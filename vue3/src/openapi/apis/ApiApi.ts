/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    AccessToken,
    AccessTokenFromJSON,
    AccessTokenToJSON,
    Automation,
    AutomationFromJSON,
    AutomationToJSON,
    BookmarkletImport,
    BookmarkletImportFromJSON,
    BookmarkletImportToJSON,
    BookmarkletImportList,
    BookmarkletImportListFromJSON,
    BookmarkletImportListToJSON,
    ConnectorConfigConfig,
    ConnectorConfigConfigFromJSON,
    ConnectorConfigConfigToJSON,
    CookLog,
    CookLogFromJSON,
    CookLogToJSON,
    CustomFilter,
    CustomFilterFromJSON,
    CustomFilterToJSON,
    ExportLog,
    ExportLogFromJSON,
    ExportLogToJSON,
    Food,
    FoodFromJSON,
    FoodToJSON,
    FoodInheritField,
    FoodInheritFieldFromJSON,
    FoodInheritFieldToJSON,
    Group,
    GroupFromJSON,
    GroupToJSON,
    ImportLog,
    ImportLogFromJSON,
    ImportLogToJSON,
    Ingredient,
    IngredientFromJSON,
    IngredientToJSON,
    InviteLink,
    InviteLinkFromJSON,
    InviteLinkToJSON,
    Keyword,
    KeywordFromJSON,
    KeywordToJSON,
    MealPlan,
    MealPlanFromJSON,
    MealPlanToJSON,
    MealType,
    MealTypeFromJSON,
    MealTypeToJSON,
    OpenDataCategory,
    OpenDataCategoryFromJSON,
    OpenDataCategoryToJSON,
    OpenDataConversion,
    OpenDataConversionFromJSON,
    OpenDataConversionToJSON,
    OpenDataFood,
    OpenDataFoodFromJSON,
    OpenDataFoodToJSON,
    OpenDataProperty,
    OpenDataPropertyFromJSON,
    OpenDataPropertyToJSON,
    OpenDataStore,
    OpenDataStoreFromJSON,
    OpenDataStoreToJSON,
    OpenDataUnit,
    OpenDataUnitFromJSON,
    OpenDataUnitToJSON,
    OpenDataVersion,
    OpenDataVersionFromJSON,
    OpenDataVersionToJSON,
    PaginatedAutomationList,
    PaginatedAutomationListFromJSON,
    PaginatedAutomationListToJSON,
    PaginatedCookLogList,
    PaginatedCookLogListFromJSON,
    PaginatedCookLogListToJSON,
    PaginatedCustomFilterList,
    PaginatedCustomFilterListFromJSON,
    PaginatedCustomFilterListToJSON,
    PaginatedExportLogList,
    PaginatedExportLogListFromJSON,
    PaginatedExportLogListToJSON,
    PaginatedFoodList,
    PaginatedFoodListFromJSON,
    PaginatedFoodListToJSON,
    PaginatedImportLogList,
    PaginatedImportLogListFromJSON,
    PaginatedImportLogListToJSON,
    PaginatedIngredientList,
    PaginatedIngredientListFromJSON,
    PaginatedIngredientListToJSON,
    PaginatedKeywordList,
    PaginatedKeywordListFromJSON,
    PaginatedKeywordListToJSON,
    PaginatedRecipeOverviewList,
    PaginatedRecipeOverviewListFromJSON,
    PaginatedRecipeOverviewListToJSON,
    PaginatedStepList,
    PaginatedStepListFromJSON,
    PaginatedStepListToJSON,
    PaginatedSupermarketCategoryRelationList,
    PaginatedSupermarketCategoryRelationListFromJSON,
    PaginatedSupermarketCategoryRelationListToJSON,
    PaginatedSyncLogList,
    PaginatedSyncLogListFromJSON,
    PaginatedSyncLogListToJSON,
    PaginatedUnitList,
    PaginatedUnitListFromJSON,
    PaginatedUnitListToJSON,
    PaginatedUserSpaceList,
    PaginatedUserSpaceListFromJSON,
    PaginatedUserSpaceListToJSON,
    PaginatedViewLogList,
    PaginatedViewLogListFromJSON,
    PaginatedViewLogListToJSON,
    PatchedAccessToken,
    PatchedAccessTokenFromJSON,
    PatchedAccessTokenToJSON,
    PatchedAutomation,
    PatchedAutomationFromJSON,
    PatchedAutomationToJSON,
    PatchedBookmarkletImport,
    PatchedBookmarkletImportFromJSON,
    PatchedBookmarkletImportToJSON,
    PatchedConnectorConfigConfig,
    PatchedConnectorConfigConfigFromJSON,
    PatchedConnectorConfigConfigToJSON,
    PatchedCookLog,
    PatchedCookLogFromJSON,
    PatchedCookLogToJSON,
    PatchedCustomFilter,
    PatchedCustomFilterFromJSON,
    PatchedCustomFilterToJSON,
    PatchedExportLog,
    PatchedExportLogFromJSON,
    PatchedExportLogToJSON,
    PatchedFood,
    PatchedFoodFromJSON,
    PatchedFoodToJSON,
    PatchedImportLog,
    PatchedImportLogFromJSON,
    PatchedImportLogToJSON,
    PatchedIngredient,
    PatchedIngredientFromJSON,
    PatchedIngredientToJSON,
    PatchedInviteLink,
    PatchedInviteLinkFromJSON,
    PatchedInviteLinkToJSON,
    PatchedKeyword,
    PatchedKeywordFromJSON,
    PatchedKeywordToJSON,
    PatchedMealPlan,
    PatchedMealPlanFromJSON,
    PatchedMealPlanToJSON,
    PatchedMealType,
    PatchedMealTypeFromJSON,
    PatchedMealTypeToJSON,
    PatchedOpenDataCategory,
    PatchedOpenDataCategoryFromJSON,
    PatchedOpenDataCategoryToJSON,
    PatchedOpenDataConversion,
    PatchedOpenDataConversionFromJSON,
    PatchedOpenDataConversionToJSON,
    PatchedOpenDataFood,
    PatchedOpenDataFoodFromJSON,
    PatchedOpenDataFoodToJSON,
    PatchedOpenDataProperty,
    PatchedOpenDataPropertyFromJSON,
    PatchedOpenDataPropertyToJSON,
    PatchedOpenDataStore,
    PatchedOpenDataStoreFromJSON,
    PatchedOpenDataStoreToJSON,
    PatchedOpenDataUnit,
    PatchedOpenDataUnitFromJSON,
    PatchedOpenDataUnitToJSON,
    PatchedOpenDataVersion,
    PatchedOpenDataVersionFromJSON,
    PatchedOpenDataVersionToJSON,
    PatchedProperty,
    PatchedPropertyFromJSON,
    PatchedPropertyToJSON,
    PatchedPropertyType,
    PatchedPropertyTypeFromJSON,
    PatchedPropertyTypeToJSON,
    PatchedRecipe,
    PatchedRecipeFromJSON,
    PatchedRecipeToJSON,
    PatchedRecipeBook,
    PatchedRecipeBookFromJSON,
    PatchedRecipeBookToJSON,
    PatchedRecipeBookEntry,
    PatchedRecipeBookEntryFromJSON,
    PatchedRecipeBookEntryToJSON,
    PatchedShoppingListEntry,
    PatchedShoppingListEntryFromJSON,
    PatchedShoppingListEntryToJSON,
    PatchedShoppingListRecipe,
    PatchedShoppingListRecipeFromJSON,
    PatchedShoppingListRecipeToJSON,
    PatchedSpace,
    PatchedSpaceFromJSON,
    PatchedSpaceToJSON,
    PatchedStep,
    PatchedStepFromJSON,
    PatchedStepToJSON,
    PatchedStorage,
    PatchedStorageFromJSON,
    PatchedStorageToJSON,
    PatchedSupermarket,
    PatchedSupermarketFromJSON,
    PatchedSupermarketToJSON,
    PatchedSupermarketCategory,
    PatchedSupermarketCategoryFromJSON,
    PatchedSupermarketCategoryToJSON,
    PatchedSupermarketCategoryRelation,
    PatchedSupermarketCategoryRelationFromJSON,
    PatchedSupermarketCategoryRelationToJSON,
    PatchedSync,
    PatchedSyncFromJSON,
    PatchedSyncToJSON,
    PatchedUnit,
    PatchedUnitFromJSON,
    PatchedUnitToJSON,
    PatchedUnitConversion,
    PatchedUnitConversionFromJSON,
    PatchedUnitConversionToJSON,
    PatchedUser,
    PatchedUserFromJSON,
    PatchedUserToJSON,
    PatchedUserPreference,
    PatchedUserPreferenceFromJSON,
    PatchedUserPreferenceToJSON,
    PatchedUserSpace,
    PatchedUserSpaceFromJSON,
    PatchedUserSpaceToJSON,
    PatchedViewLog,
    PatchedViewLogFromJSON,
    PatchedViewLogToJSON,
    Property,
    PropertyFromJSON,
    PropertyToJSON,
    PropertyType,
    PropertyTypeFromJSON,
    PropertyTypeToJSON,
    Recipe,
    RecipeFromJSON,
    RecipeToJSON,
    RecipeBook,
    RecipeBookFromJSON,
    RecipeBookToJSON,
    RecipeBookEntry,
    RecipeBookEntryFromJSON,
    RecipeBookEntryToJSON,
    RecipeFlat,
    RecipeFlatFromJSON,
    RecipeFlatToJSON,
    RecipeImage,
    RecipeImageFromJSON,
    RecipeImageToJSON,
    RecipeShoppingUpdate,
    RecipeShoppingUpdateFromJSON,
    RecipeShoppingUpdateToJSON,
    RecipeSimple,
    RecipeSimpleFromJSON,
    RecipeSimpleToJSON,
    ShoppingListEntry,
    ShoppingListEntryFromJSON,
    ShoppingListEntryToJSON,
    ShoppingListEntryBulk,
    ShoppingListEntryBulkFromJSON,
    ShoppingListEntryBulkToJSON,
    ShoppingListRecipe,
    ShoppingListRecipeFromJSON,
    ShoppingListRecipeToJSON,
    Space,
    SpaceFromJSON,
    SpaceToJSON,
    Step,
    StepFromJSON,
    StepToJSON,
    Storage,
    StorageFromJSON,
    StorageToJSON,
    Supermarket,
    SupermarketFromJSON,
    SupermarketToJSON,
    SupermarketCategory,
    SupermarketCategoryFromJSON,
    SupermarketCategoryToJSON,
    SupermarketCategoryRelation,
    SupermarketCategoryRelationFromJSON,
    SupermarketCategoryRelationToJSON,
    Sync,
    SyncFromJSON,
    SyncToJSON,
    SyncLog,
    SyncLogFromJSON,
    SyncLogToJSON,
    Unit,
    UnitFromJSON,
    UnitToJSON,
    UnitConversion,
    UnitConversionFromJSON,
    UnitConversionToJSON,
    User,
    UserFromJSON,
    UserToJSON,
    UserFile,
    UserFileFromJSON,
    UserFileToJSON,
    UserPreference,
    UserPreferenceFromJSON,
    UserPreferenceToJSON,
    UserSpace,
    UserSpaceFromJSON,
    UserSpaceToJSON,
    ViewLog,
    ViewLogFromJSON,
    ViewLogToJSON,
} from '../models';

export interface ApiAccessTokenCreateRequest {
    accessToken: AccessToken;
}

export interface ApiAccessTokenDestroyRequest {
    id: number;
}

export interface ApiAccessTokenPartialUpdateRequest {
    id: number;
    patchedAccessToken?: PatchedAccessToken;
}

export interface ApiAccessTokenRetrieveRequest {
    id: number;
}

export interface ApiAccessTokenUpdateRequest {
    id: number;
    accessToken: AccessToken;
}

export interface ApiAutomationCreateRequest {
    automation: Automation;
}

export interface ApiAutomationDestroyRequest {
    id: number;
}

export interface ApiAutomationListRequest {
    automationType?: string;
    page?: number;
    pageSize?: number;
}

export interface ApiAutomationPartialUpdateRequest {
    id: number;
    patchedAutomation?: PatchedAutomation;
}

export interface ApiAutomationRetrieveRequest {
    id: number;
}

export interface ApiAutomationUpdateRequest {
    id: number;
    automation: Automation;
}

export interface ApiBookmarkletImportCreateRequest {
    bookmarkletImport: BookmarkletImport;
}

export interface ApiBookmarkletImportDestroyRequest {
    id: number;
}

export interface ApiBookmarkletImportPartialUpdateRequest {
    id: number;
    patchedBookmarkletImport?: PatchedBookmarkletImport;
}

export interface ApiBookmarkletImportRetrieveRequest {
    id: number;
}

export interface ApiBookmarkletImportUpdateRequest {
    id: number;
    bookmarkletImport: BookmarkletImport;
}

export interface ApiConnectorConfigCreateRequest {
    connectorConfigConfig: ConnectorConfigConfig;
}

export interface ApiConnectorConfigDestroyRequest {
    id: number;
}

export interface ApiConnectorConfigPartialUpdateRequest {
    id: number;
    patchedConnectorConfigConfig?: PatchedConnectorConfigConfig;
}

export interface ApiConnectorConfigRetrieveRequest {
    id: number;
}

export interface ApiConnectorConfigUpdateRequest {
    id: number;
    connectorConfigConfig: ConnectorConfigConfig;
}

export interface ApiCookLogCreateRequest {
    cookLog: CookLog;
}

export interface ApiCookLogDestroyRequest {
    id: number;
}

export interface ApiCookLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiCookLogPartialUpdateRequest {
    id: number;
    patchedCookLog?: PatchedCookLog;
}

export interface ApiCookLogRetrieveRequest {
    id: number;
}

export interface ApiCookLogUpdateRequest {
    id: number;
    cookLog: CookLog;
}

export interface ApiCustomFilterCreateRequest {
    customFilter: CustomFilter;
}

export interface ApiCustomFilterDestroyRequest {
    id: number;
}

export interface ApiCustomFilterListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiCustomFilterPartialUpdateRequest {
    id: number;
    patchedCustomFilter?: PatchedCustomFilter;
}

export interface ApiCustomFilterRetrieveRequest {
    id: number;
}

export interface ApiCustomFilterUpdateRequest {
    id: number;
    customFilter: CustomFilter;
}

export interface ApiDownloadFileRetrieveRequest {
    fileId: number;
}

export interface ApiExportLogCreateRequest {
    exportLog: ExportLog;
}

export interface ApiExportLogDestroyRequest {
    id: number;
}

export interface ApiExportLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiExportLogPartialUpdateRequest {
    id: number;
    patchedExportLog?: PatchedExportLog;
}

export interface ApiExportLogRetrieveRequest {
    id: number;
}

export interface ApiExportLogUpdateRequest {
    id: number;
    exportLog: ExportLog;
}

export interface ApiFoodCreateRequest {
    food: Food;
}

export interface ApiFoodDestroyRequest {
    id: number;
}

export interface ApiFoodFdcCreateRequest {
    id: number;
    food: Food;
}

export interface ApiFoodInheritFieldRetrieveRequest {
    id: number;
}

export interface ApiFoodListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiFoodMergeUpdateRequest {
    id: number;
    target: string;
    food: Food;
}

export interface ApiFoodMoveUpdateRequest {
    id: number;
    parent: string;
    food: Food;
}

export interface ApiFoodPartialUpdateRequest {
    id: number;
    patchedFood?: PatchedFood;
}

export interface ApiFoodPropertyCreateRequest {
    property: Property;
}

export interface ApiFoodPropertyDestroyRequest {
    id: number;
}

export interface ApiFoodPropertyPartialUpdateRequest {
    id: number;
    patchedProperty?: PatchedProperty;
}

export interface ApiFoodPropertyRetrieveRequest {
    id: number;
}

export interface ApiFoodPropertyTypeCreateRequest {
    propertyType: PropertyType;
}

export interface ApiFoodPropertyTypeDestroyRequest {
    id: number;
}

export interface ApiFoodPropertyTypePartialUpdateRequest {
    id: number;
    patchedPropertyType?: PatchedPropertyType;
}

export interface ApiFoodPropertyTypeRetrieveRequest {
    id: number;
}

export interface ApiFoodPropertyTypeUpdateRequest {
    id: number;
    propertyType: PropertyType;
}

export interface ApiFoodPropertyUpdateRequest {
    id: number;
    property: Property;
}

export interface ApiFoodRetrieveRequest {
    id: number;
}

export interface ApiFoodUpdateRequest {
    id: number;
    food: Food;
}

export interface ApiGroupRetrieveRequest {
    id: number;
}

export interface ApiImportLogCreateRequest {
    importLog: ImportLog;
}

export interface ApiImportLogDestroyRequest {
    id: number;
}

export interface ApiImportLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiImportLogPartialUpdateRequest {
    id: number;
    patchedImportLog?: PatchedImportLog;
}

export interface ApiImportLogRetrieveRequest {
    id: number;
}

export interface ApiImportLogUpdateRequest {
    id: number;
    importLog: ImportLog;
}

export interface ApiIngredientCreateRequest {
    ingredient: Ingredient;
}

export interface ApiIngredientDestroyRequest {
    id: number;
}

export interface ApiIngredientListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiIngredientPartialUpdateRequest {
    id: number;
    patchedIngredient?: PatchedIngredient;
}

export interface ApiIngredientRetrieveRequest {
    id: number;
}

export interface ApiIngredientUpdateRequest {
    id: number;
    ingredient: Ingredient;
}

export interface ApiInviteLinkCreateRequest {
    inviteLink: InviteLink;
}

export interface ApiInviteLinkDestroyRequest {
    id: number;
}

export interface ApiInviteLinkListRequest {
    limit?: string;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiInviteLinkPartialUpdateRequest {
    id: number;
    patchedInviteLink?: PatchedInviteLink;
}

export interface ApiInviteLinkRetrieveRequest {
    id: number;
}

export interface ApiInviteLinkUpdateRequest {
    id: number;
    inviteLink: InviteLink;
}

export interface ApiKeywordCreateRequest {
    keyword: Keyword;
}

export interface ApiKeywordDestroyRequest {
    id: number;
}

export interface ApiKeywordListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiKeywordMergeUpdateRequest {
    id: number;
    target: string;
    keyword: Keyword;
}

export interface ApiKeywordMoveUpdateRequest {
    id: number;
    parent: string;
    keyword: Keyword;
}

export interface ApiKeywordPartialUpdateRequest {
    id: number;
    patchedKeyword?: PatchedKeyword;
}

export interface ApiKeywordRetrieveRequest {
    id: number;
}

export interface ApiKeywordUpdateRequest {
    id: number;
    keyword: Keyword;
}

export interface ApiMealPlanCreateRequest {
    mealPlan: MealPlan;
}

export interface ApiMealPlanDestroyRequest {
    id: number;
}

export interface ApiMealPlanListRequest {
    fromDate?: string;
    mealType?: string;
    toDate?: string;
}

export interface ApiMealPlanPartialUpdateRequest {
    id: number;
    patchedMealPlan?: PatchedMealPlan;
}

export interface ApiMealPlanRetrieveRequest {
    id: number;
}

export interface ApiMealPlanUpdateRequest {
    id: number;
    mealPlan: MealPlan;
}

export interface ApiMealTypeCreateRequest {
    mealType: MealType;
}

export interface ApiMealTypeDestroyRequest {
    id: number;
}

export interface ApiMealTypePartialUpdateRequest {
    id: number;
    patchedMealType?: PatchedMealType;
}

export interface ApiMealTypeRetrieveRequest {
    id: number;
}

export interface ApiMealTypeUpdateRequest {
    id: number;
    mealType: MealType;
}

export interface ApiOpenDataCategoryCreateRequest {
    openDataCategory: OpenDataCategory;
}

export interface ApiOpenDataCategoryDestroyRequest {
    id: number;
}

export interface ApiOpenDataCategoryPartialUpdateRequest {
    id: number;
    patchedOpenDataCategory?: PatchedOpenDataCategory;
}

export interface ApiOpenDataCategoryRetrieveRequest {
    id: number;
}

export interface ApiOpenDataCategoryUpdateRequest {
    id: number;
    openDataCategory: OpenDataCategory;
}

export interface ApiOpenDataConversionCreateRequest {
    openDataConversion: OpenDataConversion;
}

export interface ApiOpenDataConversionDestroyRequest {
    id: number;
}

export interface ApiOpenDataConversionPartialUpdateRequest {
    id: number;
    patchedOpenDataConversion?: PatchedOpenDataConversion;
}

export interface ApiOpenDataConversionRetrieveRequest {
    id: number;
}

export interface ApiOpenDataConversionUpdateRequest {
    id: number;
    openDataConversion: OpenDataConversion;
}

export interface ApiOpenDataFDCRetrieveRequest {
    id: string;
}

export interface ApiOpenDataFoodCreateRequest {
    openDataFood: OpenDataFood;
}

export interface ApiOpenDataFoodDestroyRequest {
    id: number;
}

export interface ApiOpenDataFoodPartialUpdateRequest {
    id: number;
    patchedOpenDataFood?: PatchedOpenDataFood;
}

export interface ApiOpenDataFoodRetrieveRequest {
    id: number;
}

export interface ApiOpenDataFoodUpdateRequest {
    id: number;
    openDataFood: OpenDataFood;
}

export interface ApiOpenDataPropertyCreateRequest {
    openDataProperty: OpenDataProperty;
}

export interface ApiOpenDataPropertyDestroyRequest {
    id: number;
}

export interface ApiOpenDataPropertyPartialUpdateRequest {
    id: number;
    patchedOpenDataProperty?: PatchedOpenDataProperty;
}

export interface ApiOpenDataPropertyRetrieveRequest {
    id: number;
}

export interface ApiOpenDataPropertyUpdateRequest {
    id: number;
    openDataProperty: OpenDataProperty;
}

export interface ApiOpenDataStoreCreateRequest {
    openDataStore: OpenDataStore;
}

export interface ApiOpenDataStoreDestroyRequest {
    id: number;
}

export interface ApiOpenDataStorePartialUpdateRequest {
    id: number;
    patchedOpenDataStore?: PatchedOpenDataStore;
}

export interface ApiOpenDataStoreRetrieveRequest {
    id: number;
}

export interface ApiOpenDataStoreUpdateRequest {
    id: number;
    openDataStore: OpenDataStore;
}

export interface ApiOpenDataUnitCreateRequest {
    openDataUnit: OpenDataUnit;
}

export interface ApiOpenDataUnitDestroyRequest {
    id: number;
}

export interface ApiOpenDataUnitPartialUpdateRequest {
    id: number;
    patchedOpenDataUnit?: PatchedOpenDataUnit;
}

export interface ApiOpenDataUnitRetrieveRequest {
    id: number;
}

export interface ApiOpenDataUnitUpdateRequest {
    id: number;
    openDataUnit: OpenDataUnit;
}

export interface ApiOpenDataVersionCreateRequest {
    openDataVersion: OpenDataVersion;
}

export interface ApiOpenDataVersionDestroyRequest {
    id: number;
}

export interface ApiOpenDataVersionPartialUpdateRequest {
    id: number;
    patchedOpenDataVersion?: PatchedOpenDataVersion;
}

export interface ApiOpenDataVersionRetrieveRequest {
    id: number;
}

export interface ApiOpenDataVersionUpdateRequest {
    id: number;
    openDataVersion: OpenDataVersion;
}

export interface ApiPlanIcalRetrieve2Request {
    fromDate: string;
}

export interface ApiPlanIcalRetrieve3Request {
    fromDate: string;
    toDate: string;
}

export interface ApiRecipeBookCreateRequest {
    recipeBook: RecipeBook;
}

export interface ApiRecipeBookDestroyRequest {
    id: number;
}

export interface ApiRecipeBookEntryCreateRequest {
    recipeBookEntry: RecipeBookEntry;
}

export interface ApiRecipeBookEntryDestroyRequest {
    id: number;
}

export interface ApiRecipeBookEntryPartialUpdateRequest {
    id: number;
    patchedRecipeBookEntry?: PatchedRecipeBookEntry;
}

export interface ApiRecipeBookEntryRetrieveRequest {
    id: number;
}

export interface ApiRecipeBookEntryUpdateRequest {
    id: number;
    recipeBookEntry: RecipeBookEntry;
}

export interface ApiRecipeBookListRequest {
    limit?: string;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiRecipeBookPartialUpdateRequest {
    id: number;
    patchedRecipeBook?: PatchedRecipeBook;
}

export interface ApiRecipeBookRetrieveRequest {
    id: number;
}

export interface ApiRecipeBookUpdateRequest {
    id: number;
    recipeBook: RecipeBook;
}

export interface ApiRecipeCreateRequest {
    recipe: Recipe;
}

export interface ApiRecipeDestroyRequest {
    id: number;
}

export interface ApiRecipeImageUpdateRequest {
    id: number;
    image?: string | null;
    imageUrl?: string | null;
}

export interface ApiRecipeListRequest {
    books?: string;
    booksAnd?: number;
    booksAndNot?: number;
    booksOr?: number;
    booksOrNot?: number;
    cookedon?: string;
    createdon?: string;
    foods?: number;
    foodsAnd?: number;
    foodsAndNot?: number;
    foodsOr?: number;
    foodsOrNot?: number;
    internal?: string;
    keywords?: number;
    keywordsAnd?: number;
    keywordsAndNot?: number;
    keywordsOr?: number;
    keywordsOrNot?: number;
    makenow?: string;
    _new?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    rating?: number;
    timescooked?: number;
    units?: number;
    updatedon?: string;
    viewedon?: string;
}

export interface ApiRecipePartialUpdateRequest {
    id: number;
    patchedRecipe?: PatchedRecipe;
}

export interface ApiRecipeRelatedRetrieveRequest {
    id: number;
}

export interface ApiRecipeRetrieveRequest {
    id: number;
}

export interface ApiRecipeShoppingUpdateRequest {
    id: number;
    recipeShoppingUpdate?: RecipeShoppingUpdate;
}

export interface ApiRecipeUpdateRequest {
    id: number;
    recipe: Recipe;
}

export interface ApiShareLinkRetrieveRequest {
    id: number;
}

export interface ApiShoppingListEntryBulkCreateRequest {
    shoppingListEntryBulk: ShoppingListEntryBulk;
}

export interface ApiShoppingListEntryCreateRequest {
    shoppingListEntry: ShoppingListEntry;
}

export interface ApiShoppingListEntryDestroyRequest {
    id: number;
}

export interface ApiShoppingListEntryListRequest {
    checked?: string;
    id?: number;
    supermarket?: number;
}

export interface ApiShoppingListEntryPartialUpdateRequest {
    id: number;
    patchedShoppingListEntry?: PatchedShoppingListEntry;
}

export interface ApiShoppingListEntryRetrieveRequest {
    id: number;
}

export interface ApiShoppingListEntryUpdateRequest {
    id: number;
    shoppingListEntry: ShoppingListEntry;
}

export interface ApiShoppingListRecipeCreateRequest {
    shoppingListRecipe: ShoppingListRecipe;
}

export interface ApiShoppingListRecipeDestroyRequest {
    id: number;
}

export interface ApiShoppingListRecipePartialUpdateRequest {
    id: number;
    patchedShoppingListRecipe?: PatchedShoppingListRecipe;
}

export interface ApiShoppingListRecipeRetrieveRequest {
    id: number;
}

export interface ApiShoppingListRecipeUpdateRequest {
    id: number;
    shoppingListRecipe: ShoppingListRecipe;
}

export interface ApiSpacePartialUpdateRequest {
    id: number;
    patchedSpace?: PatchedSpace;
}

export interface ApiSpaceRetrieveRequest {
    id: number;
}

export interface ApiStepCreateRequest {
    step: Step;
}

export interface ApiStepDestroyRequest {
    id: number;
}

export interface ApiStepListRequest {
    page?: number;
    pageSize?: number;
    query?: string;
    recipe?: number;
}

export interface ApiStepPartialUpdateRequest {
    id: number;
    patchedStep?: PatchedStep;
}

export interface ApiStepRetrieveRequest {
    id: number;
}

export interface ApiStepUpdateRequest {
    id: number;
    step: Step;
}

export interface ApiStorageCreateRequest {
    storage: Storage;
}

export interface ApiStorageDestroyRequest {
    id: number;
}

export interface ApiStoragePartialUpdateRequest {
    id: number;
    patchedStorage?: PatchedStorage;
}

export interface ApiStorageRetrieveRequest {
    id: number;
}

export interface ApiStorageUpdateRequest {
    id: number;
    storage: Storage;
}

export interface ApiSupermarketCategoryCreateRequest {
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCategoryDestroyRequest {
    id: number;
}

export interface ApiSupermarketCategoryMergeUpdateRequest {
    id: number;
    target: string;
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCategoryPartialUpdateRequest {
    id: number;
    patchedSupermarketCategory?: PatchedSupermarketCategory;
}

export interface ApiSupermarketCategoryRelationCreateRequest {
    supermarketCategoryRelation: SupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRelationDestroyRequest {
    id: number;
}

export interface ApiSupermarketCategoryRelationListRequest {
    limit?: string;
    page?: number;
    pageSize?: number;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiSupermarketCategoryRelationPartialUpdateRequest {
    id: number;
    patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRelationRetrieveRequest {
    id: number;
}

export interface ApiSupermarketCategoryRelationUpdateRequest {
    id: number;
    supermarketCategoryRelation: SupermarketCategoryRelation;
}

export interface ApiSupermarketCategoryRetrieveRequest {
    id: number;
}

export interface ApiSupermarketCategoryUpdateRequest {
    id: number;
    supermarketCategory: SupermarketCategory;
}

export interface ApiSupermarketCreateRequest {
    supermarket: Supermarket;
}

export interface ApiSupermarketDestroyRequest {
    id: number;
}

export interface ApiSupermarketListRequest {
    limit?: string;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiSupermarketPartialUpdateRequest {
    id: number;
    patchedSupermarket?: PatchedSupermarket;
}

export interface ApiSupermarketRetrieveRequest {
    id: number;
}

export interface ApiSupermarketUpdateRequest {
    id: number;
    supermarket: Supermarket;
}

export interface ApiSwitchActiveSpaceRetrieveRequest {
    spaceId: number;
}

export interface ApiSyncCreateRequest {
    sync: Sync;
}

export interface ApiSyncDestroyRequest {
    id: number;
}

export interface ApiSyncLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiSyncLogRetrieveRequest {
    id: number;
}

export interface ApiSyncPartialUpdateRequest {
    id: number;
    patchedSync?: PatchedSync;
}

export interface ApiSyncRetrieveRequest {
    id: number;
}

export interface ApiSyncUpdateRequest {
    id: number;
    sync: Sync;
}

export interface ApiUnitConversionCreateRequest {
    unitConversion: UnitConversion;
}

export interface ApiUnitConversionDestroyRequest {
    id: number;
}

export interface ApiUnitConversionListRequest {
    foodId?: number;
}

export interface ApiUnitConversionPartialUpdateRequest {
    id: number;
    patchedUnitConversion?: PatchedUnitConversion;
}

export interface ApiUnitConversionRetrieveRequest {
    id: number;
}

export interface ApiUnitConversionUpdateRequest {
    id: number;
    unitConversion: UnitConversion;
}

export interface ApiUnitCreateRequest {
    unit: Unit;
}

export interface ApiUnitDestroyRequest {
    id: number;
}

export interface ApiUnitListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiUnitMergeUpdateRequest {
    id: number;
    target: string;
    unit: Unit;
}

export interface ApiUnitPartialUpdateRequest {
    id: number;
    patchedUnit?: PatchedUnit;
}

export interface ApiUnitRetrieveRequest {
    id: number;
}

export interface ApiUnitUpdateRequest {
    id: number;
    unit: Unit;
}

export interface ApiUserFileCreateRequest {
    id: number;
    name: string;
    file: string;
    fileDownload: string;
    preview: string;
    fileSizeKb: number;
}

export interface ApiUserFileDestroyRequest {
    id: number;
}

export interface ApiUserFileListRequest {
    limit?: string;
    query?: string;
    random?: string;
    updatedAt?: string;
}

export interface ApiUserFilePartialUpdateRequest {
    id: number;
    id2?: number;
    name?: string;
    file?: string;
    fileDownload?: string;
    preview?: string;
    fileSizeKb?: number;
}

export interface ApiUserFileRetrieveRequest {
    id: number;
}

export interface ApiUserFileUpdateRequest {
    id: number;
    id2: number;
    name: string;
    file: string;
    fileDownload: string;
    preview: string;
    fileSizeKb: number;
}

export interface ApiUserPartialUpdateRequest {
    id: number;
    patchedUser?: PatchedUser;
}

export interface ApiUserPreferencePartialUpdateRequest {
    user: number;
    patchedUserPreference?: PatchedUserPreference;
}

export interface ApiUserPreferenceRetrieveRequest {
    user: number;
}

export interface ApiUserRetrieveRequest {
    id: number;
}

export interface ApiUserSpaceDestroyRequest {
    id: number;
}

export interface ApiUserSpaceListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiUserSpacePartialUpdateRequest {
    id: number;
    patchedUserSpace?: PatchedUserSpace;
}

export interface ApiUserSpaceRetrieveRequest {
    id: number;
}

export interface ApiViewLogCreateRequest {
    viewLog: ViewLog;
}

export interface ApiViewLogDestroyRequest {
    id: number;
}

export interface ApiViewLogListRequest {
    page?: number;
    pageSize?: number;
}

export interface ApiViewLogPartialUpdateRequest {
    id: number;
    patchedViewLog?: PatchedViewLog;
}

export interface ApiViewLogRetrieveRequest {
    id: number;
}

export interface ApiViewLogUpdateRequest {
    id: number;
    viewLog: ViewLog;
}

/**
 * 
 */
export class ApiApi extends runtime.BaseAPI {

    /**
     */
    async apiAccessTokenCreateRaw(requestParameters: ApiAccessTokenCreateRequest): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters.accessToken === null || requestParameters.accessToken === undefined) {
            throw new runtime.RequiredError('accessToken','Required parameter requestParameters.accessToken was null or undefined when calling apiAccessTokenCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccessTokenToJSON(requestParameters.accessToken),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAccessTokenCreate(requestParameters: ApiAccessTokenCreateRequest): Promise<AccessToken> {
        const response = await this.apiAccessTokenCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAccessTokenDestroyRaw(requestParameters: ApiAccessTokenDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAccessTokenDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiAccessTokenDestroy(requestParameters: ApiAccessTokenDestroyRequest): Promise<void> {
        await this.apiAccessTokenDestroyRaw(requestParameters);
    }

    /**
     */
    async apiAccessTokenListRaw(): Promise<runtime.ApiResponse<Array<AccessToken>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccessTokenFromJSON));
    }

    /**
     */
    async apiAccessTokenList(): Promise<Array<AccessToken>> {
        const response = await this.apiAccessTokenListRaw();
        return await response.value();
    }

    /**
     */
    async apiAccessTokenPartialUpdateRaw(requestParameters: ApiAccessTokenPartialUpdateRequest): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAccessTokenPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAccessTokenToJSON(requestParameters.patchedAccessToken),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAccessTokenPartialUpdate(requestParameters: ApiAccessTokenPartialUpdateRequest): Promise<AccessToken> {
        const response = await this.apiAccessTokenPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAccessTokenRetrieveRaw(requestParameters: ApiAccessTokenRetrieveRequest): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAccessTokenRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAccessTokenRetrieve(requestParameters: ApiAccessTokenRetrieveRequest): Promise<AccessToken> {
        const response = await this.apiAccessTokenRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAccessTokenUpdateRaw(requestParameters: ApiAccessTokenUpdateRequest): Promise<runtime.ApiResponse<AccessToken>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAccessTokenUpdate.');
        }

        if (requestParameters.accessToken === null || requestParameters.accessToken === undefined) {
            throw new runtime.RequiredError('accessToken','Required parameter requestParameters.accessToken was null or undefined when calling apiAccessTokenUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/access-token/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AccessTokenToJSON(requestParameters.accessToken),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccessTokenFromJSON(jsonValue));
    }

    /**
     */
    async apiAccessTokenUpdate(requestParameters: ApiAccessTokenUpdateRequest): Promise<AccessToken> {
        const response = await this.apiAccessTokenUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiAutoPlanCreateRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/auto-plan/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiAutoPlanCreate(): Promise<void> {
        await this.apiAutoPlanCreateRaw();
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationCreateRaw(requestParameters: ApiAutomationCreateRequest): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters.automation === null || requestParameters.automation === undefined) {
            throw new runtime.RequiredError('automation','Required parameter requestParameters.automation was null or undefined when calling apiAutomationCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationToJSON(requestParameters.automation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationCreate(requestParameters: ApiAutomationCreateRequest): Promise<Automation> {
        const response = await this.apiAutomationCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationDestroyRaw(requestParameters: ApiAutomationDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAutomationDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationDestroy(requestParameters: ApiAutomationDestroyRequest): Promise<void> {
        await this.apiAutomationDestroyRaw(requestParameters);
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationListRaw(requestParameters: ApiAutomationListRequest): Promise<runtime.ApiResponse<PaginatedAutomationList>> {
        const queryParameters: any = {};

        if (requestParameters.automationType !== undefined) {
            queryParameters['automation_type'] = requestParameters.automationType;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedAutomationListFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationList(requestParameters: ApiAutomationListRequest): Promise<PaginatedAutomationList> {
        const response = await this.apiAutomationListRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationPartialUpdateRaw(requestParameters: ApiAutomationPartialUpdateRequest): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAutomationPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedAutomationToJSON(requestParameters.patchedAutomation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationPartialUpdate(requestParameters: ApiAutomationPartialUpdateRequest): Promise<Automation> {
        const response = await this.apiAutomationPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationRetrieveRaw(requestParameters: ApiAutomationRetrieveRequest): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAutomationRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationRetrieve(requestParameters: ApiAutomationRetrieveRequest): Promise<Automation> {
        const response = await this.apiAutomationRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationUpdateRaw(requestParameters: ApiAutomationUpdateRequest): Promise<runtime.ApiResponse<Automation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiAutomationUpdate.');
        }

        if (requestParameters.automation === null || requestParameters.automation === undefined) {
            throw new runtime.RequiredError('automation','Required parameter requestParameters.automation was null or undefined when calling apiAutomationUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/automation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AutomationToJSON(requestParameters.automation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AutomationFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **automation_type**: Return the Automations matching the automation type.  Multiple values allowed.  *Automation Types:* - FS: Food Alias - UA: Unit Alias - KA: Keyword Alias - DR: Description Replace - IR: Instruction Replace - NU: Never Unit - TW: Transpose Words - FR: Food Replace - UR: Unit Replace - NR: Name Replace
     */
    async apiAutomationUpdate(requestParameters: ApiAutomationUpdateRequest): Promise<Automation> {
        const response = await this.apiAutomationUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiBookmarkletImportCreateRaw(requestParameters: ApiBookmarkletImportCreateRequest): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters.bookmarkletImport === null || requestParameters.bookmarkletImport === undefined) {
            throw new runtime.RequiredError('bookmarkletImport','Required parameter requestParameters.bookmarkletImport was null or undefined when calling apiBookmarkletImportCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BookmarkletImportToJSON(requestParameters.bookmarkletImport),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     */
    async apiBookmarkletImportCreate(requestParameters: ApiBookmarkletImportCreateRequest): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiBookmarkletImportDestroyRaw(requestParameters: ApiBookmarkletImportDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiBookmarkletImportDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiBookmarkletImportDestroy(requestParameters: ApiBookmarkletImportDestroyRequest): Promise<void> {
        await this.apiBookmarkletImportDestroyRaw(requestParameters);
    }

    /**
     */
    async apiBookmarkletImportListRaw(): Promise<runtime.ApiResponse<Array<BookmarkletImportList>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BookmarkletImportListFromJSON));
    }

    /**
     */
    async apiBookmarkletImportList(): Promise<Array<BookmarkletImportList>> {
        const response = await this.apiBookmarkletImportListRaw();
        return await response.value();
    }

    /**
     */
    async apiBookmarkletImportPartialUpdateRaw(requestParameters: ApiBookmarkletImportPartialUpdateRequest): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiBookmarkletImportPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedBookmarkletImportToJSON(requestParameters.patchedBookmarkletImport),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     */
    async apiBookmarkletImportPartialUpdate(requestParameters: ApiBookmarkletImportPartialUpdateRequest): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiBookmarkletImportRetrieveRaw(requestParameters: ApiBookmarkletImportRetrieveRequest): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiBookmarkletImportRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     */
    async apiBookmarkletImportRetrieve(requestParameters: ApiBookmarkletImportRetrieveRequest): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiBookmarkletImportUpdateRaw(requestParameters: ApiBookmarkletImportUpdateRequest): Promise<runtime.ApiResponse<BookmarkletImport>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiBookmarkletImportUpdate.');
        }

        if (requestParameters.bookmarkletImport === null || requestParameters.bookmarkletImport === undefined) {
            throw new runtime.RequiredError('bookmarkletImport','Required parameter requestParameters.bookmarkletImport was null or undefined when calling apiBookmarkletImportUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/bookmarklet-import/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BookmarkletImportToJSON(requestParameters.bookmarkletImport),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => BookmarkletImportFromJSON(jsonValue));
    }

    /**
     */
    async apiBookmarkletImportUpdate(requestParameters: ApiBookmarkletImportUpdateRequest): Promise<BookmarkletImport> {
        const response = await this.apiBookmarkletImportUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiConnectorConfigCreateRaw(requestParameters: ApiConnectorConfigCreateRequest): Promise<runtime.ApiResponse<ConnectorConfigConfig>> {
        if (requestParameters.connectorConfigConfig === null || requestParameters.connectorConfigConfig === undefined) {
            throw new runtime.RequiredError('connectorConfigConfig','Required parameter requestParameters.connectorConfigConfig was null or undefined when calling apiConnectorConfigCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConnectorConfigConfigToJSON(requestParameters.connectorConfigConfig),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigConfigFromJSON(jsonValue));
    }

    /**
     */
    async apiConnectorConfigCreate(requestParameters: ApiConnectorConfigCreateRequest): Promise<ConnectorConfigConfig> {
        const response = await this.apiConnectorConfigCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiConnectorConfigDestroyRaw(requestParameters: ApiConnectorConfigDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiConnectorConfigDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiConnectorConfigDestroy(requestParameters: ApiConnectorConfigDestroyRequest): Promise<void> {
        await this.apiConnectorConfigDestroyRaw(requestParameters);
    }

    /**
     */
    async apiConnectorConfigListRaw(): Promise<runtime.ApiResponse<Array<ConnectorConfigConfig>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ConnectorConfigConfigFromJSON));
    }

    /**
     */
    async apiConnectorConfigList(): Promise<Array<ConnectorConfigConfig>> {
        const response = await this.apiConnectorConfigListRaw();
        return await response.value();
    }

    /**
     */
    async apiConnectorConfigPartialUpdateRaw(requestParameters: ApiConnectorConfigPartialUpdateRequest): Promise<runtime.ApiResponse<ConnectorConfigConfig>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiConnectorConfigPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedConnectorConfigConfigToJSON(requestParameters.patchedConnectorConfigConfig),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigConfigFromJSON(jsonValue));
    }

    /**
     */
    async apiConnectorConfigPartialUpdate(requestParameters: ApiConnectorConfigPartialUpdateRequest): Promise<ConnectorConfigConfig> {
        const response = await this.apiConnectorConfigPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiConnectorConfigRetrieveRaw(requestParameters: ApiConnectorConfigRetrieveRequest): Promise<runtime.ApiResponse<ConnectorConfigConfig>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiConnectorConfigRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigConfigFromJSON(jsonValue));
    }

    /**
     */
    async apiConnectorConfigRetrieve(requestParameters: ApiConnectorConfigRetrieveRequest): Promise<ConnectorConfigConfig> {
        const response = await this.apiConnectorConfigRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiConnectorConfigUpdateRaw(requestParameters: ApiConnectorConfigUpdateRequest): Promise<runtime.ApiResponse<ConnectorConfigConfig>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiConnectorConfigUpdate.');
        }

        if (requestParameters.connectorConfigConfig === null || requestParameters.connectorConfigConfig === undefined) {
            throw new runtime.RequiredError('connectorConfigConfig','Required parameter requestParameters.connectorConfigConfig was null or undefined when calling apiConnectorConfigUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/connector-config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConnectorConfigConfigToJSON(requestParameters.connectorConfigConfig),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ConnectorConfigConfigFromJSON(jsonValue));
    }

    /**
     */
    async apiConnectorConfigUpdate(requestParameters: ApiConnectorConfigUpdateRequest): Promise<ConnectorConfigConfig> {
        const response = await this.apiConnectorConfigUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCookLogCreateRaw(requestParameters: ApiCookLogCreateRequest): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters.cookLog === null || requestParameters.cookLog === undefined) {
            throw new runtime.RequiredError('cookLog','Required parameter requestParameters.cookLog was null or undefined when calling apiCookLogCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CookLogToJSON(requestParameters.cookLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     */
    async apiCookLogCreate(requestParameters: ApiCookLogCreateRequest): Promise<CookLog> {
        const response = await this.apiCookLogCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCookLogDestroyRaw(requestParameters: ApiCookLogDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCookLogDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiCookLogDestroy(requestParameters: ApiCookLogDestroyRequest): Promise<void> {
        await this.apiCookLogDestroyRaw(requestParameters);
    }

    /**
     */
    async apiCookLogListRaw(requestParameters: ApiCookLogListRequest): Promise<runtime.ApiResponse<PaginatedCookLogList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCookLogListFromJSON(jsonValue));
    }

    /**
     */
    async apiCookLogList(requestParameters: ApiCookLogListRequest): Promise<PaginatedCookLogList> {
        const response = await this.apiCookLogListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCookLogPartialUpdateRaw(requestParameters: ApiCookLogPartialUpdateRequest): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCookLogPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCookLogToJSON(requestParameters.patchedCookLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     */
    async apiCookLogPartialUpdate(requestParameters: ApiCookLogPartialUpdateRequest): Promise<CookLog> {
        const response = await this.apiCookLogPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCookLogRetrieveRaw(requestParameters: ApiCookLogRetrieveRequest): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCookLogRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     */
    async apiCookLogRetrieve(requestParameters: ApiCookLogRetrieveRequest): Promise<CookLog> {
        const response = await this.apiCookLogRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCookLogUpdateRaw(requestParameters: ApiCookLogUpdateRequest): Promise<runtime.ApiResponse<CookLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCookLogUpdate.');
        }

        if (requestParameters.cookLog === null || requestParameters.cookLog === undefined) {
            throw new runtime.RequiredError('cookLog','Required parameter requestParameters.cookLog was null or undefined when calling apiCookLogUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/cook-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CookLogToJSON(requestParameters.cookLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CookLogFromJSON(jsonValue));
    }

    /**
     */
    async apiCookLogUpdate(requestParameters: ApiCookLogUpdateRequest): Promise<CookLog> {
        const response = await this.apiCookLogUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCustomFilterCreateRaw(requestParameters: ApiCustomFilterCreateRequest): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters.customFilter === null || requestParameters.customFilter === undefined) {
            throw new runtime.RequiredError('customFilter','Required parameter requestParameters.customFilter was null or undefined when calling apiCustomFilterCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CustomFilterToJSON(requestParameters.customFilter),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     */
    async apiCustomFilterCreate(requestParameters: ApiCustomFilterCreateRequest): Promise<CustomFilter> {
        const response = await this.apiCustomFilterCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCustomFilterDestroyRaw(requestParameters: ApiCustomFilterDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCustomFilterDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiCustomFilterDestroy(requestParameters: ApiCustomFilterDestroyRequest): Promise<void> {
        await this.apiCustomFilterDestroyRaw(requestParameters);
    }

    /**
     */
    async apiCustomFilterListRaw(requestParameters: ApiCustomFilterListRequest): Promise<runtime.ApiResponse<PaginatedCustomFilterList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCustomFilterListFromJSON(jsonValue));
    }

    /**
     */
    async apiCustomFilterList(requestParameters: ApiCustomFilterListRequest): Promise<PaginatedCustomFilterList> {
        const response = await this.apiCustomFilterListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCustomFilterPartialUpdateRaw(requestParameters: ApiCustomFilterPartialUpdateRequest): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCustomFilterPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCustomFilterToJSON(requestParameters.patchedCustomFilter),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     */
    async apiCustomFilterPartialUpdate(requestParameters: ApiCustomFilterPartialUpdateRequest): Promise<CustomFilter> {
        const response = await this.apiCustomFilterPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCustomFilterRetrieveRaw(requestParameters: ApiCustomFilterRetrieveRequest): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCustomFilterRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     */
    async apiCustomFilterRetrieve(requestParameters: ApiCustomFilterRetrieveRequest): Promise<CustomFilter> {
        const response = await this.apiCustomFilterRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiCustomFilterUpdateRaw(requestParameters: ApiCustomFilterUpdateRequest): Promise<runtime.ApiResponse<CustomFilter>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiCustomFilterUpdate.');
        }

        if (requestParameters.customFilter === null || requestParameters.customFilter === undefined) {
            throw new runtime.RequiredError('customFilter','Required parameter requestParameters.customFilter was null or undefined when calling apiCustomFilterUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/custom-filter/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CustomFilterToJSON(requestParameters.customFilter),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => CustomFilterFromJSON(jsonValue));
    }

    /**
     */
    async apiCustomFilterUpdate(requestParameters: ApiCustomFilterUpdateRequest): Promise<CustomFilter> {
        const response = await this.apiCustomFilterUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     */
    async apiDownloadFileRetrieveRaw(requestParameters: ApiDownloadFileRetrieveRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.fileId === null || requestParameters.fileId === undefined) {
            throw new runtime.RequiredError('fileId','Required parameter requestParameters.fileId was null or undefined when calling apiDownloadFileRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/download-file/{file_id}/`.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters.fileId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     */
    async apiDownloadFileRetrieve(requestParameters: ApiDownloadFileRetrieveRequest): Promise<void> {
        await this.apiDownloadFileRetrieveRaw(requestParameters);
    }

    /**
     */
    async apiExportLogCreateRaw(requestParameters: ApiExportLogCreateRequest): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters.exportLog === null || requestParameters.exportLog === undefined) {
            throw new runtime.RequiredError('exportLog','Required parameter requestParameters.exportLog was null or undefined when calling apiExportLogCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ExportLogToJSON(requestParameters.exportLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiExportLogCreate(requestParameters: ApiExportLogCreateRequest): Promise<ExportLog> {
        const response = await this.apiExportLogCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExportLogDestroyRaw(requestParameters: ApiExportLogDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExportLogDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiExportLogDestroy(requestParameters: ApiExportLogDestroyRequest): Promise<void> {
        await this.apiExportLogDestroyRaw(requestParameters);
    }

    /**
     */
    async apiExportLogListRaw(requestParameters: ApiExportLogListRequest): Promise<runtime.ApiResponse<PaginatedExportLogList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedExportLogListFromJSON(jsonValue));
    }

    /**
     */
    async apiExportLogList(requestParameters: ApiExportLogListRequest): Promise<PaginatedExportLogList> {
        const response = await this.apiExportLogListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExportLogPartialUpdateRaw(requestParameters: ApiExportLogPartialUpdateRequest): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExportLogPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedExportLogToJSON(requestParameters.patchedExportLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiExportLogPartialUpdate(requestParameters: ApiExportLogPartialUpdateRequest): Promise<ExportLog> {
        const response = await this.apiExportLogPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExportLogRetrieveRaw(requestParameters: ApiExportLogRetrieveRequest): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExportLogRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiExportLogRetrieve(requestParameters: ApiExportLogRetrieveRequest): Promise<ExportLog> {
        const response = await this.apiExportLogRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiExportLogUpdateRaw(requestParameters: ApiExportLogUpdateRequest): Promise<runtime.ApiResponse<ExportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiExportLogUpdate.');
        }

        if (requestParameters.exportLog === null || requestParameters.exportLog === undefined) {
            throw new runtime.RequiredError('exportLog','Required parameter requestParameters.exportLog was null or undefined when calling apiExportLogUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/export-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ExportLogToJSON(requestParameters.exportLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ExportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiExportLogUpdate(requestParameters: ApiExportLogUpdateRequest): Promise<ExportLog> {
        const response = await this.apiExportLogUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodCreateRaw(requestParameters: ApiFoodCreateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.food === null || requestParameters.food === undefined) {
            throw new runtime.RequiredError('food','Required parameter requestParameters.food was null or undefined when calling apiFoodCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters.food),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodCreate(requestParameters: ApiFoodCreateRequest): Promise<Food> {
        const response = await this.apiFoodCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodDestroyRaw(requestParameters: ApiFoodDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiFoodDestroy(requestParameters: ApiFoodDestroyRequest): Promise<void> {
        await this.apiFoodDestroyRaw(requestParameters);
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     */
    async apiFoodFdcCreateRaw(requestParameters: ApiFoodFdcCreateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodFdcCreate.');
        }

        if (requestParameters.food === null || requestParameters.food === undefined) {
            throw new runtime.RequiredError('food','Required parameter requestParameters.food was null or undefined when calling apiFoodFdcCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/fdc/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters.food),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     */
    async apiFoodFdcCreate(requestParameters: ApiFoodFdcCreateRequest): Promise<Food> {
        const response = await this.apiFoodFdcCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodInheritFieldListRaw(): Promise<runtime.ApiResponse<Array<FoodInheritField>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-inherit-field/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(FoodInheritFieldFromJSON));
    }

    /**
     */
    async apiFoodInheritFieldList(): Promise<Array<FoodInheritField>> {
        const response = await this.apiFoodInheritFieldListRaw();
        return await response.value();
    }

    /**
     */
    async apiFoodInheritFieldRetrieveRaw(requestParameters: ApiFoodInheritFieldRetrieveRequest): Promise<runtime.ApiResponse<FoodInheritField>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodInheritFieldRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-inherit-field/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodInheritFieldFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodInheritFieldRetrieve(requestParameters: ApiFoodInheritFieldRetrieveRequest): Promise<FoodInheritField> {
        const response = await this.apiFoodInheritFieldRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodListRaw(requestParameters: ApiFoodListRequest): Promise<runtime.ApiResponse<PaginatedFoodList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedFoodListFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodList(requestParameters: ApiFoodListRequest): Promise<PaginatedFoodList> {
        const response = await this.apiFoodListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodMergeUpdateRaw(requestParameters: ApiFoodMergeUpdateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodMergeUpdate.');
        }

        if (requestParameters.target === null || requestParameters.target === undefined) {
            throw new runtime.RequiredError('target','Required parameter requestParameters.target was null or undefined when calling apiFoodMergeUpdate.');
        }

        if (requestParameters.food === null || requestParameters.food === undefined) {
            throw new runtime.RequiredError('food','Required parameter requestParameters.food was null or undefined when calling apiFoodMergeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters.target))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters.food),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodMergeUpdate(requestParameters: ApiFoodMergeUpdateRequest): Promise<Food> {
        const response = await this.apiFoodMergeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodMoveUpdateRaw(requestParameters: ApiFoodMoveUpdateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodMoveUpdate.');
        }

        if (requestParameters.parent === null || requestParameters.parent === undefined) {
            throw new runtime.RequiredError('parent','Required parameter requestParameters.parent was null or undefined when calling apiFoodMoveUpdate.');
        }

        if (requestParameters.food === null || requestParameters.food === undefined) {
            throw new runtime.RequiredError('food','Required parameter requestParameters.food was null or undefined when calling apiFoodMoveUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/move/{parent}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"parent"}}`, encodeURIComponent(String(requestParameters.parent))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters.food),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodMoveUpdate(requestParameters: ApiFoodMoveUpdateRequest): Promise<Food> {
        const response = await this.apiFoodMoveUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPartialUpdateRaw(requestParameters: ApiFoodPartialUpdateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedFoodToJSON(requestParameters.patchedFood),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPartialUpdate(requestParameters: ApiFoodPartialUpdateRequest): Promise<Food> {
        const response = await this.apiFoodPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyCreateRaw(requestParameters: ApiFoodPropertyCreateRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.property === null || requestParameters.property === undefined) {
            throw new runtime.RequiredError('property','Required parameter requestParameters.property was null or undefined when calling apiFoodPropertyCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters.property),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyCreate(requestParameters: ApiFoodPropertyCreateRequest): Promise<Property> {
        const response = await this.apiFoodPropertyCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyDestroyRaw(requestParameters: ApiFoodPropertyDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiFoodPropertyDestroy(requestParameters: ApiFoodPropertyDestroyRequest): Promise<void> {
        await this.apiFoodPropertyDestroyRaw(requestParameters);
    }

    /**
     */
    async apiFoodPropertyListRaw(): Promise<runtime.ApiResponse<Array<Property>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyFromJSON));
    }

    /**
     */
    async apiFoodPropertyList(): Promise<Array<Property>> {
        const response = await this.apiFoodPropertyListRaw();
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyPartialUpdateRaw(requestParameters: ApiFoodPropertyPartialUpdateRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyToJSON(requestParameters.patchedProperty),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyPartialUpdate(requestParameters: ApiFoodPropertyPartialUpdateRequest): Promise<Property> {
        const response = await this.apiFoodPropertyPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyRetrieveRaw(requestParameters: ApiFoodPropertyRetrieveRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyRetrieve(requestParameters: ApiFoodPropertyRetrieveRequest): Promise<Property> {
        const response = await this.apiFoodPropertyRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyTypeCreateRaw(requestParameters: ApiFoodPropertyTypeCreateRequest): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters.propertyType === null || requestParameters.propertyType === undefined) {
            throw new runtime.RequiredError('propertyType','Required parameter requestParameters.propertyType was null or undefined when calling apiFoodPropertyTypeCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyTypeToJSON(requestParameters.propertyType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyTypeCreate(requestParameters: ApiFoodPropertyTypeCreateRequest): Promise<PropertyType> {
        const response = await this.apiFoodPropertyTypeCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyTypeDestroyRaw(requestParameters: ApiFoodPropertyTypeDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyTypeDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiFoodPropertyTypeDestroy(requestParameters: ApiFoodPropertyTypeDestroyRequest): Promise<void> {
        await this.apiFoodPropertyTypeDestroyRaw(requestParameters);
    }

    /**
     */
    async apiFoodPropertyTypeListRaw(): Promise<runtime.ApiResponse<Array<PropertyType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(PropertyTypeFromJSON));
    }

    /**
     */
    async apiFoodPropertyTypeList(): Promise<Array<PropertyType>> {
        const response = await this.apiFoodPropertyTypeListRaw();
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyTypePartialUpdateRaw(requestParameters: ApiFoodPropertyTypePartialUpdateRequest): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyTypePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPropertyTypeToJSON(requestParameters.patchedPropertyType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyTypePartialUpdate(requestParameters: ApiFoodPropertyTypePartialUpdateRequest): Promise<PropertyType> {
        const response = await this.apiFoodPropertyTypePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyTypeRetrieveRaw(requestParameters: ApiFoodPropertyTypeRetrieveRequest): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyTypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyTypeRetrieve(requestParameters: ApiFoodPropertyTypeRetrieveRequest): Promise<PropertyType> {
        const response = await this.apiFoodPropertyTypeRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyTypeUpdateRaw(requestParameters: ApiFoodPropertyTypeUpdateRequest): Promise<runtime.ApiResponse<PropertyType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyTypeUpdate.');
        }

        if (requestParameters.propertyType === null || requestParameters.propertyType === undefined) {
            throw new runtime.RequiredError('propertyType','Required parameter requestParameters.propertyType was null or undefined when calling apiFoodPropertyTypeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyTypeToJSON(requestParameters.propertyType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyTypeFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyTypeUpdate(requestParameters: ApiFoodPropertyTypeUpdateRequest): Promise<PropertyType> {
        const response = await this.apiFoodPropertyTypeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodPropertyUpdateRaw(requestParameters: ApiFoodPropertyUpdateRequest): Promise<runtime.ApiResponse<Property>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodPropertyUpdate.');
        }

        if (requestParameters.property === null || requestParameters.property === undefined) {
            throw new runtime.RequiredError('property','Required parameter requestParameters.property was null or undefined when calling apiFoodPropertyUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PropertyToJSON(requestParameters.property),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodPropertyUpdate(requestParameters: ApiFoodPropertyUpdateRequest): Promise<Property> {
        const response = await this.apiFoodPropertyUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodRetrieveRaw(requestParameters: ApiFoodRetrieveRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodRetrieve(requestParameters: ApiFoodRetrieveRequest): Promise<Food> {
        const response = await this.apiFoodRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiFoodUpdateRaw(requestParameters: ApiFoodUpdateRequest): Promise<runtime.ApiResponse<Food>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiFoodUpdate.');
        }

        if (requestParameters.food === null || requestParameters.food === undefined) {
            throw new runtime.RequiredError('food','Required parameter requestParameters.food was null or undefined when calling apiFoodUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: FoodToJSON(requestParameters.food),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => FoodFromJSON(jsonValue));
    }

    /**
     */
    async apiFoodUpdate(requestParameters: ApiFoodUpdateRequest): Promise<Food> {
        const response = await this.apiFoodUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiGroupListRaw(): Promise<runtime.ApiResponse<Array<Group>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/group/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(GroupFromJSON));
    }

    /**
     */
    async apiGroupList(): Promise<Array<Group>> {
        const response = await this.apiGroupListRaw();
        return await response.value();
    }

    /**
     */
    async apiGroupRetrieveRaw(requestParameters: ApiGroupRetrieveRequest): Promise<runtime.ApiResponse<Group>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiGroupRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/group/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => GroupFromJSON(jsonValue));
    }

    /**
     */
    async apiGroupRetrieve(requestParameters: ApiGroupRetrieveRequest): Promise<Group> {
        const response = await this.apiGroupRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * function to handle files passed by application importer
     */
    async apiImportCreateRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to handle files passed by application importer
     */
    async apiImportCreate(): Promise<void> {
        await this.apiImportCreateRaw();
    }

    /**
     */
    async apiImportLogCreateRaw(requestParameters: ApiImportLogCreateRequest): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters.importLog === null || requestParameters.importLog === undefined) {
            throw new runtime.RequiredError('importLog','Required parameter requestParameters.importLog was null or undefined when calling apiImportLogCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImportLogToJSON(requestParameters.importLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiImportLogCreate(requestParameters: ApiImportLogCreateRequest): Promise<ImportLog> {
        const response = await this.apiImportLogCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiImportLogDestroyRaw(requestParameters: ApiImportLogDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiImportLogDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiImportLogDestroy(requestParameters: ApiImportLogDestroyRequest): Promise<void> {
        await this.apiImportLogDestroyRaw(requestParameters);
    }

    /**
     */
    async apiImportLogListRaw(requestParameters: ApiImportLogListRequest): Promise<runtime.ApiResponse<PaginatedImportLogList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedImportLogListFromJSON(jsonValue));
    }

    /**
     */
    async apiImportLogList(requestParameters: ApiImportLogListRequest): Promise<PaginatedImportLogList> {
        const response = await this.apiImportLogListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiImportLogPartialUpdateRaw(requestParameters: ApiImportLogPartialUpdateRequest): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiImportLogPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedImportLogToJSON(requestParameters.patchedImportLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiImportLogPartialUpdate(requestParameters: ApiImportLogPartialUpdateRequest): Promise<ImportLog> {
        const response = await this.apiImportLogPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiImportLogRetrieveRaw(requestParameters: ApiImportLogRetrieveRequest): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiImportLogRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiImportLogRetrieve(requestParameters: ApiImportLogRetrieveRequest): Promise<ImportLog> {
        const response = await this.apiImportLogRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiImportLogUpdateRaw(requestParameters: ApiImportLogUpdateRequest): Promise<runtime.ApiResponse<ImportLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiImportLogUpdate.');
        }

        if (requestParameters.importLog === null || requestParameters.importLog === undefined) {
            throw new runtime.RequiredError('importLog','Required parameter requestParameters.importLog was null or undefined when calling apiImportLogUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/import-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ImportLogToJSON(requestParameters.importLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ImportLogFromJSON(jsonValue));
    }

    /**
     */
    async apiImportLogUpdate(requestParameters: ApiImportLogUpdateRequest): Promise<ImportLog> {
        const response = await this.apiImportLogUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiIngredientCreateRaw(requestParameters: ApiIngredientCreateRequest): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters.ingredient === null || requestParameters.ingredient === undefined) {
            throw new runtime.RequiredError('ingredient','Required parameter requestParameters.ingredient was null or undefined when calling apiIngredientCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IngredientToJSON(requestParameters.ingredient),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientCreate(requestParameters: ApiIngredientCreateRequest): Promise<Ingredient> {
        const response = await this.apiIngredientCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiIngredientDestroyRaw(requestParameters: ApiIngredientDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiIngredientDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiIngredientDestroy(requestParameters: ApiIngredientDestroyRequest): Promise<void> {
        await this.apiIngredientDestroyRaw(requestParameters);
    }

    /**
     */
    async apiIngredientListRaw(requestParameters: ApiIngredientListRequest): Promise<runtime.ApiResponse<PaginatedIngredientList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedIngredientListFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientList(requestParameters: ApiIngredientListRequest): Promise<PaginatedIngredientList> {
        const response = await this.apiIngredientListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiIngredientPartialUpdateRaw(requestParameters: ApiIngredientPartialUpdateRequest): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiIngredientPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedIngredientToJSON(requestParameters.patchedIngredient),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientPartialUpdate(requestParameters: ApiIngredientPartialUpdateRequest): Promise<Ingredient> {
        const response = await this.apiIngredientPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiIngredientRetrieveRaw(requestParameters: ApiIngredientRetrieveRequest): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiIngredientRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientRetrieve(requestParameters: ApiIngredientRetrieveRequest): Promise<Ingredient> {
        const response = await this.apiIngredientRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiIngredientUpdateRaw(requestParameters: ApiIngredientUpdateRequest): Promise<runtime.ApiResponse<Ingredient>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiIngredientUpdate.');
        }

        if (requestParameters.ingredient === null || requestParameters.ingredient === undefined) {
            throw new runtime.RequiredError('ingredient','Required parameter requestParameters.ingredient was null or undefined when calling apiIngredientUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/ingredient/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: IngredientToJSON(requestParameters.ingredient),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => IngredientFromJSON(jsonValue));
    }

    /**
     */
    async apiIngredientUpdate(requestParameters: ApiIngredientUpdateRequest): Promise<Ingredient> {
        const response = await this.apiIngredientUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiInviteLinkCreateRaw(requestParameters: ApiInviteLinkCreateRequest): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters.inviteLink === null || requestParameters.inviteLink === undefined) {
            throw new runtime.RequiredError('inviteLink','Required parameter requestParameters.inviteLink was null or undefined when calling apiInviteLinkCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: InviteLinkToJSON(requestParameters.inviteLink),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     */
    async apiInviteLinkCreate(requestParameters: ApiInviteLinkCreateRequest): Promise<InviteLink> {
        const response = await this.apiInviteLinkCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiInviteLinkDestroyRaw(requestParameters: ApiInviteLinkDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInviteLinkDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiInviteLinkDestroy(requestParameters: ApiInviteLinkDestroyRequest): Promise<void> {
        await this.apiInviteLinkDestroyRaw(requestParameters);
    }

    /**
     */
    async apiInviteLinkListRaw(requestParameters: ApiInviteLinkListRequest): Promise<runtime.ApiResponse<Array<InviteLink>>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(InviteLinkFromJSON));
    }

    /**
     */
    async apiInviteLinkList(requestParameters: ApiInviteLinkListRequest): Promise<Array<InviteLink>> {
        const response = await this.apiInviteLinkListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiInviteLinkPartialUpdateRaw(requestParameters: ApiInviteLinkPartialUpdateRequest): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInviteLinkPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedInviteLinkToJSON(requestParameters.patchedInviteLink),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     */
    async apiInviteLinkPartialUpdate(requestParameters: ApiInviteLinkPartialUpdateRequest): Promise<InviteLink> {
        const response = await this.apiInviteLinkPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiInviteLinkRetrieveRaw(requestParameters: ApiInviteLinkRetrieveRequest): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInviteLinkRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     */
    async apiInviteLinkRetrieve(requestParameters: ApiInviteLinkRetrieveRequest): Promise<InviteLink> {
        const response = await this.apiInviteLinkRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiInviteLinkUpdateRaw(requestParameters: ApiInviteLinkUpdateRequest): Promise<runtime.ApiResponse<InviteLink>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiInviteLinkUpdate.');
        }

        if (requestParameters.inviteLink === null || requestParameters.inviteLink === undefined) {
            throw new runtime.RequiredError('inviteLink','Required parameter requestParameters.inviteLink was null or undefined when calling apiInviteLinkUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/invite-link/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: InviteLinkToJSON(requestParameters.inviteLink),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => InviteLinkFromJSON(jsonValue));
    }

    /**
     */
    async apiInviteLinkUpdate(requestParameters: ApiInviteLinkUpdateRequest): Promise<InviteLink> {
        const response = await this.apiInviteLinkUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordCreateRaw(requestParameters: ApiKeywordCreateRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.keyword === null || requestParameters.keyword === undefined) {
            throw new runtime.RequiredError('keyword','Required parameter requestParameters.keyword was null or undefined when calling apiKeywordCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters.keyword),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordCreate(requestParameters: ApiKeywordCreateRequest): Promise<Keyword> {
        const response = await this.apiKeywordCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordDestroyRaw(requestParameters: ApiKeywordDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiKeywordDestroy(requestParameters: ApiKeywordDestroyRequest): Promise<void> {
        await this.apiKeywordDestroyRaw(requestParameters);
    }

    /**
     */
    async apiKeywordListRaw(requestParameters: ApiKeywordListRequest): Promise<runtime.ApiResponse<PaginatedKeywordList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedKeywordListFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordList(requestParameters: ApiKeywordListRequest): Promise<PaginatedKeywordList> {
        const response = await this.apiKeywordListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordMergeUpdateRaw(requestParameters: ApiKeywordMergeUpdateRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordMergeUpdate.');
        }

        if (requestParameters.target === null || requestParameters.target === undefined) {
            throw new runtime.RequiredError('target','Required parameter requestParameters.target was null or undefined when calling apiKeywordMergeUpdate.');
        }

        if (requestParameters.keyword === null || requestParameters.keyword === undefined) {
            throw new runtime.RequiredError('keyword','Required parameter requestParameters.keyword was null or undefined when calling apiKeywordMergeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters.target))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters.keyword),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordMergeUpdate(requestParameters: ApiKeywordMergeUpdateRequest): Promise<Keyword> {
        const response = await this.apiKeywordMergeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordMoveUpdateRaw(requestParameters: ApiKeywordMoveUpdateRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordMoveUpdate.');
        }

        if (requestParameters.parent === null || requestParameters.parent === undefined) {
            throw new runtime.RequiredError('parent','Required parameter requestParameters.parent was null or undefined when calling apiKeywordMoveUpdate.');
        }

        if (requestParameters.keyword === null || requestParameters.keyword === undefined) {
            throw new runtime.RequiredError('keyword','Required parameter requestParameters.keyword was null or undefined when calling apiKeywordMoveUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/move/{parent}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"parent"}}`, encodeURIComponent(String(requestParameters.parent))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters.keyword),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordMoveUpdate(requestParameters: ApiKeywordMoveUpdateRequest): Promise<Keyword> {
        const response = await this.apiKeywordMoveUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordPartialUpdateRaw(requestParameters: ApiKeywordPartialUpdateRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedKeywordToJSON(requestParameters.patchedKeyword),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordPartialUpdate(requestParameters: ApiKeywordPartialUpdateRequest): Promise<Keyword> {
        const response = await this.apiKeywordPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordRetrieveRaw(requestParameters: ApiKeywordRetrieveRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordRetrieve(requestParameters: ApiKeywordRetrieveRequest): Promise<Keyword> {
        const response = await this.apiKeywordRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiKeywordUpdateRaw(requestParameters: ApiKeywordUpdateRequest): Promise<runtime.ApiResponse<Keyword>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiKeywordUpdate.');
        }

        if (requestParameters.keyword === null || requestParameters.keyword === undefined) {
            throw new runtime.RequiredError('keyword','Required parameter requestParameters.keyword was null or undefined when calling apiKeywordUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/keyword/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordToJSON(requestParameters.keyword),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordFromJSON(jsonValue));
    }

    /**
     */
    async apiKeywordUpdate(requestParameters: ApiKeywordUpdateRequest): Promise<Keyword> {
        const response = await this.apiKeywordUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanCreateRaw(requestParameters: ApiMealPlanCreateRequest): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters.mealPlan === null || requestParameters.mealPlan === undefined) {
            throw new runtime.RequiredError('mealPlan','Required parameter requestParameters.mealPlan was null or undefined when calling apiMealPlanCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MealPlanToJSON(requestParameters.mealPlan),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanCreate(requestParameters: ApiMealPlanCreateRequest): Promise<MealPlan> {
        const response = await this.apiMealPlanCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanDestroyRaw(requestParameters: ApiMealPlanDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealPlanDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanDestroy(requestParameters: ApiMealPlanDestroyRequest): Promise<void> {
        await this.apiMealPlanDestroyRaw(requestParameters);
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanListRaw(requestParameters: ApiMealPlanListRequest): Promise<runtime.ApiResponse<Array<MealPlan>>> {
        const queryParameters: any = {};

        if (requestParameters.fromDate !== undefined) {
            queryParameters['from_date'] = requestParameters.fromDate;
        }

        if (requestParameters.mealType !== undefined) {
            queryParameters['meal_type'] = requestParameters.mealType;
        }

        if (requestParameters.toDate !== undefined) {
            queryParameters['to_date'] = requestParameters.toDate;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MealPlanFromJSON));
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanList(requestParameters: ApiMealPlanListRequest): Promise<Array<MealPlan>> {
        const response = await this.apiMealPlanListRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanPartialUpdateRaw(requestParameters: ApiMealPlanPartialUpdateRequest): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealPlanPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedMealPlanToJSON(requestParameters.patchedMealPlan),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanPartialUpdate(requestParameters: ApiMealPlanPartialUpdateRequest): Promise<MealPlan> {
        const response = await this.apiMealPlanPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanRetrieveRaw(requestParameters: ApiMealPlanRetrieveRequest): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealPlanRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanRetrieve(requestParameters: ApiMealPlanRetrieveRequest): Promise<MealPlan> {
        const response = await this.apiMealPlanRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanUpdateRaw(requestParameters: ApiMealPlanUpdateRequest): Promise<runtime.ApiResponse<MealPlan>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealPlanUpdate.');
        }

        if (requestParameters.mealPlan === null || requestParameters.mealPlan === undefined) {
            throw new runtime.RequiredError('mealPlan','Required parameter requestParameters.mealPlan was null or undefined when calling apiMealPlanUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-plan/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MealPlanToJSON(requestParameters.mealPlan),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealPlanFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **from_date**: filter from (inclusive) a certain date onward - **to_date**: filter upward to (inclusive) certain date - **meal_type**: filter meal plans based on meal_type ID
     */
    async apiMealPlanUpdate(requestParameters: ApiMealPlanUpdateRequest): Promise<MealPlan> {
        const response = await this.apiMealPlanUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeCreateRaw(requestParameters: ApiMealTypeCreateRequest): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters.mealType === null || requestParameters.mealType === undefined) {
            throw new runtime.RequiredError('mealType','Required parameter requestParameters.mealType was null or undefined when calling apiMealTypeCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: MealTypeToJSON(requestParameters.mealType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeCreate(requestParameters: ApiMealTypeCreateRequest): Promise<MealType> {
        const response = await this.apiMealTypeCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeDestroyRaw(requestParameters: ApiMealTypeDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealTypeDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeDestroy(requestParameters: ApiMealTypeDestroyRequest): Promise<void> {
        await this.apiMealTypeDestroyRaw(requestParameters);
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeListRaw(): Promise<runtime.ApiResponse<Array<MealType>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MealTypeFromJSON));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeList(): Promise<Array<MealType>> {
        const response = await this.apiMealTypeListRaw();
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypePartialUpdateRaw(requestParameters: ApiMealTypePartialUpdateRequest): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealTypePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedMealTypeToJSON(requestParameters.patchedMealType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypePartialUpdate(requestParameters: ApiMealTypePartialUpdateRequest): Promise<MealType> {
        const response = await this.apiMealTypePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeRetrieveRaw(requestParameters: ApiMealTypeRetrieveRequest): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealTypeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeRetrieve(requestParameters: ApiMealTypeRetrieveRequest): Promise<MealType> {
        const response = await this.apiMealTypeRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeUpdateRaw(requestParameters: ApiMealTypeUpdateRequest): Promise<runtime.ApiResponse<MealType>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiMealTypeUpdate.');
        }

        if (requestParameters.mealType === null || requestParameters.mealType === undefined) {
            throw new runtime.RequiredError('mealType','Required parameter requestParameters.mealType was null or undefined when calling apiMealTypeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/meal-type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: MealTypeToJSON(requestParameters.mealType),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => MealTypeFromJSON(jsonValue));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     */
    async apiMealTypeUpdate(requestParameters: ApiMealTypeUpdateRequest): Promise<MealType> {
        const response = await this.apiMealTypeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataCategoryCreateRaw(requestParameters: ApiOpenDataCategoryCreateRequest): Promise<runtime.ApiResponse<OpenDataCategory>> {
        if (requestParameters.openDataCategory === null || requestParameters.openDataCategory === undefined) {
            throw new runtime.RequiredError('openDataCategory','Required parameter requestParameters.openDataCategory was null or undefined when calling apiOpenDataCategoryCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataCategoryToJSON(requestParameters.openDataCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataCategoryCreate(requestParameters: ApiOpenDataCategoryCreateRequest): Promise<OpenDataCategory> {
        const response = await this.apiOpenDataCategoryCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataCategoryDestroyRaw(requestParameters: ApiOpenDataCategoryDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataCategoryDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataCategoryDestroy(requestParameters: ApiOpenDataCategoryDestroyRequest): Promise<void> {
        await this.apiOpenDataCategoryDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataCategoryListRaw(): Promise<runtime.ApiResponse<Array<OpenDataCategory>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataCategoryFromJSON));
    }

    /**
     */
    async apiOpenDataCategoryList(): Promise<Array<OpenDataCategory>> {
        const response = await this.apiOpenDataCategoryListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataCategoryPartialUpdateRaw(requestParameters: ApiOpenDataCategoryPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataCategoryPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataCategoryToJSON(requestParameters.patchedOpenDataCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataCategoryPartialUpdate(requestParameters: ApiOpenDataCategoryPartialUpdateRequest): Promise<OpenDataCategory> {
        const response = await this.apiOpenDataCategoryPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataCategoryRetrieveRaw(requestParameters: ApiOpenDataCategoryRetrieveRequest): Promise<runtime.ApiResponse<OpenDataCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataCategoryRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataCategoryRetrieve(requestParameters: ApiOpenDataCategoryRetrieveRequest): Promise<OpenDataCategory> {
        const response = await this.apiOpenDataCategoryRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataCategoryUpdateRaw(requestParameters: ApiOpenDataCategoryUpdateRequest): Promise<runtime.ApiResponse<OpenDataCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataCategoryUpdate.');
        }

        if (requestParameters.openDataCategory === null || requestParameters.openDataCategory === undefined) {
            throw new runtime.RequiredError('openDataCategory','Required parameter requestParameters.openDataCategory was null or undefined when calling apiOpenDataCategoryUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataCategoryToJSON(requestParameters.openDataCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataCategoryUpdate(requestParameters: ApiOpenDataCategoryUpdateRequest): Promise<OpenDataCategory> {
        const response = await this.apiOpenDataCategoryUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataConversionCreateRaw(requestParameters: ApiOpenDataConversionCreateRequest): Promise<runtime.ApiResponse<OpenDataConversion>> {
        if (requestParameters.openDataConversion === null || requestParameters.openDataConversion === undefined) {
            throw new runtime.RequiredError('openDataConversion','Required parameter requestParameters.openDataConversion was null or undefined when calling apiOpenDataConversionCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataConversionToJSON(requestParameters.openDataConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataConversionCreate(requestParameters: ApiOpenDataConversionCreateRequest): Promise<OpenDataConversion> {
        const response = await this.apiOpenDataConversionCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataConversionDestroyRaw(requestParameters: ApiOpenDataConversionDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataConversionDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataConversionDestroy(requestParameters: ApiOpenDataConversionDestroyRequest): Promise<void> {
        await this.apiOpenDataConversionDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataConversionListRaw(): Promise<runtime.ApiResponse<Array<OpenDataConversion>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataConversionFromJSON));
    }

    /**
     */
    async apiOpenDataConversionList(): Promise<Array<OpenDataConversion>> {
        const response = await this.apiOpenDataConversionListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataConversionPartialUpdateRaw(requestParameters: ApiOpenDataConversionPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataConversionPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataConversionToJSON(requestParameters.patchedOpenDataConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataConversionPartialUpdate(requestParameters: ApiOpenDataConversionPartialUpdateRequest): Promise<OpenDataConversion> {
        const response = await this.apiOpenDataConversionPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataConversionRetrieveRaw(requestParameters: ApiOpenDataConversionRetrieveRequest): Promise<runtime.ApiResponse<OpenDataConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataConversionRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataConversionRetrieve(requestParameters: ApiOpenDataConversionRetrieveRequest): Promise<OpenDataConversion> {
        const response = await this.apiOpenDataConversionRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataConversionUpdateRaw(requestParameters: ApiOpenDataConversionUpdateRequest): Promise<runtime.ApiResponse<OpenDataConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataConversionUpdate.');
        }

        if (requestParameters.openDataConversion === null || requestParameters.openDataConversion === undefined) {
            throw new runtime.RequiredError('openDataConversion','Required parameter requestParameters.openDataConversion was null or undefined when calling apiOpenDataConversionUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataConversionToJSON(requestParameters.openDataConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataConversionUpdate(requestParameters: ApiOpenDataConversionUpdateRequest): Promise<OpenDataConversion> {
        const response = await this.apiOpenDataConversionUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataFDCRetrieveRaw(requestParameters: ApiOpenDataFDCRetrieveRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataFDCRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-FDC/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataFDCRetrieve(requestParameters: ApiOpenDataFDCRetrieveRequest): Promise<void> {
        await this.apiOpenDataFDCRetrieveRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataFoodCreateRaw(requestParameters: ApiOpenDataFoodCreateRequest): Promise<runtime.ApiResponse<OpenDataFood>> {
        if (requestParameters.openDataFood === null || requestParameters.openDataFood === undefined) {
            throw new runtime.RequiredError('openDataFood','Required parameter requestParameters.openDataFood was null or undefined when calling apiOpenDataFoodCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataFoodToJSON(requestParameters.openDataFood),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataFoodFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataFoodCreate(requestParameters: ApiOpenDataFoodCreateRequest): Promise<OpenDataFood> {
        const response = await this.apiOpenDataFoodCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataFoodDestroyRaw(requestParameters: ApiOpenDataFoodDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataFoodDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataFoodDestroy(requestParameters: ApiOpenDataFoodDestroyRequest): Promise<void> {
        await this.apiOpenDataFoodDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataFoodListRaw(): Promise<runtime.ApiResponse<Array<OpenDataFood>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataFoodFromJSON));
    }

    /**
     */
    async apiOpenDataFoodList(): Promise<Array<OpenDataFood>> {
        const response = await this.apiOpenDataFoodListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataFoodPartialUpdateRaw(requestParameters: ApiOpenDataFoodPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataFood>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataFoodPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataFoodToJSON(requestParameters.patchedOpenDataFood),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataFoodFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataFoodPartialUpdate(requestParameters: ApiOpenDataFoodPartialUpdateRequest): Promise<OpenDataFood> {
        const response = await this.apiOpenDataFoodPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataFoodRetrieveRaw(requestParameters: ApiOpenDataFoodRetrieveRequest): Promise<runtime.ApiResponse<OpenDataFood>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataFoodRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataFoodFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataFoodRetrieve(requestParameters: ApiOpenDataFoodRetrieveRequest): Promise<OpenDataFood> {
        const response = await this.apiOpenDataFoodRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataFoodUpdateRaw(requestParameters: ApiOpenDataFoodUpdateRequest): Promise<runtime.ApiResponse<OpenDataFood>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataFoodUpdate.');
        }

        if (requestParameters.openDataFood === null || requestParameters.openDataFood === undefined) {
            throw new runtime.RequiredError('openDataFood','Required parameter requestParameters.openDataFood was null or undefined when calling apiOpenDataFoodUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-food/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataFoodToJSON(requestParameters.openDataFood),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataFoodFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataFoodUpdate(requestParameters: ApiOpenDataFoodUpdateRequest): Promise<OpenDataFood> {
        const response = await this.apiOpenDataFoodUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataPropertyCreateRaw(requestParameters: ApiOpenDataPropertyCreateRequest): Promise<runtime.ApiResponse<OpenDataProperty>> {
        if (requestParameters.openDataProperty === null || requestParameters.openDataProperty === undefined) {
            throw new runtime.RequiredError('openDataProperty','Required parameter requestParameters.openDataProperty was null or undefined when calling apiOpenDataPropertyCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataPropertyToJSON(requestParameters.openDataProperty),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataPropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataPropertyCreate(requestParameters: ApiOpenDataPropertyCreateRequest): Promise<OpenDataProperty> {
        const response = await this.apiOpenDataPropertyCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataPropertyDestroyRaw(requestParameters: ApiOpenDataPropertyDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataPropertyDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataPropertyDestroy(requestParameters: ApiOpenDataPropertyDestroyRequest): Promise<void> {
        await this.apiOpenDataPropertyDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataPropertyListRaw(): Promise<runtime.ApiResponse<Array<OpenDataProperty>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataPropertyFromJSON));
    }

    /**
     */
    async apiOpenDataPropertyList(): Promise<Array<OpenDataProperty>> {
        const response = await this.apiOpenDataPropertyListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataPropertyPartialUpdateRaw(requestParameters: ApiOpenDataPropertyPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataProperty>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataPropertyPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataPropertyToJSON(requestParameters.patchedOpenDataProperty),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataPropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataPropertyPartialUpdate(requestParameters: ApiOpenDataPropertyPartialUpdateRequest): Promise<OpenDataProperty> {
        const response = await this.apiOpenDataPropertyPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataPropertyRetrieveRaw(requestParameters: ApiOpenDataPropertyRetrieveRequest): Promise<runtime.ApiResponse<OpenDataProperty>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataPropertyRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataPropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataPropertyRetrieve(requestParameters: ApiOpenDataPropertyRetrieveRequest): Promise<OpenDataProperty> {
        const response = await this.apiOpenDataPropertyRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataPropertyUpdateRaw(requestParameters: ApiOpenDataPropertyUpdateRequest): Promise<runtime.ApiResponse<OpenDataProperty>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataPropertyUpdate.');
        }

        if (requestParameters.openDataProperty === null || requestParameters.openDataProperty === undefined) {
            throw new runtime.RequiredError('openDataProperty','Required parameter requestParameters.openDataProperty was null or undefined when calling apiOpenDataPropertyUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-property/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataPropertyToJSON(requestParameters.openDataProperty),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataPropertyFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataPropertyUpdate(requestParameters: ApiOpenDataPropertyUpdateRequest): Promise<OpenDataProperty> {
        const response = await this.apiOpenDataPropertyUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataStatsRetrieveRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-stats/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataStatsRetrieve(): Promise<void> {
        await this.apiOpenDataStatsRetrieveRaw();
    }

    /**
     */
    async apiOpenDataStoreCreateRaw(requestParameters: ApiOpenDataStoreCreateRequest): Promise<runtime.ApiResponse<OpenDataStore>> {
        if (requestParameters.openDataStore === null || requestParameters.openDataStore === undefined) {
            throw new runtime.RequiredError('openDataStore','Required parameter requestParameters.openDataStore was null or undefined when calling apiOpenDataStoreCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataStoreToJSON(requestParameters.openDataStore),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataStoreFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataStoreCreate(requestParameters: ApiOpenDataStoreCreateRequest): Promise<OpenDataStore> {
        const response = await this.apiOpenDataStoreCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataStoreDestroyRaw(requestParameters: ApiOpenDataStoreDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataStoreDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataStoreDestroy(requestParameters: ApiOpenDataStoreDestroyRequest): Promise<void> {
        await this.apiOpenDataStoreDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataStoreListRaw(): Promise<runtime.ApiResponse<Array<OpenDataStore>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataStoreFromJSON));
    }

    /**
     */
    async apiOpenDataStoreList(): Promise<Array<OpenDataStore>> {
        const response = await this.apiOpenDataStoreListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataStorePartialUpdateRaw(requestParameters: ApiOpenDataStorePartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataStore>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataStorePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataStoreToJSON(requestParameters.patchedOpenDataStore),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataStoreFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataStorePartialUpdate(requestParameters: ApiOpenDataStorePartialUpdateRequest): Promise<OpenDataStore> {
        const response = await this.apiOpenDataStorePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataStoreRetrieveRaw(requestParameters: ApiOpenDataStoreRetrieveRequest): Promise<runtime.ApiResponse<OpenDataStore>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataStoreRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataStoreFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataStoreRetrieve(requestParameters: ApiOpenDataStoreRetrieveRequest): Promise<OpenDataStore> {
        const response = await this.apiOpenDataStoreRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataStoreUpdateRaw(requestParameters: ApiOpenDataStoreUpdateRequest): Promise<runtime.ApiResponse<OpenDataStore>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataStoreUpdate.');
        }

        if (requestParameters.openDataStore === null || requestParameters.openDataStore === undefined) {
            throw new runtime.RequiredError('openDataStore','Required parameter requestParameters.openDataStore was null or undefined when calling apiOpenDataStoreUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-store/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataStoreToJSON(requestParameters.openDataStore),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataStoreFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataStoreUpdate(requestParameters: ApiOpenDataStoreUpdateRequest): Promise<OpenDataStore> {
        const response = await this.apiOpenDataStoreUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataUnitCreateRaw(requestParameters: ApiOpenDataUnitCreateRequest): Promise<runtime.ApiResponse<OpenDataUnit>> {
        if (requestParameters.openDataUnit === null || requestParameters.openDataUnit === undefined) {
            throw new runtime.RequiredError('openDataUnit','Required parameter requestParameters.openDataUnit was null or undefined when calling apiOpenDataUnitCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataUnitToJSON(requestParameters.openDataUnit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataUnitFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataUnitCreate(requestParameters: ApiOpenDataUnitCreateRequest): Promise<OpenDataUnit> {
        const response = await this.apiOpenDataUnitCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataUnitDestroyRaw(requestParameters: ApiOpenDataUnitDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataUnitDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataUnitDestroy(requestParameters: ApiOpenDataUnitDestroyRequest): Promise<void> {
        await this.apiOpenDataUnitDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataUnitListRaw(): Promise<runtime.ApiResponse<Array<OpenDataUnit>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataUnitFromJSON));
    }

    /**
     */
    async apiOpenDataUnitList(): Promise<Array<OpenDataUnit>> {
        const response = await this.apiOpenDataUnitListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataUnitPartialUpdateRaw(requestParameters: ApiOpenDataUnitPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataUnit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataUnitPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataUnitToJSON(requestParameters.patchedOpenDataUnit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataUnitFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataUnitPartialUpdate(requestParameters: ApiOpenDataUnitPartialUpdateRequest): Promise<OpenDataUnit> {
        const response = await this.apiOpenDataUnitPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataUnitRetrieveRaw(requestParameters: ApiOpenDataUnitRetrieveRequest): Promise<runtime.ApiResponse<OpenDataUnit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataUnitRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataUnitFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataUnitRetrieve(requestParameters: ApiOpenDataUnitRetrieveRequest): Promise<OpenDataUnit> {
        const response = await this.apiOpenDataUnitRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataUnitUpdateRaw(requestParameters: ApiOpenDataUnitUpdateRequest): Promise<runtime.ApiResponse<OpenDataUnit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataUnitUpdate.');
        }

        if (requestParameters.openDataUnit === null || requestParameters.openDataUnit === undefined) {
            throw new runtime.RequiredError('openDataUnit','Required parameter requestParameters.openDataUnit was null or undefined when calling apiOpenDataUnitUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataUnitToJSON(requestParameters.openDataUnit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataUnitFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataUnitUpdate(requestParameters: ApiOpenDataUnitUpdateRequest): Promise<OpenDataUnit> {
        const response = await this.apiOpenDataUnitUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataVersionCreateRaw(requestParameters: ApiOpenDataVersionCreateRequest): Promise<runtime.ApiResponse<OpenDataVersion>> {
        if (requestParameters.openDataVersion === null || requestParameters.openDataVersion === undefined) {
            throw new runtime.RequiredError('openDataVersion','Required parameter requestParameters.openDataVersion was null or undefined when calling apiOpenDataVersionCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataVersionToJSON(requestParameters.openDataVersion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataVersionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataVersionCreate(requestParameters: ApiOpenDataVersionCreateRequest): Promise<OpenDataVersion> {
        const response = await this.apiOpenDataVersionCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataVersionDestroyRaw(requestParameters: ApiOpenDataVersionDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataVersionDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiOpenDataVersionDestroy(requestParameters: ApiOpenDataVersionDestroyRequest): Promise<void> {
        await this.apiOpenDataVersionDestroyRaw(requestParameters);
    }

    /**
     */
    async apiOpenDataVersionListRaw(): Promise<runtime.ApiResponse<Array<OpenDataVersion>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenDataVersionFromJSON));
    }

    /**
     */
    async apiOpenDataVersionList(): Promise<Array<OpenDataVersion>> {
        const response = await this.apiOpenDataVersionListRaw();
        return await response.value();
    }

    /**
     */
    async apiOpenDataVersionPartialUpdateRaw(requestParameters: ApiOpenDataVersionPartialUpdateRequest): Promise<runtime.ApiResponse<OpenDataVersion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataVersionPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOpenDataVersionToJSON(requestParameters.patchedOpenDataVersion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataVersionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataVersionPartialUpdate(requestParameters: ApiOpenDataVersionPartialUpdateRequest): Promise<OpenDataVersion> {
        const response = await this.apiOpenDataVersionPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataVersionRetrieveRaw(requestParameters: ApiOpenDataVersionRetrieveRequest): Promise<runtime.ApiResponse<OpenDataVersion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataVersionRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataVersionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataVersionRetrieve(requestParameters: ApiOpenDataVersionRetrieveRequest): Promise<OpenDataVersion> {
        const response = await this.apiOpenDataVersionRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiOpenDataVersionUpdateRaw(requestParameters: ApiOpenDataVersionUpdateRequest): Promise<runtime.ApiResponse<OpenDataVersion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiOpenDataVersionUpdate.');
        }

        if (requestParameters.openDataVersion === null || requestParameters.openDataVersion === undefined) {
            throw new runtime.RequiredError('openDataVersion','Required parameter requestParameters.openDataVersion was null or undefined when calling apiOpenDataVersionUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/open-data-version/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenDataVersionToJSON(requestParameters.openDataVersion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenDataVersionFromJSON(jsonValue));
    }

    /**
     */
    async apiOpenDataVersionUpdate(requestParameters: ApiOpenDataVersionUpdateRequest): Promise<OpenDataVersion> {
        const response = await this.apiOpenDataVersionUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiPlanIcalRetrieveRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/plan-ical/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiPlanIcalRetrieve(): Promise<void> {
        await this.apiPlanIcalRetrieveRaw();
    }

    /**
     */
    async apiPlanIcalRetrieve2Raw(requestParameters: ApiPlanIcalRetrieve2Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.fromDate === null || requestParameters.fromDate === undefined) {
            throw new runtime.RequiredError('fromDate','Required parameter requestParameters.fromDate was null or undefined when calling apiPlanIcalRetrieve2.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/plan-ical/{from_date}/`.replace(`{${"from_date"}}`, encodeURIComponent(String(requestParameters.fromDate))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiPlanIcalRetrieve2(requestParameters: ApiPlanIcalRetrieve2Request): Promise<void> {
        await this.apiPlanIcalRetrieve2Raw(requestParameters);
    }

    /**
     */
    async apiPlanIcalRetrieve3Raw(requestParameters: ApiPlanIcalRetrieve3Request): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.fromDate === null || requestParameters.fromDate === undefined) {
            throw new runtime.RequiredError('fromDate','Required parameter requestParameters.fromDate was null or undefined when calling apiPlanIcalRetrieve3.');
        }

        if (requestParameters.toDate === null || requestParameters.toDate === undefined) {
            throw new runtime.RequiredError('toDate','Required parameter requestParameters.toDate was null or undefined when calling apiPlanIcalRetrieve3.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/plan-ical/{from_date}/{to_date}/`.replace(`{${"from_date"}}`, encodeURIComponent(String(requestParameters.fromDate))).replace(`{${"to_date"}}`, encodeURIComponent(String(requestParameters.toDate))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiPlanIcalRetrieve3(requestParameters: ApiPlanIcalRetrieve3Request): Promise<void> {
        await this.apiPlanIcalRetrieve3Raw(requestParameters);
    }

    /**
     */
    async apiRecipeBookCreateRaw(requestParameters: ApiRecipeBookCreateRequest): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters.recipeBook === null || requestParameters.recipeBook === undefined) {
            throw new runtime.RequiredError('recipeBook','Required parameter requestParameters.recipeBook was null or undefined when calling apiRecipeBookCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookToJSON(requestParameters.recipeBook),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeBookCreate(requestParameters: ApiRecipeBookCreateRequest): Promise<RecipeBook> {
        const response = await this.apiRecipeBookCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeBookDestroyRaw(requestParameters: ApiRecipeBookDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiRecipeBookDestroy(requestParameters: ApiRecipeBookDestroyRequest): Promise<void> {
        await this.apiRecipeBookDestroyRaw(requestParameters);
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryCreateRaw(requestParameters: ApiRecipeBookEntryCreateRequest): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters.recipeBookEntry === null || requestParameters.recipeBookEntry === undefined) {
            throw new runtime.RequiredError('recipeBookEntry','Required parameter requestParameters.recipeBookEntry was null or undefined when calling apiRecipeBookEntryCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookEntryToJSON(requestParameters.recipeBookEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryCreate(requestParameters: ApiRecipeBookEntryCreateRequest): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryDestroyRaw(requestParameters: ApiRecipeBookEntryDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookEntryDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryDestroy(requestParameters: ApiRecipeBookEntryDestroyRequest): Promise<void> {
        await this.apiRecipeBookEntryDestroyRaw(requestParameters);
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryListRaw(): Promise<runtime.ApiResponse<Array<RecipeBookEntry>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecipeBookEntryFromJSON));
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryList(): Promise<Array<RecipeBookEntry>> {
        const response = await this.apiRecipeBookEntryListRaw();
        return await response.value();
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryPartialUpdateRaw(requestParameters: ApiRecipeBookEntryPartialUpdateRequest): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookEntryPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeBookEntryToJSON(requestParameters.patchedRecipeBookEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryPartialUpdate(requestParameters: ApiRecipeBookEntryPartialUpdateRequest): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryRetrieveRaw(requestParameters: ApiRecipeBookEntryRetrieveRequest): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookEntryRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryRetrieve(requestParameters: ApiRecipeBookEntryRetrieveRequest): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryUpdateRaw(requestParameters: ApiRecipeBookEntryUpdateRequest): Promise<runtime.ApiResponse<RecipeBookEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookEntryUpdate.');
        }

        if (requestParameters.recipeBookEntry === null || requestParameters.recipeBookEntry === undefined) {
            throw new runtime.RequiredError('recipeBookEntry','Required parameter requestParameters.recipeBookEntry was null or undefined when calling apiRecipeBookEntryUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookEntryToJSON(requestParameters.recipeBookEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookEntryFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **recipe**: id of recipe - only return books for that recipe - **book**: id of book - only return recipes in that book
     */
    async apiRecipeBookEntryUpdate(requestParameters: ApiRecipeBookEntryUpdateRequest): Promise<RecipeBookEntry> {
        const response = await this.apiRecipeBookEntryUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeBookListRaw(requestParameters: ApiRecipeBookListRequest): Promise<runtime.ApiResponse<Array<RecipeBook>>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecipeBookFromJSON));
    }

    /**
     */
    async apiRecipeBookList(requestParameters: ApiRecipeBookListRequest): Promise<Array<RecipeBook>> {
        const response = await this.apiRecipeBookListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeBookPartialUpdateRaw(requestParameters: ApiRecipeBookPartialUpdateRequest): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeBookToJSON(requestParameters.patchedRecipeBook),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeBookPartialUpdate(requestParameters: ApiRecipeBookPartialUpdateRequest): Promise<RecipeBook> {
        const response = await this.apiRecipeBookPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeBookRetrieveRaw(requestParameters: ApiRecipeBookRetrieveRequest): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeBookRetrieve(requestParameters: ApiRecipeBookRetrieveRequest): Promise<RecipeBook> {
        const response = await this.apiRecipeBookRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeBookUpdateRaw(requestParameters: ApiRecipeBookUpdateRequest): Promise<runtime.ApiResponse<RecipeBook>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeBookUpdate.');
        }

        if (requestParameters.recipeBook === null || requestParameters.recipeBook === undefined) {
            throw new runtime.RequiredError('recipeBook','Required parameter requestParameters.recipeBook was null or undefined when calling apiRecipeBookUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-book/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeBookToJSON(requestParameters.recipeBook),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeBookFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeBookUpdate(requestParameters: ApiRecipeBookUpdateRequest): Promise<RecipeBook> {
        const response = await this.apiRecipeBookUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeCreateRaw(requestParameters: ApiRecipeCreateRequest): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters.recipe === null || requestParameters.recipe === undefined) {
            throw new runtime.RequiredError('recipe','Required parameter requestParameters.recipe was null or undefined when calling apiRecipeCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters.recipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeCreate(requestParameters: ApiRecipeCreateRequest): Promise<Recipe> {
        const response = await this.apiRecipeCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeDestroyRaw(requestParameters: ApiRecipeDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiRecipeDestroy(requestParameters: ApiRecipeDestroyRequest): Promise<void> {
        await this.apiRecipeDestroyRaw(requestParameters);
    }

    /**
     */
    async apiRecipeFlatListRaw(): Promise<runtime.ApiResponse<Array<RecipeFlat>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/flat/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(RecipeFlatFromJSON));
    }

    /**
     */
    async apiRecipeFlatList(): Promise<Array<RecipeFlat>> {
        const response = await this.apiRecipeFlatListRaw();
        return await response.value();
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     */
    async apiRecipeFromSourceCreateRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe-from-source/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     */
    async apiRecipeFromSourceCreate(): Promise<void> {
        await this.apiRecipeFromSourceCreateRaw();
    }

    /**
     */
    async apiRecipeImageUpdateRaw(requestParameters: ApiRecipeImageUpdateRequest): Promise<runtime.ApiResponse<RecipeImage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeImageUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.image !== undefined) {
            formParams.append('image', requestParameters.image as any);
        }

        if (requestParameters.imageUrl !== undefined) {
            formParams.append('image_url', requestParameters.imageUrl as any);
        }

        const response = await this.request({
            path: `/api/recipe/{id}/image/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeImageFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeImageUpdate(requestParameters: ApiRecipeImageUpdateRequest): Promise<RecipeImage> {
        const response = await this.apiRecipeImageUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeListRaw(requestParameters: ApiRecipeListRequest): Promise<runtime.ApiResponse<PaginatedRecipeOverviewList>> {
        const queryParameters: any = {};

        if (requestParameters.books !== undefined) {
            queryParameters['books'] = requestParameters.books;
        }

        if (requestParameters.booksAnd !== undefined) {
            queryParameters['books_and'] = requestParameters.booksAnd;
        }

        if (requestParameters.booksAndNot !== undefined) {
            queryParameters['books_and_not'] = requestParameters.booksAndNot;
        }

        if (requestParameters.booksOr !== undefined) {
            queryParameters['books_or'] = requestParameters.booksOr;
        }

        if (requestParameters.booksOrNot !== undefined) {
            queryParameters['books_or_not'] = requestParameters.booksOrNot;
        }

        if (requestParameters.cookedon !== undefined) {
            queryParameters['cookedon'] = requestParameters.cookedon;
        }

        if (requestParameters.createdon !== undefined) {
            queryParameters['createdon'] = requestParameters.createdon;
        }

        if (requestParameters.foods !== undefined) {
            queryParameters['foods'] = requestParameters.foods;
        }

        if (requestParameters.foodsAnd !== undefined) {
            queryParameters['foods_and'] = requestParameters.foodsAnd;
        }

        if (requestParameters.foodsAndNot !== undefined) {
            queryParameters['foods_and_not'] = requestParameters.foodsAndNot;
        }

        if (requestParameters.foodsOr !== undefined) {
            queryParameters['foods_or'] = requestParameters.foodsOr;
        }

        if (requestParameters.foodsOrNot !== undefined) {
            queryParameters['foods_or_not'] = requestParameters.foodsOrNot;
        }

        if (requestParameters.internal !== undefined) {
            queryParameters['internal'] = requestParameters.internal;
        }

        if (requestParameters.keywords !== undefined) {
            queryParameters['keywords'] = requestParameters.keywords;
        }

        if (requestParameters.keywordsAnd !== undefined) {
            queryParameters['keywords_and'] = requestParameters.keywordsAnd;
        }

        if (requestParameters.keywordsAndNot !== undefined) {
            queryParameters['keywords_and_not'] = requestParameters.keywordsAndNot;
        }

        if (requestParameters.keywordsOr !== undefined) {
            queryParameters['keywords_or'] = requestParameters.keywordsOr;
        }

        if (requestParameters.keywordsOrNot !== undefined) {
            queryParameters['keywords_or_not'] = requestParameters.keywordsOrNot;
        }

        if (requestParameters.makenow !== undefined) {
            queryParameters['makenow'] = requestParameters.makenow;
        }

        if (requestParameters._new !== undefined) {
            queryParameters['new'] = requestParameters._new;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.rating !== undefined) {
            queryParameters['rating'] = requestParameters.rating;
        }

        if (requestParameters.timescooked !== undefined) {
            queryParameters['timescooked'] = requestParameters.timescooked;
        }

        if (requestParameters.units !== undefined) {
            queryParameters['units'] = requestParameters.units;
        }

        if (requestParameters.updatedon !== undefined) {
            queryParameters['updatedon'] = requestParameters.updatedon;
        }

        if (requestParameters.viewedon !== undefined) {
            queryParameters['viewedon'] = requestParameters.viewedon;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedRecipeOverviewListFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeList(requestParameters: ApiRecipeListRequest): Promise<PaginatedRecipeOverviewList> {
        const response = await this.apiRecipeListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipePartialUpdateRaw(requestParameters: ApiRecipePartialUpdateRequest): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedRecipeToJSON(requestParameters.patchedRecipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipePartialUpdate(requestParameters: ApiRecipePartialUpdateRequest): Promise<Recipe> {
        const response = await this.apiRecipePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeRelatedRetrieveRaw(requestParameters: ApiRecipeRelatedRetrieveRequest): Promise<runtime.ApiResponse<RecipeSimple>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeRelatedRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/related/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeSimpleFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeRelatedRetrieve(requestParameters: ApiRecipeRelatedRetrieveRequest): Promise<RecipeSimple> {
        const response = await this.apiRecipeRelatedRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeRetrieveRaw(requestParameters: ApiRecipeRetrieveRequest): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeRetrieve(requestParameters: ApiRecipeRetrieveRequest): Promise<Recipe> {
        const response = await this.apiRecipeRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeShoppingUpdateRaw(requestParameters: ApiRecipeShoppingUpdateRequest): Promise<runtime.ApiResponse<RecipeShoppingUpdate>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeShoppingUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/shopping/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeShoppingUpdateToJSON(requestParameters.recipeShoppingUpdate),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeShoppingUpdateFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeShoppingUpdate(requestParameters: ApiRecipeShoppingUpdateRequest): Promise<RecipeShoppingUpdate> {
        const response = await this.apiRecipeShoppingUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiRecipeUpdateRaw(requestParameters: ApiRecipeUpdateRequest): Promise<runtime.ApiResponse<Recipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiRecipeUpdate.');
        }

        if (requestParameters.recipe === null || requestParameters.recipe === undefined) {
            throw new runtime.RequiredError('recipe','Required parameter requestParameters.recipe was null or undefined when calling apiRecipeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: RecipeToJSON(requestParameters.recipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => RecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiRecipeUpdate(requestParameters: ApiRecipeUpdateRequest): Promise<Recipe> {
        const response = await this.apiRecipeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * function to reset inheritance from api, see food method for docs
     */
    async apiResetFoodInheritanceRetrieveRaw(): Promise<runtime.ApiResponse<void>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/reset-food-inheritance/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * function to reset inheritance from api, see food method for docs
     */
    async apiResetFoodInheritanceRetrieve(): Promise<void> {
        await this.apiResetFoodInheritanceRetrieveRaw();
    }

    /**
     */
    async apiShareLinkRetrieveRaw(requestParameters: ApiShareLinkRetrieveRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShareLinkRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/share-link/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiShareLinkRetrieve(requestParameters: ApiShareLinkRetrieveRequest): Promise<void> {
        await this.apiShareLinkRetrieveRaw(requestParameters);
    }

    /**
     */
    async apiShoppingListEntryBulkCreateRaw(requestParameters: ApiShoppingListEntryBulkCreateRequest): Promise<runtime.ApiResponse<ShoppingListEntryBulk>> {
        if (requestParameters.shoppingListEntryBulk === null || requestParameters.shoppingListEntryBulk === undefined) {
            throw new runtime.RequiredError('shoppingListEntryBulk','Required parameter requestParameters.shoppingListEntryBulk was null or undefined when calling apiShoppingListEntryBulkCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/bulk/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryBulkToJSON(requestParameters.shoppingListEntryBulk),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryBulkFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListEntryBulkCreate(requestParameters: ApiShoppingListEntryBulkCreateRequest): Promise<ShoppingListEntryBulk> {
        const response = await this.apiShoppingListEntryBulkCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListEntryCreateRaw(requestParameters: ApiShoppingListEntryCreateRequest): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters.shoppingListEntry === null || requestParameters.shoppingListEntry === undefined) {
            throw new runtime.RequiredError('shoppingListEntry','Required parameter requestParameters.shoppingListEntry was null or undefined when calling apiShoppingListEntryCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryToJSON(requestParameters.shoppingListEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListEntryCreate(requestParameters: ApiShoppingListEntryCreateRequest): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListEntryDestroyRaw(requestParameters: ApiShoppingListEntryDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListEntryDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiShoppingListEntryDestroy(requestParameters: ApiShoppingListEntryDestroyRequest): Promise<void> {
        await this.apiShoppingListEntryDestroyRaw(requestParameters);
    }

    /**
     */
    async apiShoppingListEntryListRaw(requestParameters: ApiShoppingListEntryListRequest): Promise<runtime.ApiResponse<Array<ShoppingListEntry>>> {
        const queryParameters: any = {};

        if (requestParameters.checked !== undefined) {
            queryParameters['checked'] = requestParameters.checked;
        }

        if (requestParameters.id !== undefined) {
            queryParameters['id'] = requestParameters.id;
        }

        if (requestParameters.supermarket !== undefined) {
            queryParameters['supermarket'] = requestParameters.supermarket;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ShoppingListEntryFromJSON));
    }

    /**
     */
    async apiShoppingListEntryList(requestParameters: ApiShoppingListEntryListRequest): Promise<Array<ShoppingListEntry>> {
        const response = await this.apiShoppingListEntryListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListEntryPartialUpdateRaw(requestParameters: ApiShoppingListEntryPartialUpdateRequest): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListEntryPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedShoppingListEntryToJSON(requestParameters.patchedShoppingListEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListEntryPartialUpdate(requestParameters: ApiShoppingListEntryPartialUpdateRequest): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListEntryRetrieveRaw(requestParameters: ApiShoppingListEntryRetrieveRequest): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListEntryRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListEntryRetrieve(requestParameters: ApiShoppingListEntryRetrieveRequest): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListEntryUpdateRaw(requestParameters: ApiShoppingListEntryUpdateRequest): Promise<runtime.ApiResponse<ShoppingListEntry>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListEntryUpdate.');
        }

        if (requestParameters.shoppingListEntry === null || requestParameters.shoppingListEntry === undefined) {
            throw new runtime.RequiredError('shoppingListEntry','Required parameter requestParameters.shoppingListEntry was null or undefined when calling apiShoppingListEntryUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-entry/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListEntryToJSON(requestParameters.shoppingListEntry),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListEntryFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListEntryUpdate(requestParameters: ApiShoppingListEntryUpdateRequest): Promise<ShoppingListEntry> {
        const response = await this.apiShoppingListEntryUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListRecipeCreateRaw(requestParameters: ApiShoppingListRecipeCreateRequest): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters.shoppingListRecipe === null || requestParameters.shoppingListRecipe === undefined) {
            throw new runtime.RequiredError('shoppingListRecipe','Required parameter requestParameters.shoppingListRecipe was null or undefined when calling apiShoppingListRecipeCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListRecipeToJSON(requestParameters.shoppingListRecipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListRecipeCreate(requestParameters: ApiShoppingListRecipeCreateRequest): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListRecipeDestroyRaw(requestParameters: ApiShoppingListRecipeDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListRecipeDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiShoppingListRecipeDestroy(requestParameters: ApiShoppingListRecipeDestroyRequest): Promise<void> {
        await this.apiShoppingListRecipeDestroyRaw(requestParameters);
    }

    /**
     */
    async apiShoppingListRecipeListRaw(): Promise<runtime.ApiResponse<Array<ShoppingListRecipe>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ShoppingListRecipeFromJSON));
    }

    /**
     */
    async apiShoppingListRecipeList(): Promise<Array<ShoppingListRecipe>> {
        const response = await this.apiShoppingListRecipeListRaw();
        return await response.value();
    }

    /**
     */
    async apiShoppingListRecipePartialUpdateRaw(requestParameters: ApiShoppingListRecipePartialUpdateRequest): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListRecipePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedShoppingListRecipeToJSON(requestParameters.patchedShoppingListRecipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListRecipePartialUpdate(requestParameters: ApiShoppingListRecipePartialUpdateRequest): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListRecipeRetrieveRaw(requestParameters: ApiShoppingListRecipeRetrieveRequest): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListRecipeRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListRecipeRetrieve(requestParameters: ApiShoppingListRecipeRetrieveRequest): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiShoppingListRecipeUpdateRaw(requestParameters: ApiShoppingListRecipeUpdateRequest): Promise<runtime.ApiResponse<ShoppingListRecipe>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiShoppingListRecipeUpdate.');
        }

        if (requestParameters.shoppingListRecipe === null || requestParameters.shoppingListRecipe === undefined) {
            throw new runtime.RequiredError('shoppingListRecipe','Required parameter requestParameters.shoppingListRecipe was null or undefined when calling apiShoppingListRecipeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/shopping-list-recipe/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ShoppingListRecipeToJSON(requestParameters.shoppingListRecipe),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ShoppingListRecipeFromJSON(jsonValue));
    }

    /**
     */
    async apiShoppingListRecipeUpdate(requestParameters: ApiShoppingListRecipeUpdateRequest): Promise<ShoppingListRecipe> {
        const response = await this.apiShoppingListRecipeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSpaceListRaw(): Promise<runtime.ApiResponse<Array<Space>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/space/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SpaceFromJSON));
    }

    /**
     */
    async apiSpaceList(): Promise<Array<Space>> {
        const response = await this.apiSpaceListRaw();
        return await response.value();
    }

    /**
     */
    async apiSpacePartialUpdateRaw(requestParameters: ApiSpacePartialUpdateRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSpacePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSpaceToJSON(requestParameters.patchedSpace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     */
    async apiSpacePartialUpdate(requestParameters: ApiSpacePartialUpdateRequest): Promise<Space> {
        const response = await this.apiSpacePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSpaceRetrieveRaw(requestParameters: ApiSpaceRetrieveRequest): Promise<runtime.ApiResponse<Space>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSpaceRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SpaceFromJSON(jsonValue));
    }

    /**
     */
    async apiSpaceRetrieve(requestParameters: ApiSpaceRetrieveRequest): Promise<Space> {
        const response = await this.apiSpaceRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStepCreateRaw(requestParameters: ApiStepCreateRequest): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters.step === null || requestParameters.step === undefined) {
            throw new runtime.RequiredError('step','Required parameter requestParameters.step was null or undefined when calling apiStepCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StepToJSON(requestParameters.step),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     */
    async apiStepCreate(requestParameters: ApiStepCreateRequest): Promise<Step> {
        const response = await this.apiStepCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStepDestroyRaw(requestParameters: ApiStepDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStepDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiStepDestroy(requestParameters: ApiStepDestroyRequest): Promise<void> {
        await this.apiStepDestroyRaw(requestParameters);
    }

    /**
     */
    async apiStepListRaw(requestParameters: ApiStepListRequest): Promise<runtime.ApiResponse<PaginatedStepList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.recipe !== undefined) {
            queryParameters['recipe'] = requestParameters.recipe;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedStepListFromJSON(jsonValue));
    }

    /**
     */
    async apiStepList(requestParameters: ApiStepListRequest): Promise<PaginatedStepList> {
        const response = await this.apiStepListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStepPartialUpdateRaw(requestParameters: ApiStepPartialUpdateRequest): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStepPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStepToJSON(requestParameters.patchedStep),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     */
    async apiStepPartialUpdate(requestParameters: ApiStepPartialUpdateRequest): Promise<Step> {
        const response = await this.apiStepPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStepRetrieveRaw(requestParameters: ApiStepRetrieveRequest): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStepRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     */
    async apiStepRetrieve(requestParameters: ApiStepRetrieveRequest): Promise<Step> {
        const response = await this.apiStepRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStepUpdateRaw(requestParameters: ApiStepUpdateRequest): Promise<runtime.ApiResponse<Step>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStepUpdate.');
        }

        if (requestParameters.step === null || requestParameters.step === undefined) {
            throw new runtime.RequiredError('step','Required parameter requestParameters.step was null or undefined when calling apiStepUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/step/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StepToJSON(requestParameters.step),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StepFromJSON(jsonValue));
    }

    /**
     */
    async apiStepUpdate(requestParameters: ApiStepUpdateRequest): Promise<Step> {
        const response = await this.apiStepUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStorageCreateRaw(requestParameters: ApiStorageCreateRequest): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters.storage === null || requestParameters.storage === undefined) {
            throw new runtime.RequiredError('storage','Required parameter requestParameters.storage was null or undefined when calling apiStorageCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: StorageToJSON(requestParameters.storage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     */
    async apiStorageCreate(requestParameters: ApiStorageCreateRequest): Promise<Storage> {
        const response = await this.apiStorageCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStorageDestroyRaw(requestParameters: ApiStorageDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStorageDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiStorageDestroy(requestParameters: ApiStorageDestroyRequest): Promise<void> {
        await this.apiStorageDestroyRaw(requestParameters);
    }

    /**
     */
    async apiStorageListRaw(): Promise<runtime.ApiResponse<Array<Storage>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(StorageFromJSON));
    }

    /**
     */
    async apiStorageList(): Promise<Array<Storage>> {
        const response = await this.apiStorageListRaw();
        return await response.value();
    }

    /**
     */
    async apiStoragePartialUpdateRaw(requestParameters: ApiStoragePartialUpdateRequest): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStoragePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedStorageToJSON(requestParameters.patchedStorage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     */
    async apiStoragePartialUpdate(requestParameters: ApiStoragePartialUpdateRequest): Promise<Storage> {
        const response = await this.apiStoragePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStorageRetrieveRaw(requestParameters: ApiStorageRetrieveRequest): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStorageRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     */
    async apiStorageRetrieve(requestParameters: ApiStorageRetrieveRequest): Promise<Storage> {
        const response = await this.apiStorageRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiStorageUpdateRaw(requestParameters: ApiStorageUpdateRequest): Promise<runtime.ApiResponse<Storage>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiStorageUpdate.');
        }

        if (requestParameters.storage === null || requestParameters.storage === undefined) {
            throw new runtime.RequiredError('storage','Required parameter requestParameters.storage was null or undefined when calling apiStorageUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/storage/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: StorageToJSON(requestParameters.storage),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => StorageFromJSON(jsonValue));
    }

    /**
     */
    async apiStorageUpdate(requestParameters: ApiStorageUpdateRequest): Promise<Storage> {
        const response = await this.apiStorageUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryCreateRaw(requestParameters: ApiSupermarketCategoryCreateRequest): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters.supermarketCategory === null || requestParameters.supermarketCategory === undefined) {
            throw new runtime.RequiredError('supermarketCategory','Required parameter requestParameters.supermarketCategory was null or undefined when calling apiSupermarketCategoryCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters.supermarketCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryCreate(requestParameters: ApiSupermarketCategoryCreateRequest): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryDestroyRaw(requestParameters: ApiSupermarketCategoryDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiSupermarketCategoryDestroy(requestParameters: ApiSupermarketCategoryDestroyRequest): Promise<void> {
        await this.apiSupermarketCategoryDestroyRaw(requestParameters);
    }

    /**
     */
    async apiSupermarketCategoryListRaw(): Promise<runtime.ApiResponse<Array<SupermarketCategory>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SupermarketCategoryFromJSON));
    }

    /**
     */
    async apiSupermarketCategoryList(): Promise<Array<SupermarketCategory>> {
        const response = await this.apiSupermarketCategoryListRaw();
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryMergeUpdateRaw(requestParameters: ApiSupermarketCategoryMergeUpdateRequest): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryMergeUpdate.');
        }

        if (requestParameters.target === null || requestParameters.target === undefined) {
            throw new runtime.RequiredError('target','Required parameter requestParameters.target was null or undefined when calling apiSupermarketCategoryMergeUpdate.');
        }

        if (requestParameters.supermarketCategory === null || requestParameters.supermarketCategory === undefined) {
            throw new runtime.RequiredError('supermarketCategory','Required parameter requestParameters.supermarketCategory was null or undefined when calling apiSupermarketCategoryMergeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters.target))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters.supermarketCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryMergeUpdate(requestParameters: ApiSupermarketCategoryMergeUpdateRequest): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryMergeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryPartialUpdateRaw(requestParameters: ApiSupermarketCategoryPartialUpdateRequest): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketCategoryToJSON(requestParameters.patchedSupermarketCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryPartialUpdate(requestParameters: ApiSupermarketCategoryPartialUpdateRequest): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRelationCreateRaw(requestParameters: ApiSupermarketCategoryRelationCreateRequest): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters.supermarketCategoryRelation === null || requestParameters.supermarketCategoryRelation === undefined) {
            throw new runtime.RequiredError('supermarketCategoryRelation','Required parameter requestParameters.supermarketCategoryRelation was null or undefined when calling apiSupermarketCategoryRelationCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryRelationToJSON(requestParameters.supermarketCategoryRelation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRelationCreate(requestParameters: ApiSupermarketCategoryRelationCreateRequest): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRelationDestroyRaw(requestParameters: ApiSupermarketCategoryRelationDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryRelationDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiSupermarketCategoryRelationDestroy(requestParameters: ApiSupermarketCategoryRelationDestroyRequest): Promise<void> {
        await this.apiSupermarketCategoryRelationDestroyRaw(requestParameters);
    }

    /**
     */
    async apiSupermarketCategoryRelationListRaw(requestParameters: ApiSupermarketCategoryRelationListRequest): Promise<runtime.ApiResponse<PaginatedSupermarketCategoryRelationList>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSupermarketCategoryRelationListFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRelationList(requestParameters: ApiSupermarketCategoryRelationListRequest): Promise<PaginatedSupermarketCategoryRelationList> {
        const response = await this.apiSupermarketCategoryRelationListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRelationPartialUpdateRaw(requestParameters: ApiSupermarketCategoryRelationPartialUpdateRequest): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryRelationPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketCategoryRelationToJSON(requestParameters.patchedSupermarketCategoryRelation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRelationPartialUpdate(requestParameters: ApiSupermarketCategoryRelationPartialUpdateRequest): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRelationRetrieveRaw(requestParameters: ApiSupermarketCategoryRelationRetrieveRequest): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryRelationRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRelationRetrieve(requestParameters: ApiSupermarketCategoryRelationRetrieveRequest): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRelationUpdateRaw(requestParameters: ApiSupermarketCategoryRelationUpdateRequest): Promise<runtime.ApiResponse<SupermarketCategoryRelation>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryRelationUpdate.');
        }

        if (requestParameters.supermarketCategoryRelation === null || requestParameters.supermarketCategoryRelation === undefined) {
            throw new runtime.RequiredError('supermarketCategoryRelation','Required parameter requestParameters.supermarketCategoryRelation was null or undefined when calling apiSupermarketCategoryRelationUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category-relation/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryRelationToJSON(requestParameters.supermarketCategoryRelation),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryRelationFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRelationUpdate(requestParameters: ApiSupermarketCategoryRelationUpdateRequest): Promise<SupermarketCategoryRelation> {
        const response = await this.apiSupermarketCategoryRelationUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryRetrieveRaw(requestParameters: ApiSupermarketCategoryRetrieveRequest): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryRetrieve(requestParameters: ApiSupermarketCategoryRetrieveRequest): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCategoryUpdateRaw(requestParameters: ApiSupermarketCategoryUpdateRequest): Promise<runtime.ApiResponse<SupermarketCategory>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketCategoryUpdate.');
        }

        if (requestParameters.supermarketCategory === null || requestParameters.supermarketCategory === undefined) {
            throw new runtime.RequiredError('supermarketCategory','Required parameter requestParameters.supermarketCategory was null or undefined when calling apiSupermarketCategoryUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketCategoryToJSON(requestParameters.supermarketCategory),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketCategoryFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCategoryUpdate(requestParameters: ApiSupermarketCategoryUpdateRequest): Promise<SupermarketCategory> {
        const response = await this.apiSupermarketCategoryUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketCreateRaw(requestParameters: ApiSupermarketCreateRequest): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters.supermarket === null || requestParameters.supermarket === undefined) {
            throw new runtime.RequiredError('supermarket','Required parameter requestParameters.supermarket was null or undefined when calling apiSupermarketCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketToJSON(requestParameters.supermarket),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketCreate(requestParameters: ApiSupermarketCreateRequest): Promise<Supermarket> {
        const response = await this.apiSupermarketCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketDestroyRaw(requestParameters: ApiSupermarketDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiSupermarketDestroy(requestParameters: ApiSupermarketDestroyRequest): Promise<void> {
        await this.apiSupermarketDestroyRaw(requestParameters);
    }

    /**
     */
    async apiSupermarketListRaw(requestParameters: ApiSupermarketListRequest): Promise<runtime.ApiResponse<Array<Supermarket>>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SupermarketFromJSON));
    }

    /**
     */
    async apiSupermarketList(requestParameters: ApiSupermarketListRequest): Promise<Array<Supermarket>> {
        const response = await this.apiSupermarketListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketPartialUpdateRaw(requestParameters: ApiSupermarketPartialUpdateRequest): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSupermarketToJSON(requestParameters.patchedSupermarket),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketPartialUpdate(requestParameters: ApiSupermarketPartialUpdateRequest): Promise<Supermarket> {
        const response = await this.apiSupermarketPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketRetrieveRaw(requestParameters: ApiSupermarketRetrieveRequest): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketRetrieve(requestParameters: ApiSupermarketRetrieveRequest): Promise<Supermarket> {
        const response = await this.apiSupermarketRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSupermarketUpdateRaw(requestParameters: ApiSupermarketUpdateRequest): Promise<runtime.ApiResponse<Supermarket>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSupermarketUpdate.');
        }

        if (requestParameters.supermarket === null || requestParameters.supermarket === undefined) {
            throw new runtime.RequiredError('supermarket','Required parameter requestParameters.supermarket was null or undefined when calling apiSupermarketUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/supermarket/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SupermarketToJSON(requestParameters.supermarket),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SupermarketFromJSON(jsonValue));
    }

    /**
     */
    async apiSupermarketUpdate(requestParameters: ApiSupermarketUpdateRequest): Promise<Supermarket> {
        const response = await this.apiSupermarketUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * api endpoint to switch space function
     */
    async apiSwitchActiveSpaceRetrieveRaw(requestParameters: ApiSwitchActiveSpaceRetrieveRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.spaceId === null || requestParameters.spaceId === undefined) {
            throw new runtime.RequiredError('spaceId','Required parameter requestParameters.spaceId was null or undefined when calling apiSwitchActiveSpaceRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/switch-active-space/{space_id}/`.replace(`{${"space_id"}}`, encodeURIComponent(String(requestParameters.spaceId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * api endpoint to switch space function
     */
    async apiSwitchActiveSpaceRetrieve(requestParameters: ApiSwitchActiveSpaceRetrieveRequest): Promise<void> {
        await this.apiSwitchActiveSpaceRetrieveRaw(requestParameters);
    }

    /**
     */
    async apiSyncCreateRaw(requestParameters: ApiSyncCreateRequest): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters.sync === null || requestParameters.sync === undefined) {
            throw new runtime.RequiredError('sync','Required parameter requestParameters.sync was null or undefined when calling apiSyncCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SyncToJSON(requestParameters.sync),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncCreate(requestParameters: ApiSyncCreateRequest): Promise<Sync> {
        const response = await this.apiSyncCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSyncDestroyRaw(requestParameters: ApiSyncDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSyncDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiSyncDestroy(requestParameters: ApiSyncDestroyRequest): Promise<void> {
        await this.apiSyncDestroyRaw(requestParameters);
    }

    /**
     */
    async apiSyncListRaw(): Promise<runtime.ApiResponse<Array<Sync>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SyncFromJSON));
    }

    /**
     */
    async apiSyncList(): Promise<Array<Sync>> {
        const response = await this.apiSyncListRaw();
        return await response.value();
    }

    /**
     */
    async apiSyncLogListRaw(requestParameters: ApiSyncLogListRequest): Promise<runtime.ApiResponse<PaginatedSyncLogList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSyncLogListFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncLogList(requestParameters: ApiSyncLogListRequest): Promise<PaginatedSyncLogList> {
        const response = await this.apiSyncLogListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSyncLogRetrieveRaw(requestParameters: ApiSyncLogRetrieveRequest): Promise<runtime.ApiResponse<SyncLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSyncLogRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncLogFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncLogRetrieve(requestParameters: ApiSyncLogRetrieveRequest): Promise<SyncLog> {
        const response = await this.apiSyncLogRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSyncPartialUpdateRaw(requestParameters: ApiSyncPartialUpdateRequest): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSyncPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSyncToJSON(requestParameters.patchedSync),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncPartialUpdate(requestParameters: ApiSyncPartialUpdateRequest): Promise<Sync> {
        const response = await this.apiSyncPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSyncRetrieveRaw(requestParameters: ApiSyncRetrieveRequest): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSyncRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncRetrieve(requestParameters: ApiSyncRetrieveRequest): Promise<Sync> {
        const response = await this.apiSyncRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiSyncUpdateRaw(requestParameters: ApiSyncUpdateRequest): Promise<runtime.ApiResponse<Sync>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiSyncUpdate.');
        }

        if (requestParameters.sync === null || requestParameters.sync === undefined) {
            throw new runtime.RequiredError('sync','Required parameter requestParameters.sync was null or undefined when calling apiSyncUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/sync/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SyncToJSON(requestParameters.sync),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => SyncFromJSON(jsonValue));
    }

    /**
     */
    async apiSyncUpdate(requestParameters: ApiSyncUpdateRequest): Promise<Sync> {
        const response = await this.apiSyncUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitConversionCreateRaw(requestParameters: ApiUnitConversionCreateRequest): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters.unitConversion === null || requestParameters.unitConversion === undefined) {
            throw new runtime.RequiredError('unitConversion','Required parameter requestParameters.unitConversion was null or undefined when calling apiUnitConversionCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitConversionToJSON(requestParameters.unitConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitConversionCreate(requestParameters: ApiUnitConversionCreateRequest): Promise<UnitConversion> {
        const response = await this.apiUnitConversionCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitConversionDestroyRaw(requestParameters: ApiUnitConversionDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitConversionDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiUnitConversionDestroy(requestParameters: ApiUnitConversionDestroyRequest): Promise<void> {
        await this.apiUnitConversionDestroyRaw(requestParameters);
    }

    /**
     */
    async apiUnitConversionListRaw(requestParameters: ApiUnitConversionListRequest): Promise<runtime.ApiResponse<Array<UnitConversion>>> {
        const queryParameters: any = {};

        if (requestParameters.foodId !== undefined) {
            queryParameters['food_id'] = requestParameters.foodId;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UnitConversionFromJSON));
    }

    /**
     */
    async apiUnitConversionList(requestParameters: ApiUnitConversionListRequest): Promise<Array<UnitConversion>> {
        const response = await this.apiUnitConversionListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitConversionPartialUpdateRaw(requestParameters: ApiUnitConversionPartialUpdateRequest): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitConversionPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUnitConversionToJSON(requestParameters.patchedUnitConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitConversionPartialUpdate(requestParameters: ApiUnitConversionPartialUpdateRequest): Promise<UnitConversion> {
        const response = await this.apiUnitConversionPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitConversionRetrieveRaw(requestParameters: ApiUnitConversionRetrieveRequest): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitConversionRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitConversionRetrieve(requestParameters: ApiUnitConversionRetrieveRequest): Promise<UnitConversion> {
        const response = await this.apiUnitConversionRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitConversionUpdateRaw(requestParameters: ApiUnitConversionUpdateRequest): Promise<runtime.ApiResponse<UnitConversion>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitConversionUpdate.');
        }

        if (requestParameters.unitConversion === null || requestParameters.unitConversion === undefined) {
            throw new runtime.RequiredError('unitConversion','Required parameter requestParameters.unitConversion was null or undefined when calling apiUnitConversionUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit-conversion/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitConversionToJSON(requestParameters.unitConversion),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitConversionFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitConversionUpdate(requestParameters: ApiUnitConversionUpdateRequest): Promise<UnitConversion> {
        const response = await this.apiUnitConversionUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitCreateRaw(requestParameters: ApiUnitCreateRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.unit === null || requestParameters.unit === undefined) {
            throw new runtime.RequiredError('unit','Required parameter requestParameters.unit was null or undefined when calling apiUnitCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters.unit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitCreate(requestParameters: ApiUnitCreateRequest): Promise<Unit> {
        const response = await this.apiUnitCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitDestroyRaw(requestParameters: ApiUnitDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiUnitDestroy(requestParameters: ApiUnitDestroyRequest): Promise<void> {
        await this.apiUnitDestroyRaw(requestParameters);
    }

    /**
     */
    async apiUnitListRaw(requestParameters: ApiUnitListRequest): Promise<runtime.ApiResponse<PaginatedUnitList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUnitListFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitList(requestParameters: ApiUnitListRequest): Promise<PaginatedUnitList> {
        const response = await this.apiUnitListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitMergeUpdateRaw(requestParameters: ApiUnitMergeUpdateRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitMergeUpdate.');
        }

        if (requestParameters.target === null || requestParameters.target === undefined) {
            throw new runtime.RequiredError('target','Required parameter requestParameters.target was null or undefined when calling apiUnitMergeUpdate.');
        }

        if (requestParameters.unit === null || requestParameters.unit === undefined) {
            throw new runtime.RequiredError('unit','Required parameter requestParameters.unit was null or undefined when calling apiUnitMergeUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/{id}/merge/{target}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))).replace(`{${"target"}}`, encodeURIComponent(String(requestParameters.target))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters.unit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitMergeUpdate(requestParameters: ApiUnitMergeUpdateRequest): Promise<Unit> {
        const response = await this.apiUnitMergeUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitPartialUpdateRaw(requestParameters: ApiUnitPartialUpdateRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUnitToJSON(requestParameters.patchedUnit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitPartialUpdate(requestParameters: ApiUnitPartialUpdateRequest): Promise<Unit> {
        const response = await this.apiUnitPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitRetrieveRaw(requestParameters: ApiUnitRetrieveRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitRetrieve(requestParameters: ApiUnitRetrieveRequest): Promise<Unit> {
        const response = await this.apiUnitRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUnitUpdateRaw(requestParameters: ApiUnitUpdateRequest): Promise<runtime.ApiResponse<Unit>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUnitUpdate.');
        }

        if (requestParameters.unit === null || requestParameters.unit === undefined) {
            throw new runtime.RequiredError('unit','Required parameter requestParameters.unit was null or undefined when calling apiUnitUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/unit/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UnitToJSON(requestParameters.unit),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UnitFromJSON(jsonValue));
    }

    /**
     */
    async apiUnitUpdate(requestParameters: ApiUnitUpdateRequest): Promise<Unit> {
        const response = await this.apiUnitUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserFileCreateRaw(requestParameters: ApiUserFileCreateRequest): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserFileCreate.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling apiUserFileCreate.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling apiUserFileCreate.');
        }

        if (requestParameters.fileDownload === null || requestParameters.fileDownload === undefined) {
            throw new runtime.RequiredError('fileDownload','Required parameter requestParameters.fileDownload was null or undefined when calling apiUserFileCreate.');
        }

        if (requestParameters.preview === null || requestParameters.preview === undefined) {
            throw new runtime.RequiredError('preview','Required parameter requestParameters.preview was null or undefined when calling apiUserFileCreate.');
        }

        if (requestParameters.fileSizeKb === null || requestParameters.fileSizeKb === undefined) {
            throw new runtime.RequiredError('fileSizeKb','Required parameter requestParameters.fileSizeKb was null or undefined when calling apiUserFileCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id !== undefined) {
            formParams.append('id', requestParameters.id as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.fileDownload !== undefined) {
            formParams.append('file_download', requestParameters.fileDownload as any);
        }

        if (requestParameters.preview !== undefined) {
            formParams.append('preview', requestParameters.preview as any);
        }

        if (requestParameters.fileSizeKb !== undefined) {
            formParams.append('file_size_kb', requestParameters.fileSizeKb as any);
        }

        const response = await this.request({
            path: `/api/user-file/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     */
    async apiUserFileCreate(requestParameters: ApiUserFileCreateRequest): Promise<UserFile> {
        const response = await this.apiUserFileCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserFileDestroyRaw(requestParameters: ApiUserFileDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserFileDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiUserFileDestroy(requestParameters: ApiUserFileDestroyRequest): Promise<void> {
        await this.apiUserFileDestroyRaw(requestParameters);
    }

    /**
     */
    async apiUserFileListRaw(requestParameters: ApiUserFileListRequest): Promise<runtime.ApiResponse<Array<UserFile>>> {
        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.query !== undefined) {
            queryParameters['query'] = requestParameters.query;
        }

        if (requestParameters.random !== undefined) {
            queryParameters['random'] = requestParameters.random;
        }

        if (requestParameters.updatedAt !== undefined) {
            queryParameters['updated_at'] = requestParameters.updatedAt;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-file/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFileFromJSON));
    }

    /**
     */
    async apiUserFileList(requestParameters: ApiUserFileListRequest): Promise<Array<UserFile>> {
        const response = await this.apiUserFileListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserFilePartialUpdateRaw(requestParameters: ApiUserFilePartialUpdateRequest): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserFilePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id2 !== undefined) {
            formParams.append('id', requestParameters.id2 as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.fileDownload !== undefined) {
            formParams.append('file_download', requestParameters.fileDownload as any);
        }

        if (requestParameters.preview !== undefined) {
            formParams.append('preview', requestParameters.preview as any);
        }

        if (requestParameters.fileSizeKb !== undefined) {
            formParams.append('file_size_kb', requestParameters.fileSizeKb as any);
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     */
    async apiUserFilePartialUpdate(requestParameters: ApiUserFilePartialUpdateRequest): Promise<UserFile> {
        const response = await this.apiUserFilePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserFileRetrieveRaw(requestParameters: ApiUserFileRetrieveRequest): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserFileRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     */
    async apiUserFileRetrieve(requestParameters: ApiUserFileRetrieveRequest): Promise<UserFile> {
        const response = await this.apiUserFileRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserFileUpdateRaw(requestParameters: ApiUserFileUpdateRequest): Promise<runtime.ApiResponse<UserFile>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.id2 === null || requestParameters.id2 === undefined) {
            throw new runtime.RequiredError('id2','Required parameter requestParameters.id2 was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.name === null || requestParameters.name === undefined) {
            throw new runtime.RequiredError('name','Required parameter requestParameters.name was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.file === null || requestParameters.file === undefined) {
            throw new runtime.RequiredError('file','Required parameter requestParameters.file was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.fileDownload === null || requestParameters.fileDownload === undefined) {
            throw new runtime.RequiredError('fileDownload','Required parameter requestParameters.fileDownload was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.preview === null || requestParameters.preview === undefined) {
            throw new runtime.RequiredError('preview','Required parameter requestParameters.preview was null or undefined when calling apiUserFileUpdate.');
        }

        if (requestParameters.fileSizeKb === null || requestParameters.fileSizeKb === undefined) {
            throw new runtime.RequiredError('fileSizeKb','Required parameter requestParameters.fileSizeKb was null or undefined when calling apiUserFileUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.id2 !== undefined) {
            formParams.append('id', requestParameters.id2 as any);
        }

        if (requestParameters.name !== undefined) {
            formParams.append('name', requestParameters.name as any);
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.fileDownload !== undefined) {
            formParams.append('file_download', requestParameters.fileDownload as any);
        }

        if (requestParameters.preview !== undefined) {
            formParams.append('preview', requestParameters.preview as any);
        }

        if (requestParameters.fileSizeKb !== undefined) {
            formParams.append('file_size_kb', requestParameters.fileSizeKb as any);
        }

        const response = await this.request({
            path: `/api/user-file/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFileFromJSON(jsonValue));
    }

    /**
     */
    async apiUserFileUpdate(requestParameters: ApiUserFileUpdateRequest): Promise<UserFile> {
        const response = await this.apiUserFileUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserListRaw(): Promise<runtime.ApiResponse<Array<User>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserFromJSON));
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserList(): Promise<Array<User>> {
        const response = await this.apiUserListRaw();
        return await response.value();
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserPartialUpdateRaw(requestParameters: ApiUserPartialUpdateRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserToJSON(requestParameters.patchedUser),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserPartialUpdate(requestParameters: ApiUserPartialUpdateRequest): Promise<User> {
        const response = await this.apiUserPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserPreferenceListRaw(): Promise<runtime.ApiResponse<Array<UserPreference>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-preference/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserPreferenceFromJSON));
    }

    /**
     */
    async apiUserPreferenceList(): Promise<Array<UserPreference>> {
        const response = await this.apiUserPreferenceListRaw();
        return await response.value();
    }

    /**
     */
    async apiUserPreferencePartialUpdateRaw(requestParameters: ApiUserPreferencePartialUpdateRequest): Promise<runtime.ApiResponse<UserPreference>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling apiUserPreferencePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserPreferenceToJSON(requestParameters.patchedUserPreference),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPreferenceFromJSON(jsonValue));
    }

    /**
     */
    async apiUserPreferencePartialUpdate(requestParameters: ApiUserPreferencePartialUpdateRequest): Promise<UserPreference> {
        const response = await this.apiUserPreferencePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserPreferenceRetrieveRaw(requestParameters: ApiUserPreferenceRetrieveRequest): Promise<runtime.ApiResponse<UserPreference>> {
        if (requestParameters.user === null || requestParameters.user === undefined) {
            throw new runtime.RequiredError('user','Required parameter requestParameters.user was null or undefined when calling apiUserPreferenceRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-preference/{user}/`.replace(`{${"user"}}`, encodeURIComponent(String(requestParameters.user))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserPreferenceFromJSON(jsonValue));
    }

    /**
     */
    async apiUserPreferenceRetrieve(requestParameters: ApiUserPreferenceRetrieveRequest): Promise<UserPreference> {
        const response = await this.apiUserPreferenceRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserRetrieveRaw(requestParameters: ApiUserRetrieveRequest): Promise<runtime.ApiResponse<User>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFromJSON(jsonValue));
    }

    /**
     * list: optional parameters  - **filter_list**: array of user id\'s to get names for
     */
    async apiUserRetrieve(requestParameters: ApiUserRetrieveRequest): Promise<User> {
        const response = await this.apiUserRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserSpaceDestroyRaw(requestParameters: ApiUserSpaceDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserSpaceDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiUserSpaceDestroy(requestParameters: ApiUserSpaceDestroyRequest): Promise<void> {
        await this.apiUserSpaceDestroyRaw(requestParameters);
    }

    /**
     */
    async apiUserSpaceListRaw(requestParameters: ApiUserSpaceListRequest): Promise<runtime.ApiResponse<PaginatedUserSpaceList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-space/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserSpaceListFromJSON(jsonValue));
    }

    /**
     */
    async apiUserSpaceList(requestParameters: ApiUserSpaceListRequest): Promise<PaginatedUserSpaceList> {
        const response = await this.apiUserSpaceListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserSpacePartialUpdateRaw(requestParameters: ApiUserSpacePartialUpdateRequest): Promise<runtime.ApiResponse<UserSpace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserSpacePartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserSpaceToJSON(requestParameters.patchedUserSpace),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSpaceFromJSON(jsonValue));
    }

    /**
     */
    async apiUserSpacePartialUpdate(requestParameters: ApiUserSpacePartialUpdateRequest): Promise<UserSpace> {
        const response = await this.apiUserSpacePartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiUserSpaceRetrieveRaw(requestParameters: ApiUserSpaceRetrieveRequest): Promise<runtime.ApiResponse<UserSpace>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiUserSpaceRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/user-space/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSpaceFromJSON(jsonValue));
    }

    /**
     */
    async apiUserSpaceRetrieve(requestParameters: ApiUserSpaceRetrieveRequest): Promise<UserSpace> {
        const response = await this.apiUserSpaceRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiViewLogCreateRaw(requestParameters: ApiViewLogCreateRequest): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters.viewLog === null || requestParameters.viewLog === undefined) {
            throw new runtime.RequiredError('viewLog','Required parameter requestParameters.viewLog was null or undefined when calling apiViewLogCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ViewLogToJSON(requestParameters.viewLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     */
    async apiViewLogCreate(requestParameters: ApiViewLogCreateRequest): Promise<ViewLog> {
        const response = await this.apiViewLogCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiViewLogDestroyRaw(requestParameters: ApiViewLogDestroyRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiViewLogDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     */
    async apiViewLogDestroy(requestParameters: ApiViewLogDestroyRequest): Promise<void> {
        await this.apiViewLogDestroyRaw(requestParameters);
    }

    /**
     */
    async apiViewLogListRaw(requestParameters: ApiViewLogListRequest): Promise<runtime.ApiResponse<PaginatedViewLogList>> {
        const queryParameters: any = {};

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedViewLogListFromJSON(jsonValue));
    }

    /**
     */
    async apiViewLogList(requestParameters: ApiViewLogListRequest): Promise<PaginatedViewLogList> {
        const response = await this.apiViewLogListRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiViewLogPartialUpdateRaw(requestParameters: ApiViewLogPartialUpdateRequest): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiViewLogPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedViewLogToJSON(requestParameters.patchedViewLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     */
    async apiViewLogPartialUpdate(requestParameters: ApiViewLogPartialUpdateRequest): Promise<ViewLog> {
        const response = await this.apiViewLogPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiViewLogRetrieveRaw(requestParameters: ApiViewLogRetrieveRequest): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiViewLogRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     */
    async apiViewLogRetrieve(requestParameters: ApiViewLogRetrieveRequest): Promise<ViewLog> {
        const response = await this.apiViewLogRetrieveRaw(requestParameters);
        return await response.value();
    }

    /**
     */
    async apiViewLogUpdateRaw(requestParameters: ApiViewLogUpdateRequest): Promise<runtime.ApiResponse<ViewLog>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling apiViewLogUpdate.');
        }

        if (requestParameters.viewLog === null || requestParameters.viewLog === undefined) {
            throw new runtime.RequiredError('viewLog','Required parameter requestParameters.viewLog was null or undefined when calling apiViewLogUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/api/view-log/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ViewLogToJSON(requestParameters.viewLog),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ViewLogFromJSON(jsonValue));
    }

    /**
     */
    async apiViewLogUpdate(requestParameters: ApiViewLogUpdateRequest): Promise<ViewLog> {
        const response = await this.apiViewLogUpdateRaw(requestParameters);
        return await response.value();
    }

}
