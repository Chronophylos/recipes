/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    created: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    updated: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AutoMealPlan
 */
export interface AutoMealPlan {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlan
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    servings: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof AutoMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlan
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    id: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof Automation
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Automation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface BookmarkletImport
 */
export interface BookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportList
 */
export interface BookmarkletImportList {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfig
 */
export interface ConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface CookLog
 */
export interface CookLog {
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof CookLog
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    updated_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilter
 */
export interface CustomFilter {
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    search: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof CustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    created_by: number;
}
/**
 * * `SEARCH` - Search * `PLAN` - Meal-Plan * `BOOKS` - Books * `SHOPPING` - Shopping
 * @export
 * @enum {string}
 */
export enum DefaultPageEnum {
    Search = 'SEARCH',
    Plan = 'PLAN',
    Books = 'BOOKS',
    Shopping = 'SHOPPING'
}

/**
 * * `true` - true
 * @export
 * @enum {string}
 */
export enum DeleteEnum {
    True = 'true'
}

/**
 * 
 * @export
 * @interface ExportLog
 */
export interface ExportLog {
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_at: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Food
 */
export interface Food {
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    shopping: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof Food
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Food
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof Food
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof Food
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    numchild: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Food
     */
    full_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof Food
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_onhand: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritField
 */
export interface FoodInheritField {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritField
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    field?: string | null;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdate
 */
export interface FoodShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    id: number;
    /**
     * Amount of food to add to the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    amount?: number | null;
    /**
     * ID of unit to use for the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    unit?: number | null;
    /**
     * When set to true will delete all food from active shopping lists.  * `true` - true
     * @type {DeleteEnum}
     * @memberof FoodShoppingUpdate
     */
    _delete: DeleteEnum | null;
}
/**
 * 
 * @export
 * @interface FoodSimple
 */
export interface FoodSimple {
    /**
     * 
     * @type {number}
     * @memberof FoodSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    plural_name?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ImportLog
 */
export interface ImportLog {
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof ImportLog
     */
    keyword: Keyword;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    id: number;
    /**
     * 
     * @type {Food}
     * @memberof Ingredient
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof Ingredient
     */
    unit: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    amount: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    conversions: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    used_in_recipes: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_food?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof InviteLink
     */
    group: Group;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_at: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    numchild: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    updated_at: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Keyword
     */
    full_name: string;
}
/**
 * 
 * @export
 * @interface KeywordLabel
 */
export interface KeywordLabel {
    /**
     * 
     * @type {number}
     * @memberof KeywordLabel
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof KeywordLabel
     */
    label: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlan
 */
export interface MealPlan {
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof MealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note_markdown: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof MealPlan
     */
    meal_type: MealType;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    created_by: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof MealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    meal_type_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlan
     */
    shopping: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealType
 */
export interface MealType {
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    created_by: number;
}
/**
 * * `DB` - Dropbox * `NEXTCLOUD` - Nextcloud * `LOCAL` - Local
 * @export
 * @enum {string}
 */
export enum MethodEnum {
    Db = 'DB',
    Nextcloud = 'NEXTCLOUD',
    Local = 'LOCAL'
}

/**
 * 
 * @export
 * @interface NutritionInformation
 */
export interface NutritionInformation {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformation
     */
    source?: string | null;
}
/**
 * 
 * @export
 * @interface PaginatedAutomationList
 */
export interface PaginatedAutomationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAutomationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Automation>}
     * @memberof PaginatedAutomationList
     */
    results?: Array<Automation>;
}
/**
 * 
 * @export
 * @interface PaginatedBookmarkletImportListList
 */
export interface PaginatedBookmarkletImportListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBookmarkletImportListList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<BookmarkletImportList>}
     * @memberof PaginatedBookmarkletImportListList
     */
    results?: Array<BookmarkletImportList>;
}
/**
 * 
 * @export
 * @interface PaginatedCookLogList
 */
export interface PaginatedCookLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCookLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CookLog>}
     * @memberof PaginatedCookLogList
     */
    results?: Array<CookLog>;
}
/**
 * 
 * @export
 * @interface PaginatedCustomFilterList
 */
export interface PaginatedCustomFilterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCustomFilterList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomFilter>}
     * @memberof PaginatedCustomFilterList
     */
    results?: Array<CustomFilter>;
}
/**
 * 
 * @export
 * @interface PaginatedExportLogList
 */
export interface PaginatedExportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportLog>}
     * @memberof PaginatedExportLogList
     */
    results?: Array<ExportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedFoodList
 */
export interface PaginatedFoodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFoodList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Food>}
     * @memberof PaginatedFoodList
     */
    results?: Array<Food>;
}
/**
 * 
 * @export
 * @interface PaginatedImportLogList
 */
export interface PaginatedImportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportLog>}
     * @memberof PaginatedImportLogList
     */
    results?: Array<ImportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedIngredientList
 */
export interface PaginatedIngredientList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedIngredientList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PaginatedIngredientList
     */
    results?: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface PaginatedInviteLinkList
 */
export interface PaginatedInviteLinkList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInviteLinkList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof PaginatedInviteLinkList
     */
    results?: Array<InviteLink>;
}
/**
 * 
 * @export
 * @interface PaginatedKeywordList
 */
export interface PaginatedKeywordList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedKeywordList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PaginatedKeywordList
     */
    results?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface PaginatedMealPlanList
 */
export interface PaginatedMealPlanList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealPlanList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealPlan>}
     * @memberof PaginatedMealPlanList
     */
    results?: Array<MealPlan>;
}
/**
 * 
 * @export
 * @interface PaginatedMealTypeList
 */
export interface PaginatedMealTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealType>}
     * @memberof PaginatedMealTypeList
     */
    results?: Array<MealType>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyList
 */
export interface PaginatedPropertyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PaginatedPropertyList
     */
    results?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyTypeList
 */
export interface PaginatedPropertyTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PropertyType>}
     * @memberof PaginatedPropertyTypeList
     */
    results?: Array<PropertyType>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookEntryList
 */
export interface PaginatedRecipeBookEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBookEntry>}
     * @memberof PaginatedRecipeBookEntryList
     */
    results?: Array<RecipeBookEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookList
 */
export interface PaginatedRecipeBookList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBook>}
     * @memberof PaginatedRecipeBookList
     */
    results?: Array<RecipeBook>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeOverviewList
 */
export interface PaginatedRecipeOverviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeOverviewList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeOverview>}
     * @memberof PaginatedRecipeOverviewList
     */
    results?: Array<RecipeOverview>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListEntryList
 */
export interface PaginatedShoppingListEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListEntry>}
     * @memberof PaginatedShoppingListEntryList
     */
    results?: Array<ShoppingListEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListRecipeList
 */
export interface PaginatedShoppingListRecipeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListRecipeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListRecipe>}
     * @memberof PaginatedShoppingListRecipeList
     */
    results?: Array<ShoppingListRecipe>;
}
/**
 * 
 * @export
 * @interface PaginatedStepList
 */
export interface PaginatedStepList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStepList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PaginatedStepList
     */
    results?: Array<Step>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryList
 */
export interface PaginatedSupermarketCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategory>}
     * @memberof PaginatedSupermarketCategoryList
     */
    results?: Array<SupermarketCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryRelationList
 */
export interface PaginatedSupermarketCategoryRelationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    results?: Array<SupermarketCategoryRelation>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketList
 */
export interface PaginatedSupermarketList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Supermarket>}
     * @memberof PaginatedSupermarketList
     */
    results?: Array<Supermarket>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncList
 */
export interface PaginatedSyncList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Sync>}
     * @memberof PaginatedSyncList
     */
    results?: Array<Sync>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncLogList
 */
export interface PaginatedSyncLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SyncLog>}
     * @memberof PaginatedSyncLogList
     */
    results?: Array<SyncLog>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitConversionList
 */
export interface PaginatedUnitConversionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitConversionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UnitConversion>}
     * @memberof PaginatedUnitConversionList
     */
    results?: Array<UnitConversion>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitList
 */
export interface PaginatedUnitList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof PaginatedUnitList
     */
    results?: Array<Unit>;
}
/**
 * 
 * @export
 * @interface PaginatedUserFileList
 */
export interface PaginatedUserFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserFile>}
     * @memberof PaginatedUserFileList
     */
    results?: Array<UserFile>;
}
/**
 * 
 * @export
 * @interface PaginatedUserSpaceList
 */
export interface PaginatedUserSpaceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserSpaceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserSpace>}
     * @memberof PaginatedUserSpaceList
     */
    results?: Array<UserSpace>;
}
/**
 * 
 * @export
 * @interface PaginatedViewLogList
 */
export interface PaginatedViewLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedViewLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ViewLog>}
     * @memberof PaginatedViewLogList
     */
    results?: Array<ViewLog>;
}
/**
 * 
 * @export
 * @interface PatchedAccessToken
 */
export interface PatchedAccessToken {
    /**
     * 
     * @type {number}
     * @memberof PatchedAccessToken
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    token?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    expires?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessToken
     */
    updated?: string;
}
/**
 * 
 * @export
 * @interface PatchedAutomation
 */
export interface PatchedAutomation {
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    id?: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof PatchedAutomation
     */
    type?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAutomation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomation
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedBookmarkletImport
 */
export interface PatchedBookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImport
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    html?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImport
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImport
     */
    created_at?: string;
}
/**
 * 
 * @export
 * @interface PatchedConnectorConfigConfig
 */
export interface PatchedConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfig
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfig
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedCookLog
 */
export interface PatchedCookLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof PatchedCookLog
     */
    created_by?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLog
     */
    updated_at?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedCustomFilter
 */
export interface PatchedCustomFilter {
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilter
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilter
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilter
     */
    search?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedCustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilter
     */
    created_by?: number;
}
/**
 * 
 * @export
 * @interface PatchedExportLog
 */
export interface PatchedExportLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLog
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedFood
 */
export interface PatchedFood {
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    shopping?: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof PatchedFood
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PatchedFood
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedFood
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof PatchedFood
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    parent?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedFood
     */
    numchild?: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedFood
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof PatchedFood
     */
    full_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof PatchedFood
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFood
     */
    substitute_onhand?: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedFood
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFood
     */
    open_data_slug?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedImportLog
 */
export interface PatchedImportLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof PatchedImportLog
     */
    keyword?: Keyword;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLog
     */
    created_at?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedIngredient
 */
export interface PatchedIngredient {
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    id?: number;
    /**
     * 
     * @type {Food}
     * @memberof PatchedIngredient
     */
    food?: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedIngredient
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    amount?: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof PatchedIngredient
     */
    conversions?: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof PatchedIngredient
     */
    used_in_recipes?: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredient
     */
    always_use_plural_food?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedInviteLink
 */
export interface PatchedInviteLink {
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof PatchedInviteLink
     */
    group?: Group;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedInviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLink
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLink
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedKeyword
 */
export interface PatchedKeyword {
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    parent?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeyword
     */
    numchild?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeyword
     */
    updated_at?: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof PatchedKeyword
     */
    full_name?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealPlan
 */
export interface PatchedMealPlan {
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof PatchedMealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    note_markdown?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof PatchedMealPlan
     */
    meal_type?: MealType;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlan
     */
    created_by?: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlan
     */
    meal_type_name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealPlan
     */
    shopping?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealType
 */
export interface PatchedMealType {
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealType
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealType
     */
    created_by?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedProperty
 */
export interface PatchedProperty {
    /**
     * 
     * @type {number}
     * @memberof PatchedProperty
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedProperty
     */
    property_amount?: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof PatchedProperty
     */
    property_type?: PropertyType;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedPropertyType
 */
export interface PatchedPropertyType {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipe
 */
export interface PatchedRecipe {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    image?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PatchedRecipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PatchedRecipe
     */
    steps?: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof PatchedRecipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PatchedRecipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof PatchedRecipe
     */
    food_properties?: any | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipe
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipe
     */
    last_cooked?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedRecipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeBook
 */
export interface PatchedRecipeBook {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBook
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedRecipeBook
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    created_by?: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof PatchedRecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface PatchedRecipeBookEntry
 */
export interface PatchedRecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    book?: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof PatchedRecipeBookEntry
     */
    book_content?: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntry
     */
    recipe?: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof PatchedRecipeBookEntry
     */
    recipe_content?: RecipeOverview;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedShoppingListEntry
 */
export interface PatchedShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof PatchedShoppingListEntry
     */
    food?: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof PatchedShoppingListEntry
     */
    recipe_mealplan?: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof PatchedShoppingListEntry
     */
    created_by?: User;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    updated_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface PatchedShoppingListRecipe
 */
export interface PatchedShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    recipe_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListRecipe
     */
    mealplan_type?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSpace
 */
export interface PatchedSpace {
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    created_by?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    max_recipes?: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof PatchedSpace
     */
    max_file_storage_mb?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    max_users?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSpace
     */
    allow_sharing?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSpace
     */
    demo?: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof PatchedSpace
     */
    food_inherit?: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    user_count?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    recipe_count?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpace
     */
    file_size_mb?: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof PatchedSpace
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpace
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof PatchedSpace
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedSpace
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedStep
 */
export interface PatchedStep {
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PatchedStep
     */
    ingredients?: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof PatchedStep
     */
    instructions_markdown?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStep
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedStep
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof PatchedStep
     */
    step_recipe_data?: any | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStep
     */
    numrecipe?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStep
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface PatchedStorage
 */
export interface PatchedStorage {
    /**
     * 
     * @type {number}
     * @memberof PatchedStorage
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    name?: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof PatchedStorage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorage
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorage
     */
    created_by?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarket
 */
export interface PatchedSupermarket {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarket
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PatchedSupermarket
     */
    category_to_supermarket?: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketCategory
 */
export interface PatchedSupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSupermarketCategoryRelation
 */
export interface PatchedSupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    id?: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof PatchedSupermarketCategoryRelation
     */
    category?: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    supermarket?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelation
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface PatchedSync
 */
export interface PatchedSync {
    /**
     * 
     * @type {number}
     * @memberof PatchedSync
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSync
     */
    storage?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSync
     */
    updated_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedUnit
 */
export interface PatchedUnit {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUnitConversion
 */
export interface PatchedUnitConversion {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversion
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    base_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedUnitConversion
     */
    base_unit?: Unit;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversion
     */
    converted_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof PatchedUnitConversion
     */
    converted_unit?: Unit;
    /**
     * 
     * @type {Food}
     * @memberof PatchedUnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUser
 */
export interface PatchedUser {
    /**
     * 
     * @type {number}
     * @memberof PatchedUser
     */
    id?: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof PatchedUser
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUser
     */
    display_name?: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserPreference
 */
export interface PatchedUserPreference {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    user?: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof PatchedUserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof PatchedUserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof PatchedUserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof PatchedUserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedUserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof PatchedUserPreference
     */
    food_inherit_default?: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof PatchedUserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreference
     */
    food_children_exist?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserSpace
 */
export interface PatchedUserSpace {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    id?: number;
    /**
     * 
     * @type {User}
     * @memberof PatchedUserSpace
     */
    user?: User;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    space?: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof PatchedUserSpace
     */
    groups?: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpace
     */
    invite_link?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpace
     */
    updated_at?: string;
}
/**
 * 
 * @export
 * @interface PatchedViewLog
 */
export interface PatchedViewLog {
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLog
     */
    created_by?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedViewLog
     */
    created_at?: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    property_type: PropertyType;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    image: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof Recipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof Recipe
     */
    steps: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof Recipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Recipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof Recipe
     */
    food_properties: any | null;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof Recipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBook
 */
export interface RecipeBook {
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof RecipeBook
     */
    shared: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    created_by: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof RecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RecipeBookEntry
 */
export interface RecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    book: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof RecipeBookEntry
     */
    book_content: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    recipe: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof RecipeBookEntry
     */
    recipe_content: RecipeOverview;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeFlat
 */
export interface RecipeFlat {
    /**
     * 
     * @type {number}
     * @memberof RecipeFlat
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    image?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeImage
 */
export interface RecipeImage {
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image_url?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverview
 */
export interface RecipeOverview {
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    description: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    image: string | null;
    /**
     * 
     * @type {Array<KeywordLabel>}
     * @memberof RecipeOverview
     */
    keywords: Array<KeywordLabel>;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    working_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    waiting_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    updated_at: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    internal: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    servings_text: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    _new: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    recent: string;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdate
 */
export interface RecipeShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    id: number;
    /**
     * Existing shopping list to update
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    list_recipe?: number | null;
    /**
     * List of ingredient IDs from the recipe to add, if not provided all ingredients will be added.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    ingredients?: number | null;
    /**
     * Providing a list_recipe ID and servings of 0 will delete that shopping list.
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    servings?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimple
 */
export interface RecipeSimple {
    /**
     * 
     * @type {number}
     * @memberof RecipeSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    url: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntry
 */
export interface ShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof ShoppingListEntry
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof ShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof ShoppingListEntry
     */
    recipe_mealplan: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof ShoppingListEntry
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulk
 */
export interface ShoppingListEntryBulk {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulk
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulk
     */
    checked: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipe
 */
export interface ShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_note: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_from_date: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_type: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    created_by: number | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_recipes: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof Space
     */
    max_file_storage_mb: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_users: number;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    allow_sharing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    demo: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Space
     */
    food_inherit: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    user_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    recipe_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    file_size_mb: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof Space
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof Space
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * * `BLANK` - ------- * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum SpaceNavTextColorEnum {
    Blank = 'BLANK',
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * * `BLANK` - ------- * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum SpaceThemeEnum {
    Blank = 'BLANK',
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof Step
     */
    ingredients: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instructions_markdown: string;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof Step
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof Step
     */
    step_recipe_data: any | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    numrecipe: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_ingredients_table?: boolean;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof Storage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    created_by: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Supermarket
 */
export interface Supermarket {
    /**
     * 
     * @type {number}
     * @memberof Supermarket
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof Supermarket
     */
    category_to_supermarket: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategory
 */
export interface SupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelation
 */
export interface SupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    id: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof SupermarketCategoryRelation
     */
    category: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface Sync
 */
export interface Sync {
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface SyncLog
 */
export interface SyncLog {
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    sync: number;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    created_at: string;
}
/**
 * * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum ThemeEnum {
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * * `FOOD_ALIAS` - Food Alias * `UNIT_ALIAS` - Unit Alias * `KEYWORD_ALIAS` - Keyword Alias * `DESCRIPTION_REPLACE` - Description Replace * `INSTRUCTION_REPLACE` - Instruction Replace * `NEVER_UNIT` - Never Unit * `TRANSPOSE_WORDS` - Transpose Words * `FOOD_REPLACE` - Food Replace * `UNIT_REPLACE` - Unit Replace * `NAME_REPLACE` - Name Replace
 * @export
 * @enum {string}
 */
export enum TypeEnum {
    FoodAlias = 'FOOD_ALIAS',
    UnitAlias = 'UNIT_ALIAS',
    KeywordAlias = 'KEYWORD_ALIAS',
    DescriptionReplace = 'DESCRIPTION_REPLACE',
    InstructionReplace = 'INSTRUCTION_REPLACE',
    NeverUnit = 'NEVER_UNIT',
    TransposeWords = 'TRANSPOSE_WORDS',
    FoodReplace = 'FOOD_REPLACE',
    UnitReplace = 'UNIT_REPLACE',
    NameReplace = 'NAME_REPLACE'
}

/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversion
 */
export interface UnitConversion {
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    base_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    base_unit: Unit;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    converted_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    converted_unit: Unit;
    /**
     * 
     * @type {Food}
     * @memberof UnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
}
/**
 * 
 * @export
 * @interface UserFile
 */
export interface UserFile {
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    preview: string;
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    file_size_kb: number;
}
/**
 * 
 * @export
 * @interface UserFileView
 */
export interface UserFileView {
    /**
     * 
     * @type {number}
     * @memberof UserFileView
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    preview: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    user: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof UserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof UserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof UserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof UserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof UserPreference
     */
    food_inherit_default: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    food_children_exist: boolean;
}
/**
 * * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum UserPreferenceNavTextColorEnum {
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface UserSpace
 */
export interface UserSpace {
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    id: number;
    /**
     * 
     * @type {User}
     * @memberof UserSpace
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    space: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof UserSpace
     */
    groups: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    invite_link: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface ViewLog
 */
export interface ViewLog {
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_at: string;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenCreate: async (accessToken: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('apiAccessTokenCreate', 'accessToken', accessToken)
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenDestroy', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenPartialUpdate: async (id: number, patchedAccessToken?: PatchedAccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenPartialUpdate', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenRetrieve', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenUpdate: async (id: number, accessToken: AccessToken, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenUpdate', 'id', id)
            // verify required parameter 'accessToken' is not null or undefined
            assertParamExists('apiAccessTokenUpdate', 'accessToken', accessToken)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessToken, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutoPlanCreate: async (autoMealPlan: AutoMealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoMealPlan' is not null or undefined
            assertParamExists('apiAutoPlanCreate', 'autoMealPlan', autoMealPlan)
            const localVarPath = `/api/auto-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoMealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationCreate: async (automation: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('apiAutomationCreate', 'automation', automation)
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationDestroy', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationList: async (page?: number, pageSize?: number, type?: 'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE', options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationPartialUpdate: async (id: number, patchedAutomation?: PatchedAutomation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationPartialUpdate', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAutomation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationRetrieve', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationUpdate: async (id: number, automation: Automation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationUpdate', 'id', id)
            // verify required parameter 'automation' is not null or undefined
            assertParamExists('apiAutomationUpdate', 'automation', automation)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportCreate: async (bookmarkletImport: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookmarkletImport' is not null or undefined
            assertParamExists('apiBookmarkletImportCreate', 'bookmarkletImport', bookmarkletImport)
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportDestroy', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportPartialUpdate: async (id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportPartialUpdate', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportRetrieve', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportUpdate: async (id: number, bookmarkletImport: BookmarkletImport, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportUpdate', 'id', id)
            // verify required parameter 'bookmarkletImport' is not null or undefined
            assertParamExists('apiBookmarkletImportUpdate', 'bookmarkletImport', bookmarkletImport)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigCreate: async (connectorConfigConfig: ConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorConfigConfig' is not null or undefined
            assertParamExists('apiConnectorConfigCreate', 'connectorConfigConfig', connectorConfigConfig)
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigDestroy', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigPartialUpdate: async (id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigPartialUpdate', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConnectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigRetrieve', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigUpdate: async (id: number, connectorConfigConfig: ConnectorConfigConfig, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigUpdate', 'id', id)
            // verify required parameter 'connectorConfigConfig' is not null or undefined
            assertParamExists('apiConnectorConfigUpdate', 'connectorConfigConfig', connectorConfigConfig)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogCreate: async (cookLog: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cookLog' is not null or undefined
            assertParamExists('apiCookLogCreate', 'cookLog', cookLog)
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogDestroy', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogList: async (page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogPartialUpdate: async (id: number, patchedCookLog?: PatchedCookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogPartialUpdate', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogRetrieve', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogUpdate: async (id: number, cookLog: CookLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogUpdate', 'id', id)
            // verify required parameter 'cookLog' is not null or undefined
            assertParamExists('apiCookLogUpdate', 'cookLog', cookLog)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterCreate: async (customFilter: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFilter' is not null or undefined
            assertParamExists('apiCustomFilterCreate', 'customFilter', customFilter)
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterDestroy', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {'FOOD' | 'KEYWORD' | 'RECIPE'} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: 'FOOD' | 'KEYWORD' | 'RECIPE', updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterPartialUpdate: async (id: number, patchedCustomFilter?: PatchedCustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterPartialUpdate', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterRetrieve', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterUpdate: async (id: number, customFilter: CustomFilter, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterUpdate', 'id', id)
            // verify required parameter 'customFilter' is not null or undefined
            assertParamExists('apiCustomFilterUpdate', 'customFilter', customFilter)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDownloadFileRetrieve: async (fileId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('apiDownloadFileRetrieve', 'fileId', fileId)
            const localVarPath = `/api/download-file/{fileId}/`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogCreate: async (exportLog: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportLog' is not null or undefined
            assertParamExists('apiExportLogCreate', 'exportLog', exportLog)
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogDestroy', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogPartialUpdate: async (id: number, patchedExportLog?: PatchedExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogPartialUpdate', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogRetrieve', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogUpdate: async (id: number, exportLog: ExportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogUpdate', 'id', id)
            // verify required parameter 'exportLog' is not null or undefined
            assertParamExists('apiExportLogUpdate', 'exportLog', exportLog)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodCreate: async (food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'food' is not null or undefined
            assertParamExists('apiFoodCreate', 'food', food)
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodDestroy', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodFdcCreate: async (id: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodFdcCreate', 'id', id)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('apiFoodFdcCreate', 'food', food)
            const localVarPath = `/api/food/{id}/fdc/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-inherit-field/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodInheritFieldRetrieve', 'id', id)
            const localVarPath = `/api/food-inherit-field/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMergeUpdate: async (id: number, target: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'target', target)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'food', food)
            const localVarPath = `/api/food/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMoveUpdate: async (id: number, parent: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'parent', parent)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'food', food)
            const localVarPath = `/api/food/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPartialUpdate: async (id: number, patchedFood?: PatchedFood, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPartialUpdate', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFood, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyCreate: async (property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'property' is not null or undefined
            assertParamExists('apiFoodPropertyCreate', 'property', property)
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyDestroy', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyPartialUpdate: async (id: number, patchedProperty?: PatchedProperty, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyPartialUpdate', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedProperty, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyRetrieve', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeCreate: async (propertyType: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyType' is not null or undefined
            assertParamExists('apiFoodPropertyTypeCreate', 'propertyType', propertyType)
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeDestroy', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeList: async (category?: 'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE', page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypePartialUpdate: async (id: number, patchedPropertyType?: PatchedPropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypePartialUpdate', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeRetrieve', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeUpdate: async (id: number, propertyType: PropertyType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeUpdate', 'id', id)
            // verify required parameter 'propertyType' is not null or undefined
            assertParamExists('apiFoodPropertyTypeUpdate', 'propertyType', propertyType)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyUpdate: async (id: number, property: Property, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyUpdate', 'id', id)
            // verify required parameter 'property' is not null or undefined
            assertParamExists('apiFoodPropertyUpdate', 'property', property)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(property, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodRetrieve', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodShoppingUpdate: async (id: number, foodShoppingUpdate: FoodShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodShoppingUpdate', 'id', id)
            // verify required parameter 'foodShoppingUpdate' is not null or undefined
            assertParamExists('apiFoodShoppingUpdate', 'foodShoppingUpdate', foodShoppingUpdate)
            const localVarPath = `/api/food/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodUpdate: async (id: number, food: Food, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodUpdate', 'id', id)
            // verify required parameter 'food' is not null or undefined
            assertParamExists('apiFoodUpdate', 'food', food)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(food, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiGroupRetrieve', 'id', id)
            const localVarPath = `/api/group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogCreate: async (importLog: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importLog' is not null or undefined
            assertParamExists('apiImportLogCreate', 'importLog', importLog)
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogDestroy', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogPartialUpdate: async (id: number, patchedImportLog?: PatchedImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogPartialUpdate', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedImportLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogRetrieve', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogUpdate: async (id: number, importLog: ImportLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogUpdate', 'id', id)
            // verify required parameter 'importLog' is not null or undefined
            assertParamExists('apiImportLogUpdate', 'importLog', importLog)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientCreate: async (ingredient: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredient' is not null or undefined
            assertParamExists('apiIngredientCreate', 'ingredient', ingredient)
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientDestroy', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientList: async (food?: number, page?: number, pageSize?: number, unit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (food !== undefined) {
                localVarQueryParameter['food'] = food;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientPartialUpdate: async (id: number, patchedIngredient?: PatchedIngredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientPartialUpdate', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIngredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientRetrieve', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientUpdate: async (id: number, ingredient: Ingredient, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientUpdate', 'id', id)
            // verify required parameter 'ingredient' is not null or undefined
            assertParamExists('apiIngredientUpdate', 'ingredient', ingredient)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredient, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkCreate: async (inviteLink: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteLink' is not null or undefined
            assertParamExists('apiInviteLinkCreate', 'inviteLink', inviteLink)
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkDestroy', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkList: async (internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkPartialUpdate: async (id: number, patchedInviteLink?: PatchedInviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkPartialUpdate', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedInviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkRetrieve', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkUpdate: async (id: number, inviteLink: InviteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkUpdate', 'id', id)
            // verify required parameter 'inviteLink' is not null or undefined
            assertParamExists('apiInviteLinkUpdate', 'inviteLink', inviteLink)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordCreate: async (keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('apiKeywordCreate', 'keyword', keyword)
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordDestroy', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMergeUpdate: async (id: number, target: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'target', target)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMoveUpdate: async (id: number, parent: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'parent', parent)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordPartialUpdate: async (id: number, patchedKeyword?: PatchedKeyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordPartialUpdate', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedKeyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordRetrieve', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordUpdate: async (id: number, keyword: Keyword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordUpdate', 'id', id)
            // verify required parameter 'keyword' is not null or undefined
            assertParamExists('apiKeywordUpdate', 'keyword', keyword)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keyword, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanCreate: async (mealPlan: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealPlan' is not null or undefined
            assertParamExists('apiMealPlanCreate', 'mealPlan', mealPlan)
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanDestroy', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanIcalRetrieve: async (fromDate?: string, mealType?: string, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/ical/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType !== undefined) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanList: async (fromDate?: string, mealType?: string, page?: number, pageSize?: number, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType !== undefined) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanPartialUpdate: async (id: number, patchedMealPlan?: PatchedMealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanPartialUpdate', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanRetrieve', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanUpdate: async (id: number, mealPlan: MealPlan, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanUpdate', 'id', id)
            // verify required parameter 'mealPlan' is not null or undefined
            assertParamExists('apiMealPlanUpdate', 'mealPlan', mealPlan)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlan, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeCreate: async (mealType: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealType' is not null or undefined
            assertParamExists('apiMealTypeCreate', 'mealType', mealType)
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeDestroy', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypePartialUpdate: async (id: number, patchedMealType?: PatchedMealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypePartialUpdate', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeRetrieve', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeUpdate: async (id: number, mealType: MealType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeUpdate', 'id', id)
            // verify required parameter 'mealType' is not null or undefined
            assertParamExists('apiMealTypeUpdate', 'mealType', mealType)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealType, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlanIcalRetrieve: async (fromDate: string, toDate: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromDate' is not null or undefined
            assertParamExists('apiPlanIcalRetrieve', 'fromDate', fromDate)
            // verify required parameter 'toDate' is not null or undefined
            assertParamExists('apiPlanIcalRetrieve', 'toDate', toDate)
            const localVarPath = `/api/plan-ical/{fromDate}/{toDate}/`
                .replace(`{${"fromDate"}}`, encodeURIComponent(String(fromDate)))
                .replace(`{${"toDate"}}`, encodeURIComponent(String(toDate)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookCreate: async (recipeBook: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBook' is not null or undefined
            assertParamExists('apiRecipeBookCreate', 'recipeBook', recipeBook)
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookDestroy', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryCreate: async (recipeBookEntry: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookEntry' is not null or undefined
            assertParamExists('apiRecipeBookEntryCreate', 'recipeBookEntry', recipeBookEntry)
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryDestroy', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryList: async (book?: number, page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryPartialUpdate: async (id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryPartialUpdate', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryRetrieve', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryUpdate: async (id: number, recipeBookEntry: RecipeBookEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryUpdate', 'id', id)
            // verify required parameter 'recipeBookEntry' is not null or undefined
            assertParamExists('apiRecipeBookEntryUpdate', 'recipeBookEntry', recipeBookEntry)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookList: async (limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (orderField !== undefined) {
                localVarQueryParameter['order_field'] = orderField;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookPartialUpdate: async (id: number, patchedRecipeBook?: PatchedRecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookPartialUpdate', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookRetrieve', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookUpdate: async (id: number, recipeBook: RecipeBook, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookUpdate', 'id', id)
            // verify required parameter 'recipeBook' is not null or undefined
            assertParamExists('apiRecipeBookUpdate', 'recipeBook', recipeBook)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBook, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeCreate: async (recipe: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipe' is not null or undefined
            assertParamExists('apiRecipeCreate', 'recipe', recipe)
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeDestroy', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFlatList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/flat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFromSourceCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-from-source/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeImageUpdate: async (id: number, image?: string, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeImageUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeList: async (books?: number, booksAnd?: number, booksAndNot?: number, booksOr?: number, booksOrNot?: number, cookedon?: string, createdon?: string, foods?: number, foodsAnd?: number, foodsAndNot?: number, foodsOr?: number, foodsOrNot?: number, internal?: boolean, keywords?: number, keywordsAnd?: number, keywordsAndNot?: number, keywordsOr?: number, keywordsOrNot?: number, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (books !== undefined) {
                localVarQueryParameter['books'] = books;
            }

            if (booksAnd !== undefined) {
                localVarQueryParameter['books_and'] = booksAnd;
            }

            if (booksAndNot !== undefined) {
                localVarQueryParameter['books_and_not'] = booksAndNot;
            }

            if (booksOr !== undefined) {
                localVarQueryParameter['books_or'] = booksOr;
            }

            if (booksOrNot !== undefined) {
                localVarQueryParameter['books_or_not'] = booksOrNot;
            }

            if (cookedon !== undefined) {
                localVarQueryParameter['cookedon'] = cookedon;
            }

            if (createdon !== undefined) {
                localVarQueryParameter['createdon'] = createdon;
            }

            if (foods !== undefined) {
                localVarQueryParameter['foods'] = foods;
            }

            if (foodsAnd !== undefined) {
                localVarQueryParameter['foods_and'] = foodsAnd;
            }

            if (foodsAndNot !== undefined) {
                localVarQueryParameter['foods_and_not'] = foodsAndNot;
            }

            if (foodsOr !== undefined) {
                localVarQueryParameter['foods_or'] = foodsOr;
            }

            if (foodsOrNot !== undefined) {
                localVarQueryParameter['foods_or_not'] = foodsOrNot;
            }

            if (internal !== undefined) {
                localVarQueryParameter['internal'] = internal;
            }

            if (keywords !== undefined) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (keywordsAnd !== undefined) {
                localVarQueryParameter['keywords_and'] = keywordsAnd;
            }

            if (keywordsAndNot !== undefined) {
                localVarQueryParameter['keywords_and_not'] = keywordsAndNot;
            }

            if (keywordsOr !== undefined) {
                localVarQueryParameter['keywords_or'] = keywordsOr;
            }

            if (keywordsOrNot !== undefined) {
                localVarQueryParameter['keywords_or_not'] = keywordsOrNot;
            }

            if (makenow !== undefined) {
                localVarQueryParameter['makenow'] = makenow;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (timescooked !== undefined) {
                localVarQueryParameter['timescooked'] = timescooked;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (updatedon !== undefined) {
                localVarQueryParameter['updatedon'] = updatedon;
            }

            if (viewedon !== undefined) {
                localVarQueryParameter['viewedon'] = viewedon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipePartialUpdate: async (id: number, patchedRecipe?: PatchedRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipePartialUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRelatedRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeRelatedRetrieve', 'id', id)
            const localVarPath = `/api/recipe/{id}/related/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeRetrieve', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeShoppingUpdate: async (id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeShoppingUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeShoppingUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeUpdate: async (id: number, recipe: Recipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeUpdate', 'id', id)
            // verify required parameter 'recipe' is not null or undefined
            assertParamExists('apiRecipeUpdate', 'recipe', recipe)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResetFoodInheritanceRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reset-food-inheritance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShareLinkRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShareLinkRetrieve', 'id', id)
            const localVarPath = `/api/share-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryBulkCreate: async (shoppingListEntryBulk: ShoppingListEntryBulk, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryBulk' is not null or undefined
            assertParamExists('apiShoppingListEntryBulkCreate', 'shoppingListEntryBulk', shoppingListEntryBulk)
            const localVarPath = `/api/shopping-list-entry/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryBulk, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryCreate: async (shoppingListEntry: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntry' is not null or undefined
            assertParamExists('apiShoppingListEntryCreate', 'shoppingListEntry', shoppingListEntry)
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryDestroy', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryList: async (checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checked !== undefined) {
                localVarQueryParameter['checked'] = checked;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (supermarket !== undefined) {
                localVarQueryParameter['supermarket'] = supermarket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryPartialUpdate: async (id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryPartialUpdate', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryRetrieve', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryUpdate: async (id: number, shoppingListEntry: ShoppingListEntry, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryUpdate', 'id', id)
            // verify required parameter 'shoppingListEntry' is not null or undefined
            assertParamExists('apiShoppingListEntryUpdate', 'shoppingListEntry', shoppingListEntry)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntry, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeCreate: async (shoppingListRecipe: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListRecipe' is not null or undefined
            assertParamExists('apiShoppingListRecipeCreate', 'shoppingListRecipe', shoppingListRecipe)
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeDestroy', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipePartialUpdate: async (id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipePartialUpdate', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeRetrieve', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeUpdate: async (id: number, shoppingListRecipe: ShoppingListRecipe, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeUpdate', 'id', id)
            // verify required parameter 'shoppingListRecipe' is not null or undefined
            assertParamExists('apiShoppingListRecipeUpdate', 'shoppingListRecipe', shoppingListRecipe)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpacePartialUpdate: async (id: number, patchedSpace?: PatchedSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSpacePartialUpdate', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSpaceRetrieve', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepCreate: async (step: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'step' is not null or undefined
            assertParamExists('apiStepCreate', 'step', step)
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepDestroy', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepList: async (page?: number, pageSize?: number, query?: string, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepPartialUpdate: async (id: number, patchedStep?: PatchedStep, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepPartialUpdate', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStep, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepRetrieve', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepUpdate: async (id: number, step: Step, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepUpdate', 'id', id)
            // verify required parameter 'step' is not null or undefined
            assertParamExists('apiStepUpdate', 'step', step)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(step, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageCreate: async (storage: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'storage' is not null or undefined
            assertParamExists('apiStorageCreate', 'storage', storage)
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageDestroy', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStoragePartialUpdate: async (id: number, patchedStorage?: PatchedStorage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStoragePartialUpdate', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStorage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageRetrieve', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageUpdate: async (id: number, storage: Storage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageUpdate', 'id', id)
            // verify required parameter 'storage' is not null or undefined
            assertParamExists('apiStorageUpdate', 'storage', storage)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryCreate: async (supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('apiSupermarketCategoryCreate', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryDestroy', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryMergeUpdate: async (id: number, target: number, supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'target', target)
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryPartialUpdate: async (id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationCreate: async (supermarketCategoryRelation: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRelation' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationCreate', 'supermarketCategoryRelation', supermarketCategoryRelation)
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationDestroy', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationPartialUpdate: async (id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationRetrieve', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationUpdate: async (id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationUpdate', 'id', id)
            // verify required parameter 'supermarketCategoryRelation' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationUpdate', 'supermarketCategoryRelation', supermarketCategoryRelation)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRetrieve', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryUpdate: async (id: number, supermarketCategory: SupermarketCategory, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryUpdate', 'id', id)
            // verify required parameter 'supermarketCategory' is not null or undefined
            assertParamExists('apiSupermarketCategoryUpdate', 'supermarketCategory', supermarketCategory)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCreate: async (supermarket: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarket' is not null or undefined
            assertParamExists('apiSupermarketCreate', 'supermarket', supermarket)
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketDestroy', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketPartialUpdate: async (id: number, patchedSupermarket?: PatchedSupermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketRetrieve', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketUpdate: async (id: number, supermarket: Supermarket, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketUpdate', 'id', id)
            // verify required parameter 'supermarket' is not null or undefined
            assertParamExists('apiSupermarketUpdate', 'supermarket', supermarket)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarket, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwitchActiveSpaceRetrieve: async (spaceId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spaceId' is not null or undefined
            assertParamExists('apiSwitchActiveSpaceRetrieve', 'spaceId', spaceId)
            const localVarPath = `/api/switch-active-space/{spaceId}/`
                .replace(`{${"spaceId"}}`, encodeURIComponent(String(spaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncCreate: async (sync: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'sync' is not null or undefined
            assertParamExists('apiSyncCreate', 'sync', sync)
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncDestroy', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncLogRetrieve', 'id', id)
            const localVarPath = `/api/sync-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncPartialUpdate: async (id: number, patchedSync?: PatchedSync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncPartialUpdate', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncRetrieve', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncUpdate: async (id: number, sync: Sync, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncUpdate', 'id', id)
            // verify required parameter 'sync' is not null or undefined
            assertParamExists('apiSyncUpdate', 'sync', sync)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sync, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionCreate: async (unitConversion: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitConversion' is not null or undefined
            assertParamExists('apiUnitConversionCreate', 'unitConversion', unitConversion)
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionDestroy', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionList: async (foodId?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (foodId !== undefined) {
                localVarQueryParameter['food_id'] = foodId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionPartialUpdate: async (id: number, patchedUnitConversion?: PatchedUnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionPartialUpdate', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionRetrieve', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionUpdate: async (id: number, unitConversion: UnitConversion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionUpdate', 'id', id)
            // verify required parameter 'unitConversion' is not null or undefined
            assertParamExists('apiUnitConversionUpdate', 'unitConversion', unitConversion)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversion, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitCreate: async (unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('apiUnitCreate', 'unit', unit)
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitDestroy', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitMergeUpdate: async (id: number, target: number, unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'target', target)
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'unit', unit)
            const localVarPath = `/api/unit/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitPartialUpdate: async (id: number, patchedUnit?: PatchedUnit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitPartialUpdate', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitRetrieve', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitUpdate: async (id: number, unit: Unit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitUpdate', 'id', id)
            // verify required parameter 'unit' is not null or undefined
            assertParamExists('apiUnitUpdate', 'unit', unit)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unit, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileCreate: async (id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileCreate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiUserFileCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiUserFileCreate', 'file', file)
            // verify required parameter 'fileDownload' is not null or undefined
            assertParamExists('apiUserFileCreate', 'fileDownload', fileDownload)
            // verify required parameter 'preview' is not null or undefined
            assertParamExists('apiUserFileCreate', 'preview', preview)
            // verify required parameter 'fileSizeKb' is not null or undefined
            assertParamExists('apiUserFileCreate', 'fileSizeKb', fileSizeKb)
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileDestroy', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFilePartialUpdate: async (id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFilePartialUpdate', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileRetrieve', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} id2 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileUpdate: async (id: number, id2: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'id', id)
            // verify required parameter 'id2' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'id2', id2)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'file', file)
            // verify required parameter 'fileDownload' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'fileDownload', fileDownload)
            // verify required parameter 'preview' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'preview', preview)
            // verify required parameter 'fileSizeKb' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'fileSizeKb', fileSizeKb)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (fileDownload !== undefined) { 
                localVarFormParams.append('file_download', fileDownload as any);
            }
    
            if (preview !== undefined) { 
                localVarFormParams.append('preview', preview as any);
            }
    
            if (fileSizeKb !== undefined) { 
                localVarFormParams.append('file_size_kb', fileSizeKb as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserList: async (filterList?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filterList !== undefined) {
                localVarQueryParameter['filter_list'] = filterList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPartialUpdate: async (id: number, patchedUser?: PatchedUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserPartialUpdate', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUser, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencePartialUpdate: async (user: number, patchedUserPreference?: PatchedUserPreference, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserPreferencePartialUpdate', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserPreference, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceRetrieve: async (user: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserPreferenceRetrieve', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserRetrieve', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpaceDestroy', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceList: async (internalNote?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpacePartialUpdate: async (id: number, patchedUserSpace?: PatchedUserSpace, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpacePartialUpdate', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserSpace, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpaceRetrieve', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogCreate: async (viewLog: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewLog' is not null or undefined
            assertParamExists('apiViewLogCreate', 'viewLog', viewLog)
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogDestroy', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogPartialUpdate: async (id: number, patchedViewLog?: PatchedViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogPartialUpdate', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogRetrieve', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogUpdate: async (id: number, viewLog: ViewLog, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogUpdate', 'id', id)
            // verify required parameter 'viewLog' is not null or undefined
            assertParamExists('apiViewLogUpdate', 'viewLog', viewLog)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLog, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenCreate(accessToken: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenCreate(accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenPartialUpdate(id: number, patchedAccessToken?: PatchedAccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenPartialUpdate(id, patchedAccessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenUpdate(id: number, accessToken: AccessToken, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenUpdate(id, accessToken, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutoPlanCreate(autoMealPlan: AutoMealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoMealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutoPlanCreate(autoMealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationCreate(automation: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationCreate(automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationList(page?: number, pageSize?: number, type?: 'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAutomationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationList(page, pageSize, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationPartialUpdate(id: number, patchedAutomation?: PatchedAutomation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationPartialUpdate(id, patchedAutomation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationUpdate(id: number, automation: Automation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationUpdate(id, automation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportCreate(bookmarkletImport: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportCreate(bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBookmarkletImportListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportUpdate(id: number, bookmarkletImport: BookmarkletImport, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportUpdate(id, bookmarkletImport, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigCreate(connectorConfigConfig: ConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigCreate(connectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorConfigConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigUpdate(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigUpdate(id, connectorConfigConfig, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogCreate(cookLog: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogCreate(cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCookLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogList(page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogPartialUpdate(id: number, patchedCookLog?: PatchedCookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogPartialUpdate(id, patchedCookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogUpdate(id: number, cookLog: CookLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogUpdate(id, cookLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterCreate(customFilter: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterCreate(customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {'FOOD' | 'KEYWORD' | 'RECIPE'} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: 'FOOD' | 'KEYWORD' | 'RECIPE', updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomFilterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterPartialUpdate(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterPartialUpdate(id, patchedCustomFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterUpdate(id: number, customFilter: CustomFilter, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterUpdate(id, customFilter, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDownloadFileRetrieve(fileId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDownloadFileRetrieve(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogCreate(exportLog: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogCreate(exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogPartialUpdate(id: number, patchedExportLog?: PatchedExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogPartialUpdate(id, patchedExportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogUpdate(id: number, exportLog: ExportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogUpdate(id, exportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodCreate(food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodCreate(food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodFdcCreate(id: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodFdcCreate(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodInheritFieldList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodInheritField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodInheritFieldList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodInheritFieldRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodInheritField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodInheritFieldRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFoodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodMergeUpdate(id: number, target: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodMergeUpdate(id, target, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodMoveUpdate(id: number, parent: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodMoveUpdate(id, parent, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPartialUpdate(id: number, patchedFood?: PatchedFood, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPartialUpdate(id, patchedFood, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyCreate(property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyCreate(property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyPartialUpdate(id: number, patchedProperty?: PatchedProperty, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyPartialUpdate(id, patchedProperty, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeCreate(propertyType: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeCreate(propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeList(category?: 'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE', page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeList(category, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyType?: PatchedPropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypePartialUpdate(id, patchedPropertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeUpdate(id: number, propertyType: PropertyType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeUpdate(id, propertyType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyUpdate(id: number, property: Property, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyUpdate(id, property, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodShoppingUpdate(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodShoppingUpdate(id, foodShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodUpdate(id: number, food: Food, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodUpdate(id, food, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogCreate(importLog: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogCreate(importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogPartialUpdate(id: number, patchedImportLog?: PatchedImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogPartialUpdate(id, patchedImportLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogUpdate(id: number, importLog: ImportLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogUpdate(id, importLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientCreate(ingredient: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientCreate(ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIngredientList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientList(food, page, pageSize, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientPartialUpdate(id: number, patchedIngredient?: PatchedIngredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientPartialUpdate(id, patchedIngredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientUpdate(id: number, ingredient: Ingredient, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientUpdate(id, ingredient, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkCreate(inviteLink: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkCreate(inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInviteLinkList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkPartialUpdate(id: number, patchedInviteLink?: PatchedInviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkPartialUpdate(id, patchedInviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkUpdate(id: number, inviteLink: InviteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkUpdate(id, inviteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordCreate(keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordCreate(keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKeywordList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordMergeUpdate(id: number, target: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordMergeUpdate(id, target, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordMoveUpdate(id: number, parent: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordMoveUpdate(id, parent, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordPartialUpdate(id: number, patchedKeyword?: PatchedKeyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordPartialUpdate(id, patchedKeyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordUpdate(id: number, keyword: Keyword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordUpdate(id, keyword, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanCreate(mealPlan: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanCreate(mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanIcalRetrieve(fromDate?: string, mealType?: string, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanList(fromDate?: string, mealType?: string, page?: number, pageSize?: number, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealPlanList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanPartialUpdate(id: number, patchedMealPlan?: PatchedMealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanPartialUpdate(id, patchedMealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanUpdate(id: number, mealPlan: MealPlan, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanUpdate(id, mealPlan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeCreate(mealType: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeCreate(mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypePartialUpdate(id: number, patchedMealType?: PatchedMealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypePartialUpdate(id, patchedMealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeUpdate(id: number, mealType: MealType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeUpdate(id, mealType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiPlanIcalRetrieve(fromDate: string, toDate: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiPlanIcalRetrieve(fromDate, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookCreate(recipeBook: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookCreate(recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryCreate(recipeBookEntry: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryCreate(recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryList(book, page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryUpdate(id: number, recipeBookEntry: RecipeBookEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryUpdate(id, recipeBookEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookPartialUpdate(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookPartialUpdate(id, patchedRecipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookUpdate(id: number, recipeBook: RecipeBook, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookUpdate(id, recipeBook, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeCreate(recipe: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeCreate(recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeFlatList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeFlat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeFlatList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeFromSourceCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeFromSourceCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeImageUpdate(id: number, image?: string, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeImageUpdate(id, image, imageUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeList(books?: number, booksAnd?: number, booksAndNot?: number, booksOr?: number, booksOrNot?: number, cookedon?: string, createdon?: string, foods?: number, foodsAnd?: number, foodsAndNot?: number, foodsOr?: number, foodsOrNot?: number, internal?: boolean, keywords?: number, keywordsAnd?: number, keywordsAndNot?: number, keywordsOr?: number, keywordsOrNot?: number, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeOverviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipePartialUpdate(id: number, patchedRecipe?: PatchedRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipePartialUpdate(id, patchedRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeRelatedRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeRelatedRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeShoppingUpdate(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeShoppingUpdate(id, recipeShoppingUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeUpdate(id: number, recipe: Recipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeUpdate(id, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResetFoodInheritanceRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResetFoodInheritanceRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShareLinkRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShareLinkRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryBulkCreate(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntryBulk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryBulkCreate(shoppingListEntryBulk, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryCreate(shoppingListEntry: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryCreate(shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryUpdate(id: number, shoppingListEntry: ShoppingListEntry, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryUpdate(id, shoppingListEntry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeCreate(shoppingListRecipe: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeCreate(shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListRecipeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeUpdate(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeUpdate(id, shoppingListRecipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSpacePartialUpdate(id: number, patchedSpace?: PatchedSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSpacePartialUpdate(id, patchedSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSpaceRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSpaceRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepCreate(step: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepCreate(step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepList(page?: number, pageSize?: number, query?: string, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStepList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepList(page, pageSize, query, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepPartialUpdate(id: number, patchedStep?: PatchedStep, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepPartialUpdate(id, patchedStep, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepUpdate(id: number, step: Step, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepUpdate(id, step, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageCreate(storage: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageCreate(storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStoragePartialUpdate(id: number, patchedStorage?: PatchedStorage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStoragePartialUpdate(id, patchedStorage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageUpdate(id: number, storage: Storage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageUpdate(id, storage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryCreate(supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryCreate(supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryMergeUpdate(id, target, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationCreate(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationCreate(supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryRelationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryUpdate(id: number, supermarketCategory: SupermarketCategory, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryUpdate(id, supermarketCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCreate(supermarket: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCreate(supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketPartialUpdate(id: number, patchedSupermarket?: PatchedSupermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketPartialUpdate(id, patchedSupermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketUpdate(id: number, supermarket: Supermarket, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketUpdate(id, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSwitchActiveSpaceRetrieve(spaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncCreate(sync: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncCreate(sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncPartialUpdate(id: number, patchedSync?: PatchedSync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncPartialUpdate(id, patchedSync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncUpdate(id: number, sync: Sync, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncUpdate(id, sync, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionCreate(unitConversion: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionCreate(unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitConversionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionList(foodId, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionPartialUpdate(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionPartialUpdate(id, patchedUnitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionUpdate(id: number, unitConversion: UnitConversion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionUpdate(id, unitConversion, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitCreate(unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitCreate(unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitMergeUpdate(id: number, target: number, unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitMergeUpdate(id, target, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitPartialUpdate(id: number, patchedUnit?: PatchedUnit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitPartialUpdate(id, patchedUnit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitUpdate(id: number, unit: Unit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitUpdate(id, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileCreate(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileCreate(id, name, file, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFilePartialUpdate(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFilePartialUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} id2 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileUpdate(id: number, id2: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserList(filterList?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserList(filterList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPartialUpdate(id, patchedUser, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferencePartialUpdate(user: number, patchedUserPreference?: PatchedUserPreference, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferencePartialUpdate(user, patchedUserPreference, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferenceRetrieve(user: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferenceRetrieve(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserSpaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceList(internalNote, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpacePartialUpdate(id: number, patchedUserSpace?: PatchedUserSpace, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpacePartialUpdate(id, patchedUserSpace, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogCreate(viewLog: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogCreate(viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedViewLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogPartialUpdate(id: number, patchedViewLog?: PatchedViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogPartialUpdate(id, patchedViewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogUpdate(id: number, viewLog: ViewLog, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogUpdate(id, viewLog, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenCreate(accessToken: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenCreate(accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiAccessTokenDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenList(options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.apiAccessTokenList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessToken} [patchedAccessToken] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenPartialUpdate(id: number, patchedAccessToken?: PatchedAccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenPartialUpdate(id, patchedAccessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenRetrieve(id: number, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessToken} accessToken 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenUpdate(id: number, accessToken: AccessToken, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenUpdate(id, accessToken, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutoMealPlan} autoMealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutoPlanCreate(autoMealPlan: AutoMealPlan, options?: any): AxiosPromise<AutoMealPlan> {
            return localVarFp.apiAutoPlanCreate(autoMealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationCreate(automation: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationCreate(automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiAutomationDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationList(page?: number, pageSize?: number, type?: 'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE', options?: any): AxiosPromise<PaginatedAutomationList> {
            return localVarFp.apiAutomationList(page, pageSize, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomation} [patchedAutomation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationPartialUpdate(id: number, patchedAutomation?: PatchedAutomation, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationPartialUpdate(id, patchedAutomation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationRetrieve(id: number, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {Automation} automation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationUpdate(id: number, automation: Automation, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationUpdate(id, automation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportCreate(bookmarkletImport: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportCreate(bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiBookmarkletImportDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBookmarkletImportListList> {
            return localVarFp.apiBookmarkletImportList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportRetrieve(id: number, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImport} bookmarkletImport 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportUpdate(id: number, bookmarkletImport: BookmarkletImport, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportUpdate(id, bookmarkletImport, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigCreate(connectorConfigConfig: ConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigCreate(connectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiConnectorConfigDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigList(options?: any): AxiosPromise<Array<ConnectorConfigConfig>> {
            return localVarFp.apiConnectorConfigList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigRetrieve(id: number, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfig} connectorConfigConfig 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigUpdate(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigUpdate(id, connectorConfigConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogCreate(cookLog: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogCreate(cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiCookLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedCookLogList> {
            return localVarFp.apiCookLogList(page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLog} [patchedCookLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogPartialUpdate(id: number, patchedCookLog?: PatchedCookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogPartialUpdate(id, patchedCookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogRetrieve(id: number, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLog} cookLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogUpdate(id: number, cookLog: CookLog, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogUpdate(id, cookLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterCreate(customFilter: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterCreate(customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiCustomFilterDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {'FOOD' | 'KEYWORD' | 'RECIPE'} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: 'FOOD' | 'KEYWORD' | 'RECIPE', updatedAt?: string, options?: any): AxiosPromise<PaginatedCustomFilterList> {
            return localVarFp.apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilter} [patchedCustomFilter] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterPartialUpdate(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterPartialUpdate(id, patchedCustomFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterRetrieve(id: number, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilter} customFilter 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterUpdate(id: number, customFilter: CustomFilter, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterUpdate(id, customFilter, options).then((request) => request(axios, basePath));
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDownloadFileRetrieve(fileId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDownloadFileRetrieve(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogCreate(exportLog: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogCreate(exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiExportLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedExportLogList> {
            return localVarFp.apiExportLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLog} [patchedExportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogPartialUpdate(id: number, patchedExportLog?: PatchedExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogPartialUpdate(id, patchedExportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogRetrieve(id: number, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLog} exportLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogUpdate(id: number, exportLog: ExportLog, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogUpdate(id, exportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodCreate(food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodCreate(food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodFdcCreate(id: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodFdcCreate(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldList(options?: any): AxiosPromise<Array<FoodInheritField>> {
            return localVarFp.apiFoodInheritFieldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldRetrieve(id: number, options?: any): AxiosPromise<FoodInheritField> {
            return localVarFp.apiFoodInheritFieldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedFoodList> {
            return localVarFp.apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMergeUpdate(id: number, target: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodMergeUpdate(id, target, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMoveUpdate(id: number, parent: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodMoveUpdate(id, parent, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFood} [patchedFood] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPartialUpdate(id: number, patchedFood?: PatchedFood, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodPartialUpdate(id, patchedFood, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyCreate(property: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyCreate(property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodPropertyDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyList> {
            return localVarFp.apiFoodPropertyList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedProperty} [patchedProperty] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyPartialUpdate(id: number, patchedProperty?: PatchedProperty, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyPartialUpdate(id, patchedProperty, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyRetrieve(id: number, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeCreate(propertyType: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeCreate(propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodPropertyTypeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeList(category?: 'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE', page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyTypeList> {
            return localVarFp.apiFoodPropertyTypeList(category, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyType} [patchedPropertyType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyType?: PatchedPropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypePartialUpdate(id, patchedPropertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeRetrieve(id: number, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyType} propertyType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeUpdate(id: number, propertyType: PropertyType, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeUpdate(id, propertyType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {Property} property 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyUpdate(id: number, property: Property, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyUpdate(id, property, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodRetrieve(id: number, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdate} foodShoppingUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodShoppingUpdate(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any): AxiosPromise<FoodShoppingUpdate> {
            return localVarFp.apiFoodShoppingUpdate(id, foodShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {Food} food 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodUpdate(id: number, food: Food, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodUpdate(id, food, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupList(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.apiGroupList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupRetrieve(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.apiGroupRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogCreate(importLog: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogCreate(importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiImportLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedImportLogList> {
            return localVarFp.apiImportLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLog} [patchedImportLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogPartialUpdate(id: number, patchedImportLog?: PatchedImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogPartialUpdate(id, patchedImportLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogRetrieve(id: number, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLog} importLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogUpdate(id: number, importLog: ImportLog, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogUpdate(id, importLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientCreate(ingredient: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientCreate(ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiIngredientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): AxiosPromise<PaginatedIngredientList> {
            return localVarFp.apiIngredientList(food, page, pageSize, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredient} [patchedIngredient] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientPartialUpdate(id: number, patchedIngredient?: PatchedIngredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientPartialUpdate(id, patchedIngredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientRetrieve(id: number, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {Ingredient} ingredient 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientUpdate(id: number, ingredient: Ingredient, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientUpdate(id, ingredient, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkCreate(inviteLink: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkCreate(inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiInviteLinkDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedInviteLinkList> {
            return localVarFp.apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLink} [patchedInviteLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkPartialUpdate(id: number, patchedInviteLink?: PatchedInviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkPartialUpdate(id, patchedInviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkRetrieve(id: number, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLink} inviteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkUpdate(id: number, inviteLink: InviteLink, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkUpdate(id, inviteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordCreate(keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordCreate(keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeywordDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedKeywordList> {
            return localVarFp.apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMergeUpdate(id: number, target: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordMergeUpdate(id, target, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMoveUpdate(id: number, parent: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordMoveUpdate(id, parent, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeyword} [patchedKeyword] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordPartialUpdate(id: number, patchedKeyword?: PatchedKeyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordPartialUpdate(id, patchedKeyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordRetrieve(id: number, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {Keyword} keyword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordUpdate(id: number, keyword: Keyword, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordUpdate(id, keyword, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanCreate(mealPlan: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanCreate(mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiMealPlanDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanIcalRetrieve(fromDate?: string, mealType?: string, toDate?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanList(fromDate?: string, mealType?: string, page?: number, pageSize?: number, toDate?: string, options?: any): AxiosPromise<PaginatedMealPlanList> {
            return localVarFp.apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlan} [patchedMealPlan] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanPartialUpdate(id: number, patchedMealPlan?: PatchedMealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanPartialUpdate(id, patchedMealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanRetrieve(id: number, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlan} mealPlan 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanUpdate(id: number, mealPlan: MealPlan, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanUpdate(id, mealPlan, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeCreate(mealType: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeCreate(mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiMealTypeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedMealTypeList> {
            return localVarFp.apiMealTypeList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealType} [patchedMealType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypePartialUpdate(id: number, patchedMealType?: PatchedMealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypePartialUpdate(id, patchedMealType, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeRetrieve(id: number, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealType} mealType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeUpdate(id: number, mealType: MealType, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeUpdate(id, mealType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} fromDate 
         * @param {string} toDate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiPlanIcalRetrieve(fromDate: string, toDate: string, options?: any): AxiosPromise<void> {
            return localVarFp.apiPlanIcalRetrieve(fromDate, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookCreate(recipeBook: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookCreate(recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeBookDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryCreate(recipeBookEntry: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryCreate(recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeBookEntryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedRecipeBookEntryList> {
            return localVarFp.apiRecipeBookEntryList(book, page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryRetrieve(id: number, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntry} recipeBookEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryUpdate(id: number, recipeBookEntry: RecipeBookEntry, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryUpdate(id, recipeBookEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedRecipeBookList> {
            return localVarFp.apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBook} [patchedRecipeBook] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookPartialUpdate(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookPartialUpdate(id, patchedRecipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookRetrieve(id: number, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBook} recipeBook 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookUpdate(id: number, recipeBook: RecipeBook, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookUpdate(id, recipeBook, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeCreate(recipe: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeCreate(recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFlatList(options?: any): AxiosPromise<Array<RecipeFlat>> {
            return localVarFp.apiRecipeFlatList(options).then((request) => request(axios, basePath));
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFromSourceCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeFromSourceCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {string} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeImageUpdate(id: number, image?: string, imageUrl?: string, options?: any): AxiosPromise<RecipeImage> {
            return localVarFp.apiRecipeImageUpdate(id, image, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeList(books?: number, booksAnd?: number, booksAndNot?: number, booksOr?: number, booksOrNot?: number, cookedon?: string, createdon?: string, foods?: number, foodsAnd?: number, foodsAndNot?: number, foodsOr?: number, foodsOrNot?: number, internal?: boolean, keywords?: number, keywordsAnd?: number, keywordsAndNot?: number, keywordsOr?: number, keywordsOrNot?: number, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): AxiosPromise<PaginatedRecipeOverviewList> {
            return localVarFp.apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipe} [patchedRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipePartialUpdate(id: number, patchedRecipe?: PatchedRecipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipePartialUpdate(id, patchedRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRelatedRetrieve(id: number, options?: any): AxiosPromise<RecipeSimple> {
            return localVarFp.apiRecipeRelatedRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRetrieve(id: number, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeShoppingUpdate(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any): AxiosPromise<RecipeShoppingUpdate> {
            return localVarFp.apiRecipeShoppingUpdate(id, recipeShoppingUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {Recipe} recipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeUpdate(id: number, recipe: Recipe, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeUpdate(id, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResetFoodInheritanceRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.apiResetFoodInheritanceRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShareLinkRetrieve(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiShareLinkRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryBulkCreate(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any): AxiosPromise<ShoppingListEntryBulk> {
            return localVarFp.apiShoppingListEntryBulkCreate(shoppingListEntryBulk, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryCreate(shoppingListEntry: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryCreate(shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiShoppingListEntryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): AxiosPromise<PaginatedShoppingListEntryList> {
            return localVarFp.apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryRetrieve(id: number, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntry} shoppingListEntry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryUpdate(id: number, shoppingListEntry: ShoppingListEntry, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryUpdate(id, shoppingListEntry, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeCreate(shoppingListRecipe: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeCreate(shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiShoppingListRecipeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedShoppingListRecipeList> {
            return localVarFp.apiShoppingListRecipeList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeRetrieve(id: number, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipe} shoppingListRecipe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeUpdate(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeUpdate(id, shoppingListRecipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpace} [patchedSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpacePartialUpdate(id: number, patchedSpace?: PatchedSpace, options?: any): AxiosPromise<Space> {
            return localVarFp.apiSpacePartialUpdate(id, patchedSpace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceRetrieve(id: number, options?: any): AxiosPromise<Space> {
            return localVarFp.apiSpaceRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepCreate(step: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepCreate(step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiStepDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepList(page?: number, pageSize?: number, query?: string, recipe?: number, options?: any): AxiosPromise<PaginatedStepList> {
            return localVarFp.apiStepList(page, pageSize, query, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStep} [patchedStep] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepPartialUpdate(id: number, patchedStep?: PatchedStep, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepPartialUpdate(id, patchedStep, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepRetrieve(id: number, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {Step} step 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepUpdate(id: number, step: Step, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepUpdate(id, step, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageCreate(storage: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageCreate(storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiStorageDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageList(options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.apiStorageList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorage} [patchedStorage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStoragePartialUpdate(id: number, patchedStorage?: PatchedStorage, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStoragePartialUpdate(id, patchedStorage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageRetrieve(id: number, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {Storage} storage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageUpdate(id: number, storage: Storage, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageUpdate(id, storage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryCreate(supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryCreate(supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketCategoryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryList> {
            return localVarFp.apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryMergeUpdate(id, target, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationCreate(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationCreate(supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketCategoryRelationDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryRelationList> {
            return localVarFp.apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationRetrieve(id: number, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRetrieve(id: number, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategory} supermarketCategory 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryUpdate(id: number, supermarketCategory: SupermarketCategory, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryUpdate(id, supermarketCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCreate(supermarket: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketCreate(supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketList> {
            return localVarFp.apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarket} [patchedSupermarket] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketPartialUpdate(id: number, patchedSupermarket?: PatchedSupermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketPartialUpdate(id, patchedSupermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketRetrieve(id: number, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {Supermarket} supermarket 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketUpdate(id: number, supermarket: Supermarket, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketUpdate(id, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSwitchActiveSpaceRetrieve(spaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncCreate(sync: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncCreate(sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSyncDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncList> {
            return localVarFp.apiSyncList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncLogList> {
            return localVarFp.apiSyncLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogRetrieve(id: number, options?: any): AxiosPromise<SyncLog> {
            return localVarFp.apiSyncLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSync} [patchedSync] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncPartialUpdate(id: number, patchedSync?: PatchedSync, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncPartialUpdate(id, patchedSync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncRetrieve(id: number, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {Sync} sync 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncUpdate(id: number, sync: Sync, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncUpdate(id, sync, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionCreate(unitConversion: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionCreate(unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUnitConversionDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUnitConversionList> {
            return localVarFp.apiUnitConversionList(foodId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversion} [patchedUnitConversion] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionPartialUpdate(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionPartialUpdate(id, patchedUnitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionRetrieve(id: number, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversion} unitConversion 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionUpdate(id: number, unitConversion: UnitConversion, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionUpdate(id, unitConversion, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitCreate(unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitCreate(unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUnitDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUnitList> {
            return localVarFp.apiUnitList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitMergeUpdate(id: number, target: number, unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitMergeUpdate(id, target, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnit} [patchedUnit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitPartialUpdate(id: number, patchedUnit?: PatchedUnit, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitPartialUpdate(id, patchedUnit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitRetrieve(id: number, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {Unit} unit 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitUpdate(id: number, unit: Unit, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitUpdate(id, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileCreate(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileCreate(id, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUserFileDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUserFileList> {
            return localVarFp.apiUserFileList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} [id2] 
         * @param {string} [name] 
         * @param {string} [file] 
         * @param {string} [fileDownload] 
         * @param {string} [preview] 
         * @param {number} [fileSizeKb] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFilePartialUpdate(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFilePartialUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileRetrieve(id: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {number} id2 
         * @param {string} name 
         * @param {string} file 
         * @param {string} fileDownload 
         * @param {string} preview 
         * @param {number} fileSizeKb 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileUpdate(id: number, id2: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserList(filterList?: string, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.apiUserList(filterList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUser} [patchedUser] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any): AxiosPromise<User> {
            return localVarFp.apiUserPartialUpdate(id, patchedUser, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreference} [patchedUserPreference] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencePartialUpdate(user: number, patchedUserPreference?: PatchedUserPreference, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.apiUserPreferencePartialUpdate(user, patchedUserPreference, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceRetrieve(user: number, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.apiUserPreferenceRetrieve(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.apiUserRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUserSpaceDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUserSpaceList> {
            return localVarFp.apiUserSpaceList(internalNote, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpace} [patchedUserSpace] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpacePartialUpdate(id: number, patchedUserSpace?: PatchedUserSpace, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.apiUserSpacePartialUpdate(id, patchedUserSpace, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceRetrieve(id: number, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.apiUserSpaceRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogCreate(viewLog: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogCreate(viewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiViewLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedViewLogList> {
            return localVarFp.apiViewLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLog} [patchedViewLog] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogPartialUpdate(id: number, patchedViewLog?: PatchedViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogPartialUpdate(id, patchedViewLog, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogRetrieve(id: number, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLog} viewLog 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogUpdate(id: number, viewLog: ViewLog, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogUpdate(id, viewLog, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * 
     * @param {AccessToken} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenCreate(accessToken: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenCreate(accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenList(options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {PatchedAccessToken} [patchedAccessToken] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenPartialUpdate(id: number, patchedAccessToken?: PatchedAccessToken, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenPartialUpdate(id, patchedAccessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {AccessToken} accessToken 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenUpdate(id: number, accessToken: AccessToken, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenUpdate(id, accessToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutoMealPlan} autoMealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutoPlanCreate(autoMealPlan: AutoMealPlan, options?: any) {
        return ApiApiFp(this.configuration).apiAutoPlanCreate(autoMealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Automation} automation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationCreate(automation: Automation, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationCreate(automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'} [type] Return the Automations matching the automation type.  Repeat for multiple.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationList(page?: number, pageSize?: number, type?: 'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE', options?: any) {
        return ApiApiFp(this.configuration).apiAutomationList(page, pageSize, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {PatchedAutomation} [patchedAutomation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationPartialUpdate(id: number, patchedAutomation?: PatchedAutomation, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationPartialUpdate(id, patchedAutomation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {Automation} automation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationUpdate(id: number, automation: Automation, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationUpdate(id, automation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookmarkletImport} bookmarkletImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportCreate(bookmarkletImport: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportCreate(bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {PatchedBookmarkletImport} [patchedBookmarkletImport] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImport?: PatchedBookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImport} bookmarkletImport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportUpdate(id: number, bookmarkletImport: BookmarkletImport, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportUpdate(id, bookmarkletImport, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorConfigConfig} connectorConfigConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigCreate(connectorConfigConfig: ConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigCreate(connectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigList(options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {PatchedConnectorConfigConfig} [patchedConnectorConfigConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfig?: PatchedConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {ConnectorConfigConfig} connectorConfigConfig 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigUpdate(id: number, connectorConfigConfig: ConnectorConfigConfig, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigUpdate(id, connectorConfigConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CookLog} cookLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogCreate(cookLog: CookLog, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogCreate(cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] Filter for entries with the given recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogList(page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {PatchedCookLog} [patchedCookLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogPartialUpdate(id: number, patchedCookLog?: PatchedCookLog, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogPartialUpdate(id, patchedCookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {CookLog} cookLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogUpdate(id: number, cookLog: CookLog, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogUpdate(id, cookLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomFilter} customFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterCreate(customFilter: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterCreate(customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {'FOOD' | 'KEYWORD' | 'RECIPE'} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: 'FOOD' | 'KEYWORD' | 'RECIPE', updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {PatchedCustomFilter} [patchedCustomFilter] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterPartialUpdate(id: number, patchedCustomFilter?: PatchedCustomFilter, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterPartialUpdate(id, patchedCustomFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {CustomFilter} customFilter 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterUpdate(id: number, customFilter: CustomFilter, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterUpdate(id, customFilter, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     * @param {number} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiDownloadFileRetrieve(fileId: number, options?: any) {
        return ApiApiFp(this.configuration).apiDownloadFileRetrieve(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportLog} exportLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogCreate(exportLog: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogCreate(exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {PatchedExportLog} [patchedExportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogPartialUpdate(id: number, patchedExportLog?: PatchedExportLog, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogPartialUpdate(id, patchedExportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {ExportLog} exportLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogUpdate(id: number, exportLog: ExportLog, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogUpdate(id, exportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodCreate(food: Food, options?: any) {
        return ApiApiFp(this.configuration).apiFoodCreate(food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     * @param {number} id A unique integer value identifying this food.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodFdcCreate(id: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).apiFoodFdcCreate(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodInheritFieldList(options?: any) {
        return ApiApiFp(this.configuration).apiFoodInheritFieldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food inherit field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodInheritFieldRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodInheritFieldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodMergeUpdate(id: number, target: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).apiFoodMergeUpdate(id, target, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodMoveUpdate(id: number, parent: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).apiFoodMoveUpdate(id, parent, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {PatchedFood} [patchedFood] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPartialUpdate(id: number, patchedFood?: PatchedFood, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPartialUpdate(id, patchedFood, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyCreate(property: Property, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyCreate(property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PatchedProperty} [patchedProperty] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyPartialUpdate(id: number, patchedProperty?: PatchedProperty, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyPartialUpdate(id, patchedProperty, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyType} propertyType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeCreate(propertyType: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeCreate(propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeList(category?: 'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE', page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeList(category, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PatchedPropertyType} [patchedPropertyType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyType?: PatchedPropertyType, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypePartialUpdate(id, patchedPropertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PropertyType} propertyType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeUpdate(id: number, propertyType: PropertyType, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeUpdate(id, propertyType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {Property} property 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyUpdate(id: number, property: Property, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyUpdate(id, property, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodShoppingUpdate} foodShoppingUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodShoppingUpdate(id: number, foodShoppingUpdate: FoodShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).apiFoodShoppingUpdate(id, foodShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {Food} food 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodUpdate(id: number, food: Food, options?: any) {
        return ApiApiFp(this.configuration).apiFoodUpdate(id, food, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGroupList(options?: any) {
        return ApiApiFp(this.configuration).apiGroupList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGroupRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiGroupRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to handle files passed by application importer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportCreate(options?: any) {
        return ApiApiFp(this.configuration).apiImportCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportLog} importLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogCreate(importLog: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogCreate(importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {PatchedImportLog} [patchedImportLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogPartialUpdate(id: number, patchedImportLog?: PatchedImportLog, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogPartialUpdate(id, patchedImportLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {ImportLog} importLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogUpdate(id: number, importLog: ImportLog, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogUpdate(id, importLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Ingredient} ingredient 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientCreate(ingredient: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientCreate(ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [food] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [unit] ID of unit to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientList(food, page, pageSize, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {PatchedIngredient} [patchedIngredient] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientPartialUpdate(id: number, patchedIngredient?: PatchedIngredient, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientPartialUpdate(id, patchedIngredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {Ingredient} ingredient 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientUpdate(id: number, ingredient: Ingredient, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientUpdate(id, ingredient, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteLink} inviteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkCreate(inviteLink: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkCreate(inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what internal_note is for.
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {PatchedInviteLink} [patchedInviteLink] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkPartialUpdate(id: number, patchedInviteLink?: PatchedInviteLink, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkPartialUpdate(id, patchedInviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {InviteLink} inviteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkUpdate(id: number, inviteLink: InviteLink, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkUpdate(id, inviteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordCreate(keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordCreate(keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordMergeUpdate(id: number, target: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordMergeUpdate(id, target, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordMoveUpdate(id: number, parent: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordMoveUpdate(id, parent, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {PatchedKeyword} [patchedKeyword] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordPartialUpdate(id: number, patchedKeyword?: PatchedKeyword, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordPartialUpdate(id, patchedKeyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {Keyword} keyword 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordUpdate(id: number, keyword: Keyword, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordUpdate(id, keyword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MealPlan} mealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanCreate(mealPlan: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanCreate(mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanIcalRetrieve(fromDate?: string, mealType?: string, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {string} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanList(fromDate?: string, mealType?: string, page?: number, pageSize?: number, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {PatchedMealPlan} [patchedMealPlan] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanPartialUpdate(id: number, patchedMealPlan?: PatchedMealPlan, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanPartialUpdate(id, patchedMealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {MealPlan} mealPlan 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanUpdate(id: number, mealPlan: MealPlan, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanUpdate(id, mealPlan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {MealType} mealType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeCreate(mealType: MealType, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeCreate(mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {PatchedMealType} [patchedMealType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypePartialUpdate(id: number, patchedMealType?: PatchedMealType, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypePartialUpdate(id, patchedMealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {MealType} mealType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeUpdate(id: number, mealType: MealType, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeUpdate(id, mealType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} fromDate 
     * @param {string} toDate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiPlanIcalRetrieve(fromDate: string, toDate: string, options?: any) {
        return ApiApiFp(this.configuration).apiPlanIcalRetrieve(fromDate, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBook} recipeBook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookCreate(recipeBook: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookCreate(recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookEntry} recipeBookEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryCreate(recipeBookEntry: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryCreate(recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [book] id of book - only return recipes in that book
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] id of recipe - only return books for that recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryList(book, page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {PatchedRecipeBookEntry} [patchedRecipeBookEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntry?: PatchedRecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntry} recipeBookEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryUpdate(id: number, recipeBookEntry: RecipeBookEntry, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryUpdate(id, recipeBookEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
     * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {PatchedRecipeBook} [patchedRecipeBook] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookPartialUpdate(id: number, patchedRecipeBook?: PatchedRecipeBook, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookPartialUpdate(id, patchedRecipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {RecipeBook} recipeBook 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookUpdate(id: number, recipeBook: RecipeBook, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookUpdate(id, recipeBook, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Recipe} recipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeCreate(recipe: Recipe, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeCreate(recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeFlatList(options?: any) {
        return ApiApiFp(this.configuration).apiRecipeFlatList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeFromSourceCreate(options?: any) {
        return ApiApiFp(this.configuration).apiRecipeFromSourceCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {string} [image] 
     * @param {string} [imageUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeImageUpdate(id: number, image?: string, imageUrl?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeImageUpdate(id, image, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [books] ID of book a recipe should be in. For multiple repeat parameter.
     * @param {number} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
     * @param {number} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
     * @param {number} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
     * @param {number} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
     * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {number} [foods] ID of food a recipe should have. For multiple repeat parameter.
     * @param {number} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
     * @param {number} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
     * @param {number} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
     * @param {number} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
     * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
     * @param {number} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
     * @param {number} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
     * @param {number} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
     * @param {number} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
     * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
     * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
     * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
     * @param {number} [units] ID of unit a recipe should have.
     * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeList(books?: number, booksAnd?: number, booksAndNot?: number, booksOr?: number, booksOrNot?: number, cookedon?: string, createdon?: string, foods?: number, foodsAnd?: number, foodsAndNot?: number, foodsOr?: number, foodsOrNot?: number, internal?: boolean, keywords?: number, keywordsAnd?: number, keywordsAndNot?: number, keywordsOr?: number, keywordsOrNot?: number, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {PatchedRecipe} [patchedRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipePartialUpdate(id: number, patchedRecipe?: PatchedRecipe, options?: any) {
        return ApiApiFp(this.configuration).apiRecipePartialUpdate(id, patchedRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeRelatedRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeRelatedRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeShoppingUpdate} [recipeShoppingUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeShoppingUpdate(id: number, recipeShoppingUpdate?: RecipeShoppingUpdate, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeShoppingUpdate(id, recipeShoppingUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {Recipe} recipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeUpdate(id: number, recipe: Recipe, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeUpdate(id, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to reset inheritance from api, see food method for docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiResetFoodInheritanceRetrieve(options?: any) {
        return ApiApiFp(this.configuration).apiResetFoodInheritanceRetrieve(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShareLinkRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShareLinkRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntryBulk} shoppingListEntryBulk 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryBulkCreate(shoppingListEntryBulk: ShoppingListEntryBulk, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryBulkCreate(shoppingListEntryBulk, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntry} shoppingListEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryCreate(shoppingListEntry: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryCreate(shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
     * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {PatchedShoppingListEntry} [patchedShoppingListEntry] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntry?: PatchedShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntry} shoppingListEntry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryUpdate(id: number, shoppingListEntry: ShoppingListEntry, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryUpdate(id, shoppingListEntry, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListRecipe} shoppingListRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeCreate(shoppingListRecipe: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeCreate(shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {PatchedShoppingListRecipe} [patchedShoppingListRecipe] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipe?: PatchedShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipe} shoppingListRecipe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeUpdate(id: number, shoppingListRecipe: ShoppingListRecipe, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeUpdate(id, shoppingListRecipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {PatchedSpace} [patchedSpace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSpacePartialUpdate(id: number, patchedSpace?: PatchedSpace, options?: any) {
        return ApiApiFp(this.configuration).apiSpacePartialUpdate(id, patchedSpace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSpaceRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSpaceRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Step} step 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepCreate(step: Step, options?: any) {
        return ApiApiFp(this.configuration).apiStepCreate(step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStepDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against object name.
     * @param {number} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepList(page?: number, pageSize?: number, query?: string, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).apiStepList(page, pageSize, query, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {PatchedStep} [patchedStep] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepPartialUpdate(id: number, patchedStep?: PatchedStep, options?: any) {
        return ApiApiFp(this.configuration).apiStepPartialUpdate(id, patchedStep, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStepRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {Step} step 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepUpdate(id: number, step: Step, options?: any) {
        return ApiApiFp(this.configuration).apiStepUpdate(id, step, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Storage} storage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageCreate(storage: Storage, options?: any) {
        return ApiApiFp(this.configuration).apiStorageCreate(storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStorageDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageList(options?: any) {
        return ApiApiFp(this.configuration).apiStorageList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {PatchedStorage} [patchedStorage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStoragePartialUpdate(id: number, patchedStorage?: PatchedStorage, options?: any) {
        return ApiApiFp(this.configuration).apiStoragePartialUpdate(id, patchedStorage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStorageRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {Storage} storage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageUpdate(id: number, storage: Storage, options?: any) {
        return ApiApiFp(this.configuration).apiStorageUpdate(id, storage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryCreate(supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryCreate(supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryMergeUpdate(id, target, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {PatchedSupermarketCategory} [patchedSupermarketCategory] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategory?: PatchedSupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationCreate(supermarketCategoryRelation: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationCreate(supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {PatchedSupermarketCategoryRelation} [patchedSupermarketCategoryRelation] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelation?: PatchedSupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelation} supermarketCategoryRelation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelation: SupermarketCategoryRelation, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategory} supermarketCategory 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryUpdate(id: number, supermarketCategory: SupermarketCategory, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryUpdate(id, supermarketCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Supermarket} supermarket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCreate(supermarket: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCreate(supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {PatchedSupermarket} [patchedSupermarket] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketPartialUpdate(id: number, patchedSupermarket?: PatchedSupermarket, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketPartialUpdate(id, patchedSupermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {Supermarket} supermarket 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketUpdate(id: number, supermarket: Supermarket, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketUpdate(id, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api endpoint to switch space function
     * @param {number} spaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any) {
        return ApiApiFp(this.configuration).apiSwitchActiveSpaceRetrieve(spaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Sync} sync 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncCreate(sync: Sync, options?: any) {
        return ApiApiFp(this.configuration).apiSyncCreate(sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {PatchedSync} [patchedSync] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncPartialUpdate(id: number, patchedSync?: PatchedSync, options?: any) {
        return ApiApiFp(this.configuration).apiSyncPartialUpdate(id, patchedSync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {Sync} sync 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncUpdate(id: number, sync: Sync, options?: any) {
        return ApiApiFp(this.configuration).apiSyncUpdate(id, sync, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitConversion} unitConversion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionCreate(unitConversion: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionCreate(unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [foodId] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionList(foodId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {PatchedUnitConversion} [patchedUnitConversion] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionPartialUpdate(id: number, patchedUnitConversion?: PatchedUnitConversion, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionPartialUpdate(id, patchedUnitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {UnitConversion} unitConversion 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionUpdate(id: number, unitConversion: UnitConversion, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionUpdate(id, unitConversion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitCreate(unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).apiUnitCreate(unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiUnitList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitMergeUpdate(id: number, target: number, unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).apiUnitMergeUpdate(id, target, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {PatchedUnit} [patchedUnit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitPartialUpdate(id: number, patchedUnit?: PatchedUnit, options?: any) {
        return ApiApiFp(this.configuration).apiUnitPartialUpdate(id, patchedUnit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {Unit} unit 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitUpdate(id: number, unit: Unit, options?: any) {
        return ApiApiFp(this.configuration).apiUnitUpdate(id, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {string} name 
     * @param {string} file 
     * @param {string} fileDownload 
     * @param {string} preview 
     * @param {number} fileSizeKb 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileCreate(id: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileCreate(id, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {number} [id2] 
     * @param {string} [name] 
     * @param {string} [file] 
     * @param {string} [fileDownload] 
     * @param {string} [preview] 
     * @param {number} [fileSizeKb] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFilePartialUpdate(id: number, id2?: number, name?: string, file?: string, fileDownload?: string, preview?: string, fileSizeKb?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFilePartialUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {number} id2 
     * @param {string} name 
     * @param {string} file 
     * @param {string} fileDownload 
     * @param {string} preview 
     * @param {number} fileSizeKb 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileUpdate(id: number, id2: number, name: string, file: string, fileDownload: string, preview: string, fileSizeKb: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileUpdate(id, id2, name, file, fileDownload, preview, fileSizeKb, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [filterList] User IDs, repeat for multiple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserList(filterList?: string, options?: any) {
        return ApiApiFp(this.configuration).apiUserList(filterList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUser} [patchedUser] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPartialUpdate(id: number, patchedUser?: PatchedUser, options?: any) {
        return ApiApiFp(this.configuration).apiUserPartialUpdate(id, patchedUser, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {PatchedUserPreference} [patchedUserPreference] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPreferencePartialUpdate(user: number, patchedUserPreference?: PatchedUserPreference, options?: any) {
        return ApiApiFp(this.configuration).apiUserPreferencePartialUpdate(user, patchedUserPreference, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPreferenceRetrieve(user: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserPreferenceRetrieve(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what this is
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceList(internalNote, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {PatchedUserSpace} [patchedUserSpace] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpacePartialUpdate(id: number, patchedUserSpace?: PatchedUserSpace, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpacePartialUpdate(id, patchedUserSpace, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewLog} viewLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogCreate(viewLog: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogCreate(viewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {PatchedViewLog} [patchedViewLog] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogPartialUpdate(id: number, patchedViewLog?: PatchedViewLog, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogPartialUpdate(id, patchedViewLog, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {ViewLog} viewLog 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogUpdate(id: number, viewLog: ViewLog, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogUpdate(id, viewLog, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiImportOpenDataApi - axios parameter creator
 * @export
 */
export const ApiImportOpenDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiImportOpenDataApi - functional programming interface
 * @export
 */
export const ApiImportOpenDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiImportOpenDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportOpenDataCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportOpenDataCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportOpenDataRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportOpenDataRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiImportOpenDataApi - factory interface
 * @export
 */
export const ApiImportOpenDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiImportOpenDataApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportOpenDataCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportOpenDataRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiImportOpenDataApi - object-oriented interface
 * @export
 * @class ApiImportOpenDataApi
 * @extends {BaseAPI}
 */
export class ApiImportOpenDataApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public apiImportOpenDataCreate(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).apiImportOpenDataCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public apiImportOpenDataRetrieve(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).apiImportOpenDataRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiTokenAuthApi - axios parameter creator
 * @export
 */
export const ApiTokenAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenAuthCreate: async (username: string, password: string, token: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiTokenAuthCreate', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiTokenAuthCreate', 'password', password)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('apiTokenAuthCreate', 'token', token)
            const localVarPath = `/api-token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
            if (token !== undefined) { 
                localVarFormParams.append('token', token as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenAuthApi - functional programming interface
 * @export
 */
export const ApiTokenAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenAuthCreate(username: string, password: string, token: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenAuthCreate(username, password, token, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiTokenAuthApi - factory interface
 * @export
 */
export const ApiTokenAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenAuthCreate(username: string, password: string, token: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.apiTokenAuthCreate(username, password, token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenAuthApi - object-oriented interface
 * @export
 * @class ApiTokenAuthApi
 * @extends {BaseAPI}
 */
export class ApiTokenAuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenAuthApi
     */
    public apiTokenAuthCreate(username: string, password: string, token: string, options?: any) {
        return ApiTokenAuthApiFp(this.configuration).apiTokenAuthCreate(username, password, token, options).then((request) => request(this.axios, this.basePath));
    }
}


