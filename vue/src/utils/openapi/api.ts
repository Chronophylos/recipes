/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    created: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    updated: string;
}
/**
 * 
 * @export
 * @interface AccessTokenRequest
 */
export interface AccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenRequest
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenRequest
     */
    scope?: string;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface AutoMealPlan
 */
export interface AutoMealPlan {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlan
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    servings: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof AutoMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlan
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface AutoMealPlanRequest
 */
export interface AutoMealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlanRequest
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlanRequest
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlanRequest
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlanRequest
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlanRequest
     */
    servings: number;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof AutoMealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlanRequest
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    id: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof Automation
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Automation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface AutomationRequest
 */
export interface AutomationRequest {
    /**
     * 
     * @type {TypeEnum}
     * @memberof AutomationRequest
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AutomationRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutomationRequest
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AutomationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface BookmarkletImport
 */
export interface BookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportList
 */
export interface BookmarkletImportList {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportRequest
 */
export interface BookmarkletImportRequest {
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportRequest
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfig
 */
export interface ConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfigRequest
 */
export interface ConnectorConfigConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfigRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface CookLog
 */
export interface CookLog {
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof CookLog
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface CookLogRequest
 */
export interface CookLogRequest {
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLogRequest
     */
    comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CookLogRequest
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilter
 */
export interface CustomFilter {
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    search: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof CustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    created_by: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilterRequest
 */
export interface CustomFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomFilterRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilterRequest
     */
    search: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof CustomFilterRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilterRequest
     */
    id?: number;
}
/**
 * * `SEARCH` - Search * `PLAN` - Meal-Plan * `BOOKS` - Books * `SHOPPING` - Shopping
 * @export
 * @enum {string}
 */
export enum DefaultPageEnum {
    Search = 'SEARCH',
    Plan = 'PLAN',
    Books = 'BOOKS',
    Shopping = 'SHOPPING'
}

/**
 * * `true` - true
 * @export
 * @enum {string}
 */
export enum DeleteEnum {
    True = 'true'
}

/**
 * 
 * @export
 * @interface ExportLog
 */
export interface ExportLog {
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ExportLogRequest
 */
export interface ExportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof ExportLogRequest
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLogRequest
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Food
 */
export interface Food {
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    shopping: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof Food
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Food
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof Food
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof Food
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    numchild: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Food
     */
    full_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof Food
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_onhand: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritField
 */
export interface FoodInheritField {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritField
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    field?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritFieldRequest
 */
export interface FoodInheritFieldRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFieldRequest
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFieldRequest
     */
    field?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodInheritFieldRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodRequest
 */
export interface FoodRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    description?: string;
    /**
     * 
     * @type {RecipeSimpleRequest}
     * @memberof FoodRequest
     */
    recipe?: RecipeSimpleRequest | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    url?: string | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof FoodRequest
     */
    properties?: Array<PropertyRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof FoodRequest
     */
    properties_food_unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof FoodRequest
     */
    supermarket_category?: SupermarketCategoryRequest | null;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof FoodRequest
     */
    inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimpleRequest>}
     * @memberof FoodRequest
     */
    substitute?: Array<FoodSimpleRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof FoodRequest
     */
    child_inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdate
 */
export interface FoodShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    id: number;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdateRequest
 */
export interface FoodShoppingUpdateRequest {
    /**
     * Amount of food to add to the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    amount?: number | null;
    /**
     * ID of unit to use for the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    unit?: number | null;
    /**
     * When set to true will delete all food from active shopping lists.  * `true` - true
     * @type {DeleteEnum}
     * @memberof FoodShoppingUpdateRequest
     */
    _delete: DeleteEnum | null;
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface FoodSimple
 */
export interface FoodSimple {
    /**
     * 
     * @type {number}
     * @memberof FoodSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    plural_name?: string | null;
}
/**
 * 
 * @export
 * @interface FoodSimpleRequest
 */
export interface FoodSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodSimpleRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimpleRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodSimpleRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface GroupRequest
 */
export interface GroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof GroupRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ImportLog
 */
export interface ImportLog {
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof ImportLog
     */
    keyword: Keyword;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ImportLogRequest
 */
export interface ImportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportLogRequest
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    id: number;
    /**
     * 
     * @type {Food}
     * @memberof Ingredient
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof Ingredient
     */
    unit: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    amount: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    conversions: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    used_in_recipes: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_food?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface IngredientRequest
 */
export interface IngredientRequest {
    /**
     * 
     * @type {FoodRequest}
     * @memberof IngredientRequest
     */
    food: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof IngredientRequest
     */
    unit: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof IngredientRequest
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IngredientRequest
     */
    original_text?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    always_use_plural_food?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface IngredientStringRequest
 */
export interface IngredientStringRequest {
    /**
     * 
     * @type {string}
     * @memberof IngredientStringRequest
     */
    text: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof InviteLink
     */
    group: Group;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLinkRequest
 */
export interface InviteLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    email?: string;
    /**
     * 
     * @type {GroupRequest}
     * @memberof InviteLinkRequest
     */
    group: GroupRequest;
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLinkRequest
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLinkRequest
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLinkRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    numchild: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    updated_at: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Keyword
     */
    full_name: string;
}
/**
 * 
 * @export
 * @interface KeywordLabel
 */
export interface KeywordLabel {
    /**
     * 
     * @type {number}
     * @memberof KeywordLabel
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof KeywordLabel
     */
    label: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface KeywordRequest
 */
export interface KeywordRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRequest
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof KeywordRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlan
 */
export interface MealPlan {
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof MealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note_markdown: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof MealPlan
     */
    meal_type: MealType;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    created_by: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof MealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    meal_type_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlan
     */
    shopping: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlanRequest
 */
export interface MealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverviewRequest}
     * @memberof MealPlanRequest
     */
    recipe?: RecipeOverviewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRequest
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    to_date?: string;
    /**
     * 
     * @type {MealTypeRequest}
     * @memberof MealPlanRequest
     */
    meal_type: MealTypeRequest;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof MealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealType
 */
export interface MealType {
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    created_by: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealTypeRequest
 */
export interface MealTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof MealTypeRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealTypeRequest
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealTypeRequest
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealTypeRequest
     */
    id?: number;
}
/**
 * * `DB` - Dropbox * `NEXTCLOUD` - Nextcloud * `LOCAL` - Local
 * @export
 * @enum {string}
 */
export enum MethodEnum {
    Db = 'DB',
    Nextcloud = 'NEXTCLOUD',
    Local = 'LOCAL'
}

/**
 * 
 * @export
 * @interface NutritionInformation
 */
export interface NutritionInformation {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformation
     */
    source?: string | null;
}
/**
 * 
 * @export
 * @interface NutritionInformationRequest
 */
export interface NutritionInformationRequest {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformationRequest
     */
    source?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PaginatedAutomationList
 */
export interface PaginatedAutomationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAutomationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Automation>}
     * @memberof PaginatedAutomationList
     */
    results?: Array<Automation>;
}
/**
 * 
 * @export
 * @interface PaginatedBookmarkletImportListList
 */
export interface PaginatedBookmarkletImportListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBookmarkletImportListList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<BookmarkletImportList>}
     * @memberof PaginatedBookmarkletImportListList
     */
    results?: Array<BookmarkletImportList>;
}
/**
 * 
 * @export
 * @interface PaginatedCookLogList
 */
export interface PaginatedCookLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCookLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CookLog>}
     * @memberof PaginatedCookLogList
     */
    results?: Array<CookLog>;
}
/**
 * 
 * @export
 * @interface PaginatedCustomFilterList
 */
export interface PaginatedCustomFilterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCustomFilterList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomFilter>}
     * @memberof PaginatedCustomFilterList
     */
    results?: Array<CustomFilter>;
}
/**
 * 
 * @export
 * @interface PaginatedExportLogList
 */
export interface PaginatedExportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportLog>}
     * @memberof PaginatedExportLogList
     */
    results?: Array<ExportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedFoodList
 */
export interface PaginatedFoodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFoodList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Food>}
     * @memberof PaginatedFoodList
     */
    results?: Array<Food>;
}
/**
 * 
 * @export
 * @interface PaginatedImportLogList
 */
export interface PaginatedImportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportLog>}
     * @memberof PaginatedImportLogList
     */
    results?: Array<ImportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedIngredientList
 */
export interface PaginatedIngredientList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedIngredientList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PaginatedIngredientList
     */
    results?: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface PaginatedInviteLinkList
 */
export interface PaginatedInviteLinkList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInviteLinkList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof PaginatedInviteLinkList
     */
    results?: Array<InviteLink>;
}
/**
 * 
 * @export
 * @interface PaginatedKeywordList
 */
export interface PaginatedKeywordList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedKeywordList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PaginatedKeywordList
     */
    results?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface PaginatedMealPlanList
 */
export interface PaginatedMealPlanList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealPlanList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealPlan>}
     * @memberof PaginatedMealPlanList
     */
    results?: Array<MealPlan>;
}
/**
 * 
 * @export
 * @interface PaginatedMealTypeList
 */
export interface PaginatedMealTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealType>}
     * @memberof PaginatedMealTypeList
     */
    results?: Array<MealType>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyList
 */
export interface PaginatedPropertyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PaginatedPropertyList
     */
    results?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyTypeList
 */
export interface PaginatedPropertyTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PropertyType>}
     * @memberof PaginatedPropertyTypeList
     */
    results?: Array<PropertyType>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookEntryList
 */
export interface PaginatedRecipeBookEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBookEntry>}
     * @memberof PaginatedRecipeBookEntryList
     */
    results?: Array<RecipeBookEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookList
 */
export interface PaginatedRecipeBookList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBook>}
     * @memberof PaginatedRecipeBookList
     */
    results?: Array<RecipeBook>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeOverviewList
 */
export interface PaginatedRecipeOverviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeOverviewList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeOverview>}
     * @memberof PaginatedRecipeOverviewList
     */
    results?: Array<RecipeOverview>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListEntryList
 */
export interface PaginatedShoppingListEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListEntry>}
     * @memberof PaginatedShoppingListEntryList
     */
    results?: Array<ShoppingListEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListRecipeList
 */
export interface PaginatedShoppingListRecipeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListRecipeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListRecipe>}
     * @memberof PaginatedShoppingListRecipeList
     */
    results?: Array<ShoppingListRecipe>;
}
/**
 * 
 * @export
 * @interface PaginatedStepList
 */
export interface PaginatedStepList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStepList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PaginatedStepList
     */
    results?: Array<Step>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryList
 */
export interface PaginatedSupermarketCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategory>}
     * @memberof PaginatedSupermarketCategoryList
     */
    results?: Array<SupermarketCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryRelationList
 */
export interface PaginatedSupermarketCategoryRelationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    results?: Array<SupermarketCategoryRelation>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketList
 */
export interface PaginatedSupermarketList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Supermarket>}
     * @memberof PaginatedSupermarketList
     */
    results?: Array<Supermarket>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncList
 */
export interface PaginatedSyncList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Sync>}
     * @memberof PaginatedSyncList
     */
    results?: Array<Sync>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncLogList
 */
export interface PaginatedSyncLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SyncLog>}
     * @memberof PaginatedSyncLogList
     */
    results?: Array<SyncLog>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitConversionList
 */
export interface PaginatedUnitConversionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitConversionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UnitConversion>}
     * @memberof PaginatedUnitConversionList
     */
    results?: Array<UnitConversion>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitList
 */
export interface PaginatedUnitList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof PaginatedUnitList
     */
    results?: Array<Unit>;
}
/**
 * 
 * @export
 * @interface PaginatedUserFileList
 */
export interface PaginatedUserFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserFile>}
     * @memberof PaginatedUserFileList
     */
    results?: Array<UserFile>;
}
/**
 * 
 * @export
 * @interface PaginatedUserSpaceList
 */
export interface PaginatedUserSpaceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserSpaceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserSpace>}
     * @memberof PaginatedUserSpaceList
     */
    results?: Array<UserSpace>;
}
/**
 * 
 * @export
 * @interface PaginatedViewLogList
 */
export interface PaginatedViewLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedViewLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ViewLog>}
     * @memberof PaginatedViewLogList
     */
    results?: Array<ViewLog>;
}
/**
 * 
 * @export
 * @interface ParsedIngredient
 */
export interface ParsedIngredient {
    /**
     * 
     * @type {number}
     * @memberof ParsedIngredient
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    unit: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    food: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    note: string;
}
/**
 * 
 * @export
 * @interface PatchedAccessTokenRequest
 */
export interface PatchedAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessTokenRequest
     */
    expires?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessTokenRequest
     */
    scope?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAccessTokenRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedAutomationRequest
 */
export interface PatchedAutomationRequest {
    /**
     * 
     * @type {TypeEnum}
     * @memberof PatchedAutomationRequest
     */
    type?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomationRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAutomationRequest
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedBookmarkletImportRequest
 */
export interface PatchedBookmarkletImportRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImportRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImportRequest
     */
    html?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImportRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedConnectorConfigConfigRequest
 */
export interface PatchedConnectorConfigConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedCookLogRequest
 */
export interface PatchedCookLogRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLogRequest
     */
    comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLogRequest
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedCustomFilterRequest
 */
export interface PatchedCustomFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilterRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilterRequest
     */
    search?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedCustomFilterRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilterRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedExportLogRequest
 */
export interface PatchedExportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLogRequest
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLogRequest
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedFoodRequest
 */
export interface PatchedFoodRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    description?: string;
    /**
     * 
     * @type {RecipeSimpleRequest}
     * @memberof PatchedFoodRequest
     */
    recipe?: RecipeSimpleRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    url?: string | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof PatchedFoodRequest
     */
    properties?: Array<PropertyRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedFoodRequest
     */
    properties_food_unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof PatchedFoodRequest
     */
    supermarket_category?: SupermarketCategoryRequest | null;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedFoodRequest
     */
    inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimpleRequest>}
     * @memberof PatchedFoodRequest
     */
    substitute?: Array<FoodSimpleRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedFoodRequest
     */
    child_inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedImportLogRequest
 */
export interface PatchedImportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLogRequest
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedIngredientRequest
 */
export interface PatchedIngredientRequest {
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedIngredientRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedIngredientRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredientRequest
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredientRequest
     */
    original_text?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    always_use_plural_food?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedInviteLinkRequest
 */
export interface PatchedInviteLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    email?: string;
    /**
     * 
     * @type {GroupRequest}
     * @memberof PatchedInviteLinkRequest
     */
    group?: GroupRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLinkRequest
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedInviteLinkRequest
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLinkRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedKeywordRequest
 */
export interface PatchedKeywordRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedKeywordRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeywordRequest
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeywordRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealPlanRequest
 */
export interface PatchedMealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverviewRequest}
     * @memberof PatchedMealPlanRequest
     */
    recipe?: RecipeOverviewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlanRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    to_date?: string;
    /**
     * 
     * @type {MealTypeRequest}
     * @memberof PatchedMealPlanRequest
     */
    meal_type?: MealTypeRequest;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedMealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlanRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealTypeRequest
 */
export interface PatchedMealTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMealTypeRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealTypeRequest
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealTypeRequest
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealTypeRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedPropertyRequest
 */
export interface PatchedPropertyRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyRequest
     */
    property_amount?: number | null;
    /**
     * 
     * @type {PropertyTypeRequest}
     * @memberof PatchedPropertyRequest
     */
    property_type?: PropertyTypeRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedPropertyTypeRequest
 */
export interface PatchedPropertyTypeRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    fdc_id?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedRecipeBookEntryRequest
 */
export interface PatchedRecipeBookEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    book?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeBookRequest
 */
export interface PatchedRecipeBookRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBookRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBookRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedRecipeBookRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {CustomFilterRequest}
     * @memberof PatchedRecipeBookRequest
     */
    filter?: CustomFilterRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeRequest
 */
export interface PatchedRecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {Array<KeywordRequest>}
     * @memberof PatchedRecipeRequest
     */
    keywords?: Array<KeywordRequest>;
    /**
     * 
     * @type {Array<StepRequest>}
     * @memberof PatchedRecipeRequest
     */
    steps?: Array<StepRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformationRequest}
     * @memberof PatchedRecipeRequest
     */
    nutrition?: NutritionInformationRequest | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof PatchedRecipeRequest
     */
    properties?: Array<PropertyRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    servings_text?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedRecipeRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedShoppingListEntryRequest
 */
export interface PatchedShoppingListEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedShoppingListEntryRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedShoppingListEntryRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShoppingListEntryRequest
     */
    checked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntryRequest
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntryRequest
     */
    delay_until?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedShoppingListRecipeRequest
 */
export interface PatchedShoppingListRecipeRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSpaceRequest
 */
export interface PatchedSpaceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    message?: string;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedSpaceRequest
     */
    food_inherit?: Array<FoodInheritFieldRequest>;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    image?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    nav_logo?: UserFileViewRequest | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof PatchedSpaceRequest
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    custom_space_theme?: UserFileViewRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof PatchedSpaceRequest
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_32?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_128?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_144?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_180?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_192?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_512?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_svg?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpaceRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedStepRequest
 */
export interface PatchedStepRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStepRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStepRequest
     */
    instruction?: string;
    /**
     * 
     * @type {Array<IngredientRequest>}
     * @memberof PatchedStepRequest
     */
    ingredients?: Array<IngredientRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStepRequest
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedStepRequest
     */
    file?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStepRequest
     */
    show_ingredients_table?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedStorageRequest
 */
export interface PatchedStorageRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    name?: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof PatchedStorageRequest
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSupermarketCategoryRelationRequest
 */
export interface PatchedSupermarketCategoryRelationRequest {
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    category?: SupermarketCategoryRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    supermarket?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketCategoryRequest
 */
export interface PatchedSupermarketCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategoryRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategoryRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketRequest
 */
export interface PatchedSupermarketRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedSyncRequest
 */
export interface PatchedSyncRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedSyncRequest
     */
    storage?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSyncRequest
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSyncRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSyncRequest
     */
    last_checked?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSyncRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUnitConversionRequest
 */
export interface PatchedUnitConversionRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    base_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedUnitConversionRequest
     */
    base_unit?: UnitRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    converted_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedUnitConversionRequest
     */
    converted_unit?: UnitRequest;
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedUnitConversionRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversionRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedUnitRequest
 */
export interface PatchedUnitRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserPreferenceRequest
 */
export interface PatchedUserPreferenceRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    user?: number;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedUserPreferenceRequest
     */
    image?: UserFileViewRequest | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedUserPreferenceRequest
     */
    plan_share?: Array<UserRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_share?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    show_step_ingredients?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    last_name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserSpaceRequest
 */
export interface PatchedUserSpaceRequest {
    /**
     * 
     * @type {Array<GroupRequest>}
     * @memberof PatchedUserSpaceRequest
     */
    groups?: Array<GroupRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserSpaceRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpaceRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpaceRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedViewLogRequest
 */
export interface PatchedViewLogRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLogRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    property_type: PropertyType;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PropertyRequest
 */
export interface PropertyRequest {
    /**
     * 
     * @type {number}
     * @memberof PropertyRequest
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyTypeRequest}
     * @memberof PropertyRequest
     */
    property_type: PropertyTypeRequest;
    /**
     * 
     * @type {number}
     * @memberof PropertyRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyTypeRequest
 */
export interface PropertyTypeRequest {
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    image: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof Recipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof Recipe
     */
    steps: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof Recipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Recipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof Recipe
     */
    food_properties: any | null;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof Recipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBook
 */
export interface RecipeBook {
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof RecipeBook
     */
    shared: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    created_by: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof RecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RecipeBookEntry
 */
export interface RecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    book: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof RecipeBookEntry
     */
    book_content: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    recipe: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof RecipeBookEntry
     */
    recipe_content: RecipeOverview;
}
/**
 * 
 * @export
 * @interface RecipeBookEntryRequest
 */
export interface RecipeBookEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    book: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBookRequest
 */
export interface RecipeBookRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeBookRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof RecipeBookRequest
     */
    shared: Array<UserRequest>;
    /**
     * 
     * @type {CustomFilterRequest}
     * @memberof RecipeBookRequest
     */
    filter?: CustomFilterRequest | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeFlat
 */
export interface RecipeFlat {
    /**
     * 
     * @type {number}
     * @memberof RecipeFlat
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    image?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeImage
 */
export interface RecipeImage {
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image_url?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverview
 */
export interface RecipeOverview {
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    image: string | null;
    /**
     * 
     * @type {Array<KeywordLabel>}
     * @memberof RecipeOverview
     */
    keywords: Array<KeywordLabel>;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    working_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    waiting_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    updated_at: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    internal: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    servings_text: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    _new: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    recent: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverviewRequest
 */
export interface RecipeOverviewRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeOverviewRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverviewRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverviewRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeRequest
 */
export interface RecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {Array<KeywordRequest>}
     * @memberof RecipeRequest
     */
    keywords?: Array<KeywordRequest>;
    /**
     * 
     * @type {Array<StepRequest>}
     * @memberof RecipeRequest
     */
    steps: Array<StepRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformationRequest}
     * @memberof RecipeRequest
     */
    nutrition?: NutritionInformationRequest | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof RecipeRequest
     */
    properties?: Array<PropertyRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    servings_text?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof RecipeRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdate
 */
export interface RecipeShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    id: number;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdateRequest
 */
export interface RecipeShoppingUpdateRequest {
    /**
     * Existing shopping list to update
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    list_recipe?: number | null;
    /**
     * List of ingredient IDs from the recipe to add, if not provided all ingredients will be added.
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    ingredients?: number | null;
    /**
     * Providing a list_recipe ID and servings of 0 will delete that shopping list.
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimple
 */
export interface RecipeSimple {
    /**
     * 
     * @type {number}
     * @memberof RecipeSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    url: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimpleRequest
 */
export interface RecipeSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeSimpleRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeSimpleRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ShareLink
 */
export interface ShareLink {
    /**
     * 
     * @type {number}
     * @memberof ShareLink
     */
    pk: number;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    share: string;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    link: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntry
 */
export interface ShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof ShoppingListEntry
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof ShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof ShoppingListEntry
     */
    recipe_mealplan: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof ShoppingListEntry
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulk
 */
export interface ShoppingListEntryBulk {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulk
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulk
     */
    checked: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulkRequest
 */
export interface ShoppingListEntryBulkRequest {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulkRequest
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulkRequest
     */
    checked: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntryRequest
 */
export interface ShoppingListEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {FoodRequest}
     * @memberof ShoppingListEntryRequest
     */
    food: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof ShoppingListEntryRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryRequest
     */
    checked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntryRequest
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntryRequest
     */
    delay_until?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipe
 */
export interface ShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_note: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_from_date: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_type: string;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipeRequest
 */
export interface ShoppingListRecipeRequest {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    servings: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    created_by: number | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_recipes: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof Space
     */
    max_file_storage_mb: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_users: number;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    allow_sharing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    demo: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Space
     */
    food_inherit: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    user_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    recipe_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    file_size_mb: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof Space
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof Space
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * * `BLANK` - ------- * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum SpaceNavTextColorEnum {
    Blank = 'BLANK',
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * * `BLANK` - ------- * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum SpaceThemeEnum {
    Blank = 'BLANK',
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof Step
     */
    ingredients: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instructions_markdown: string;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof Step
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof Step
     */
    step_recipe_data: any | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    numrecipe: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_ingredients_table?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface StepRequest
 */
export interface StepRequest {
    /**
     * 
     * @type {string}
     * @memberof StepRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StepRequest
     */
    instruction?: string;
    /**
     * 
     * @type {Array<IngredientRequest>}
     * @memberof StepRequest
     */
    ingredients: Array<IngredientRequest>;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StepRequest
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof StepRequest
     */
    file?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof StepRequest
     */
    show_ingredients_table?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof Storage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    username?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface StorageRequest
 */
export interface StorageRequest {
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof StorageRequest
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StorageRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Supermarket
 */
export interface Supermarket {
    /**
     * 
     * @type {number}
     * @memberof Supermarket
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof Supermarket
     */
    category_to_supermarket: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategory
 */
export interface SupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelation
 */
export interface SupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    id: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof SupermarketCategoryRelation
     */
    category: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    order?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelationRequest
 */
export interface SupermarketCategoryRelationRequest {
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof SupermarketCategoryRelationRequest
     */
    category: SupermarketCategoryRequest;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategoryRequest
 */
export interface SupermarketCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategoryRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategoryRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketRequest
 */
export interface SupermarketRequest {
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SupermarketRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface Sync
 */
export interface Sync {
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface SyncLog
 */
export interface SyncLog {
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    sync: number;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface SyncRequest
 */
export interface SyncRequest {
    /**
     * 
     * @type {number}
     * @memberof SyncRequest
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof SyncRequest
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SyncRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SyncRequest
     */
    last_checked?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SyncRequest
     */
    id?: number;
}
/**
 * * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum ThemeEnum {
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * * `FOOD_ALIAS` - Food Alias * `UNIT_ALIAS` - Unit Alias * `KEYWORD_ALIAS` - Keyword Alias * `DESCRIPTION_REPLACE` - Description Replace * `INSTRUCTION_REPLACE` - Instruction Replace * `NEVER_UNIT` - Never Unit * `TRANSPOSE_WORDS` - Transpose Words * `FOOD_REPLACE` - Food Replace * `UNIT_REPLACE` - Unit Replace * `NAME_REPLACE` - Name Replace
 * @export
 * @enum {string}
 */
export enum TypeEnum {
    FoodAlias = 'FOOD_ALIAS',
    UnitAlias = 'UNIT_ALIAS',
    KeywordAlias = 'KEYWORD_ALIAS',
    DescriptionReplace = 'DESCRIPTION_REPLACE',
    InstructionReplace = 'INSTRUCTION_REPLACE',
    NeverUnit = 'NEVER_UNIT',
    TransposeWords = 'TRANSPOSE_WORDS',
    FoodReplace = 'FOOD_REPLACE',
    UnitReplace = 'UNIT_REPLACE',
    NameReplace = 'NAME_REPLACE'
}

/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversion
 */
export interface UnitConversion {
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    base_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    base_unit: Unit;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    converted_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    converted_unit: Unit;
    /**
     * 
     * @type {Food}
     * @memberof UnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversionRequest
 */
export interface UnitConversionRequest {
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    base_amount: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof UnitConversionRequest
     */
    base_unit: UnitRequest;
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    converted_amount: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof UnitConversionRequest
     */
    converted_unit: UnitRequest;
    /**
     * 
     * @type {FoodRequest}
     * @memberof UnitConversionRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface UnitRequest
 */
export interface UnitRequest {
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UnitRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
}
/**
 * 
 * @export
 * @interface UserFile
 */
export interface UserFile {
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    preview: string;
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    file_size_kb: number;
}
/**
 * 
 * @export
 * @interface UserFileView
 */
export interface UserFileView {
    /**
     * 
     * @type {number}
     * @memberof UserFileView
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    preview: string;
}
/**
 * 
 * @export
 * @interface UserFileViewRequest
 */
export interface UserFileViewRequest {
    /**
     * 
     * @type {string}
     * @memberof UserFileViewRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UserFileViewRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    user: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof UserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof UserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof UserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof UserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof UserPreference
     */
    food_inherit_default: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    food_children_exist: boolean;
}
/**
 * * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum UserPreferenceNavTextColorEnum {
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    last_name?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserSpace
 */
export interface UserSpace {
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    id: number;
    /**
     * 
     * @type {User}
     * @memberof UserSpace
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    space: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof UserSpace
     */
    groups: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    invite_link: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface ViewLog
 */
export interface ViewLog {
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ViewLogRequest
 */
export interface ViewLogRequest {
    /**
     * 
     * @type {number}
     * @memberof ViewLogRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLogRequest
     */
    id?: number;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry: async (shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryBulkRequest' is not null or undefined
            assertParamExists('bulkShoppingListEntry', 'shoppingListEntryBulkRequest', shoppingListEntryBulkRequest)
            const localVarPath = `/api/shopping-list-entry/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken: async (accessTokenRequest: AccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenRequest' is not null or undefined
            assertParamExists('createAccessToken', 'accessTokenRequest', accessTokenRequest)
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoMealPlan: async (autoMealPlanRequest: AutoMealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoMealPlanRequest' is not null or undefined
            assertParamExists('createAutoMealPlan', 'autoMealPlanRequest', autoMealPlanRequest)
            const localVarPath = `/api/auto-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoMealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation: async (automationRequest: AutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'automationRequest' is not null or undefined
            assertParamExists('createAutomation', 'automationRequest', automationRequest)
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport: async (bookmarkletImportRequest: BookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookmarkletImportRequest' is not null or undefined
            assertParamExists('createBookmarkletImport', 'bookmarkletImportRequest', bookmarkletImportRequest)
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorConfig: async (connectorConfigConfigRequest: ConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorConfigConfigRequest' is not null or undefined
            assertParamExists('createConnectorConfig', 'connectorConfigConfigRequest', connectorConfigConfigRequest)
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog: async (cookLogRequest: CookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cookLogRequest' is not null or undefined
            assertParamExists('createCookLog', 'cookLogRequest', cookLogRequest)
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter: async (customFilterRequest: CustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFilterRequest' is not null or undefined
            assertParamExists('createCustomFilter', 'customFilterRequest', customFilterRequest)
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog: async (exportLogRequest: ExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportLogRequest' is not null or undefined
            assertParamExists('createExportLog', 'exportLogRequest', exportLogRequest)
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood: async (foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('createFood', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog: async (importLogRequest: ImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importLogRequest' is not null or undefined
            assertParamExists('createImportLog', 'importLogRequest', importLogRequest)
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient: async (ingredientRequest: IngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientRequest' is not null or undefined
            assertParamExists('createIngredient', 'ingredientRequest', ingredientRequest)
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink: async (inviteLinkRequest: InviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteLinkRequest' is not null or undefined
            assertParamExists('createInviteLink', 'inviteLinkRequest', inviteLinkRequest)
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword: async (keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('createKeyword', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan: async (mealPlanRequest: MealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealPlanRequest' is not null or undefined
            assertParamExists('createMealPlan', 'mealPlanRequest', mealPlanRequest)
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType: async (mealTypeRequest: MealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealTypeRequest' is not null or undefined
            assertParamExists('createMealType', 'mealTypeRequest', mealTypeRequest)
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty: async (propertyRequest: PropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyRequest' is not null or undefined
            assertParamExists('createProperty', 'propertyRequest', propertyRequest)
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType: async (propertyTypeRequest: PropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyTypeRequest' is not null or undefined
            assertParamExists('createPropertyType', 'propertyTypeRequest', propertyTypeRequest)
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe: async (recipeRequest: RecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeRequest' is not null or undefined
            assertParamExists('createRecipe', 'recipeRequest', recipeRequest)
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook: async (recipeBookRequest: RecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookRequest' is not null or undefined
            assertParamExists('createRecipeBook', 'recipeBookRequest', recipeBookRequest)
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry: async (recipeBookEntryRequest: RecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookEntryRequest' is not null or undefined
            assertParamExists('createRecipeBookEntry', 'recipeBookEntryRequest', recipeBookEntryRequest)
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-from-source/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry: async (shoppingListEntryRequest: ShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryRequest' is not null or undefined
            assertParamExists('createShoppingListEntry', 'shoppingListEntryRequest', shoppingListEntryRequest)
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe: async (shoppingListRecipeRequest: ShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListRecipeRequest' is not null or undefined
            assertParamExists('createShoppingListRecipe', 'shoppingListRecipeRequest', shoppingListRecipeRequest)
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep: async (stepRequest: StepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stepRequest' is not null or undefined
            assertParamExists('createStep', 'stepRequest', stepRequest)
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage: async (storageRequest: StorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageRequest' is not null or undefined
            assertParamExists('createStorage', 'storageRequest', storageRequest)
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket: async (supermarketRequest: SupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketRequest' is not null or undefined
            assertParamExists('createSupermarket', 'supermarketRequest', supermarketRequest)
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory: async (supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('createSupermarketCategory', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation: async (supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRelationRequest' is not null or undefined
            assertParamExists('createSupermarketCategoryRelation', 'supermarketCategoryRelationRequest', supermarketCategoryRelationRequest)
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync: async (syncRequest: SyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncRequest' is not null or undefined
            assertParamExists('createSync', 'syncRequest', syncRequest)
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit: async (unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('createUnit', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion: async (unitConversionRequest: UnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitConversionRequest' is not null or undefined
            assertParamExists('createUnitConversion', 'unitConversionRequest', unitConversionRequest)
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile: async (name: string, file: any, id?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('createUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createUserFile', 'file', file)
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog: async (viewLogRequest: ViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewLogRequest' is not null or undefined
            assertParamExists('createViewLog', 'viewLogRequest', viewLogRequest)
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createingredientFromString: async (ingredientStringRequest: IngredientStringRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientStringRequest' is not null or undefined
            assertParamExists('createingredientFromString', 'ingredientStringRequest', ingredientStringRequest)
            const localVarPath = `/api/ingredient-from-string/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientStringRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createresetFoodInheritance: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reset-food-inheritance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyConnectorConfig: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyPropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroySync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('destroyViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood: async (id: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fdcFood', 'id', id)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('fdcFood', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/fdc/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        icalMealPlan: async (fromDate?: string, mealType?: Array<string>, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/ical/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe: async (id: number, image?: any, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations: async (page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorConfigs: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs: async (page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-inherit-field/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients: async (food?: number, page?: number, pageSize?: number, unit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (food !== undefined) {
                localVarQueryParameter['food'] = food;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks: async (internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans: async (fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes: async (category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys: async (book?: number, page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks: async (limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (orderField !== undefined) {
                localVarQueryParameter['order_field'] = orderField;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes: async (books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (books) {
                localVarQueryParameter['books'] = books;
            }

            if (booksAnd) {
                localVarQueryParameter['books_and'] = booksAnd;
            }

            if (booksAndNot) {
                localVarQueryParameter['books_and_not'] = booksAndNot;
            }

            if (booksOr) {
                localVarQueryParameter['books_or'] = booksOr;
            }

            if (booksOrNot) {
                localVarQueryParameter['books_or_not'] = booksOrNot;
            }

            if (cookedon !== undefined) {
                localVarQueryParameter['cookedon'] = cookedon;
            }

            if (createdon !== undefined) {
                localVarQueryParameter['createdon'] = createdon;
            }

            if (foods) {
                localVarQueryParameter['foods'] = foods;
            }

            if (foodsAnd) {
                localVarQueryParameter['foods_and'] = foodsAnd;
            }

            if (foodsAndNot) {
                localVarQueryParameter['foods_and_not'] = foodsAndNot;
            }

            if (foodsOr) {
                localVarQueryParameter['foods_or'] = foodsOr;
            }

            if (foodsOrNot) {
                localVarQueryParameter['foods_or_not'] = foodsOrNot;
            }

            if (internal !== undefined) {
                localVarQueryParameter['internal'] = internal;
            }

            if (keywords) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (keywordsAnd) {
                localVarQueryParameter['keywords_and'] = keywordsAnd;
            }

            if (keywordsAndNot) {
                localVarQueryParameter['keywords_and_not'] = keywordsAndNot;
            }

            if (keywordsOr) {
                localVarQueryParameter['keywords_or'] = keywordsOr;
            }

            if (keywordsOrNot) {
                localVarQueryParameter['keywords_or_not'] = keywordsOrNot;
            }

            if (makenow !== undefined) {
                localVarQueryParameter['makenow'] = makenow;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (timescooked !== undefined) {
                localVarQueryParameter['timescooked'] = timescooked;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (updatedon !== undefined) {
                localVarQueryParameter['updatedon'] = updatedon;
            }

            if (viewedon !== undefined) {
                localVarQueryParameter['viewedon'] = viewedon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes2: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/flat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys: async (checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checked !== undefined) {
                localVarQueryParameter['checked'] = checked;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (supermarket !== undefined) {
                localVarQueryParameter['supermarket'] = supermarket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps: async (page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (recipe) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions: async (foodId?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (foodId !== undefined) {
                localVarQueryParameter['food_id'] = foodId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preference/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces: async (internalNote?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers: async (filterList?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filterList) {
                localVarQueryParameter['filter_list'] = filterList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood: async (id: number, target: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeFood', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeFood', 'target', target)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('mergeFood', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword: async (id: number, target: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeKeyword', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeKeyword', 'target', target)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('mergeKeyword', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory: async (id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'target', target)
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('mergeSupermarketCategory', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit: async (id: number, target: number, unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('mergeUnit', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('mergeUnit', 'target', target)
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('mergeUnit', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood: async (id: number, parent: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveFood', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveFood', 'parent', parent)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('moveFood', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword: async (id: number, parent: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('moveKeyword', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('moveKeyword', 'parent', parent)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('moveKeyword', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken: async (id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation: async (id: number, patchedAutomationRequest?: PatchedAutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAutomationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport: async (id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateConnectorConfig: async (id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConnectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog: async (id: number, patchedCookLogRequest?: PatchedCookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter: async (id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog: async (id: number, patchedExportLogRequest?: PatchedExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood: async (id: number, patchedFoodRequest?: PatchedFoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFoodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog: async (id: number, patchedImportLogRequest?: PatchedImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedImportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient: async (id: number, patchedIngredientRequest?: PatchedIngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIngredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink: async (id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedInviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword: async (id: number, patchedKeywordRequest?: PatchedKeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedKeywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan: async (id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType: async (id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty: async (id: number, patchedPropertyRequest?: PatchedPropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType: async (id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdatePropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe: async (id: number, patchedRecipeRequest?: PatchedRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook: async (id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry: async (id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry: async (id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe: async (id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace: async (id: number, patchedSpaceRequest?: PatchedSpaceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSpaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep: async (id: number, patchedStepRequest?: PatchedStepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage: async (id: number, patchedStorageRequest?: PatchedStorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStorageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket: async (id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory: async (id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation: async (id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync: async (id: number, patchedSyncRequest?: PatchedSyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSyncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit: async (id: number, patchedUnitRequest?: PatchedUnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion: async (id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser: async (id: number, patchedUserRequest?: PatchedUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile: async (id: number, name?: string, file?: any, id2?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference: async (user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('partialUpdateUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserPreferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace: async (id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserSpaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog: async (id: number, patchedViewLogRequest?: PatchedViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('partialUpdateViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('relatedRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/related/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAccessToken', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveAutomation', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveBookmarkletImport', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveConnectorConfig: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveConnectorConfig', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCookLog', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveCustomFilter', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveExportLog', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFood', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveFoodInheritField', 'id', id)
            const localVarPath = `/api/food-inherit-field/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveGroup', 'id', id)
            const localVarPath = `/api/group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveImportLog', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveIngredient', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveInviteLink', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveKeyword', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealPlan', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveMealType', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveProperty', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrievePropertyType', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBook', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveRecipeBookEntry', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListEntry', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveShoppingListRecipe', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSpace', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStep', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveStorage', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarket', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategory', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSupermarketCategoryRelation', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSync', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveSyncLog', 'id', id)
            const localVarPath = `/api/sync-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnit', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUnitConversion', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUser', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserFile', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference: async (user: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('retrieveUserPreference', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveUserSpace', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveViewLog', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile: async (fileId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('retrievedownloadFile', 'fileId', fileId)
            const localVarPath = `/api/download-file/{fileId}/`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetExternalFileLink: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('retrievegetExternalFileLink', 'recipeId', recipeId)
            const localVarPath = `/api/get_external_file_link/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetRecipeFile: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('retrievegetRecipeFile', 'recipeId', recipeId)
            const localVarPath = `/api/get_recipe_file/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('retrieveshareLink', 'id', id)
            const localVarPath = `/api/share-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace: async (spaceId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spaceId' is not null or undefined
            assertParamExists('retrieveswitchActiveSpace', 'spaceId', spaceId)
            const localVarPath = `/api/switch-active-space/{spaceId}/`
                .replace(`{${"spaceId"}}`, encodeURIComponent(String(spaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood: async (id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingFood', 'id', id)
            // verify required parameter 'foodShoppingUpdateRequest' is not null or undefined
            assertParamExists('shoppingFood', 'foodShoppingUpdateRequest', foodShoppingUpdateRequest)
            const localVarPath = `/api/food/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodShoppingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe: async (id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('shoppingRecipe', 'id', id)
            const localVarPath = `/api/recipe/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeShoppingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken: async (id: number, accessTokenRequest: AccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAccessToken', 'id', id)
            // verify required parameter 'accessTokenRequest' is not null or undefined
            assertParamExists('updateAccessToken', 'accessTokenRequest', accessTokenRequest)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation: async (id: number, automationRequest: AutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAutomation', 'id', id)
            // verify required parameter 'automationRequest' is not null or undefined
            assertParamExists('updateAutomation', 'automationRequest', automationRequest)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport: async (id: number, bookmarkletImportRequest: BookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateBookmarkletImport', 'id', id)
            // verify required parameter 'bookmarkletImportRequest' is not null or undefined
            assertParamExists('updateBookmarkletImport', 'bookmarkletImportRequest', bookmarkletImportRequest)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorConfig: async (id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateConnectorConfig', 'id', id)
            // verify required parameter 'connectorConfigConfigRequest' is not null or undefined
            assertParamExists('updateConnectorConfig', 'connectorConfigConfigRequest', connectorConfigConfigRequest)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog: async (id: number, cookLogRequest: CookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCookLog', 'id', id)
            // verify required parameter 'cookLogRequest' is not null or undefined
            assertParamExists('updateCookLog', 'cookLogRequest', cookLogRequest)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter: async (id: number, customFilterRequest: CustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateCustomFilter', 'id', id)
            // verify required parameter 'customFilterRequest' is not null or undefined
            assertParamExists('updateCustomFilter', 'customFilterRequest', customFilterRequest)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog: async (id: number, exportLogRequest: ExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateExportLog', 'id', id)
            // verify required parameter 'exportLogRequest' is not null or undefined
            assertParamExists('updateExportLog', 'exportLogRequest', exportLogRequest)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood: async (id: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFood', 'id', id)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('updateFood', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog: async (id: number, importLogRequest: ImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateImportLog', 'id', id)
            // verify required parameter 'importLogRequest' is not null or undefined
            assertParamExists('updateImportLog', 'importLogRequest', importLogRequest)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient: async (id: number, ingredientRequest: IngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateIngredient', 'id', id)
            // verify required parameter 'ingredientRequest' is not null or undefined
            assertParamExists('updateIngredient', 'ingredientRequest', ingredientRequest)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink: async (id: number, inviteLinkRequest: InviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateInviteLink', 'id', id)
            // verify required parameter 'inviteLinkRequest' is not null or undefined
            assertParamExists('updateInviteLink', 'inviteLinkRequest', inviteLinkRequest)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword: async (id: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateKeyword', 'id', id)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('updateKeyword', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan: async (id: number, mealPlanRequest: MealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealPlan', 'id', id)
            // verify required parameter 'mealPlanRequest' is not null or undefined
            assertParamExists('updateMealPlan', 'mealPlanRequest', mealPlanRequest)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType: async (id: number, mealTypeRequest: MealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateMealType', 'id', id)
            // verify required parameter 'mealTypeRequest' is not null or undefined
            assertParamExists('updateMealType', 'mealTypeRequest', mealTypeRequest)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty: async (id: number, propertyRequest: PropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateProperty', 'id', id)
            // verify required parameter 'propertyRequest' is not null or undefined
            assertParamExists('updateProperty', 'propertyRequest', propertyRequest)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType: async (id: number, propertyTypeRequest: PropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePropertyType', 'id', id)
            // verify required parameter 'propertyTypeRequest' is not null or undefined
            assertParamExists('updatePropertyType', 'propertyTypeRequest', propertyTypeRequest)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe: async (id: number, recipeRequest: RecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipe', 'id', id)
            // verify required parameter 'recipeRequest' is not null or undefined
            assertParamExists('updateRecipe', 'recipeRequest', recipeRequest)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook: async (id: number, recipeBookRequest: RecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBook', 'id', id)
            // verify required parameter 'recipeBookRequest' is not null or undefined
            assertParamExists('updateRecipeBook', 'recipeBookRequest', recipeBookRequest)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry: async (id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateRecipeBookEntry', 'id', id)
            // verify required parameter 'recipeBookEntryRequest' is not null or undefined
            assertParamExists('updateRecipeBookEntry', 'recipeBookEntryRequest', recipeBookEntryRequest)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry: async (id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListEntry', 'id', id)
            // verify required parameter 'shoppingListEntryRequest' is not null or undefined
            assertParamExists('updateShoppingListEntry', 'shoppingListEntryRequest', shoppingListEntryRequest)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe: async (id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateShoppingListRecipe', 'id', id)
            // verify required parameter 'shoppingListRecipeRequest' is not null or undefined
            assertParamExists('updateShoppingListRecipe', 'shoppingListRecipeRequest', shoppingListRecipeRequest)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep: async (id: number, stepRequest: StepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStep', 'id', id)
            // verify required parameter 'stepRequest' is not null or undefined
            assertParamExists('updateStep', 'stepRequest', stepRequest)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage: async (id: number, storageRequest: StorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateStorage', 'id', id)
            // verify required parameter 'storageRequest' is not null or undefined
            assertParamExists('updateStorage', 'storageRequest', storageRequest)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket: async (id: number, supermarketRequest: SupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarket', 'id', id)
            // verify required parameter 'supermarketRequest' is not null or undefined
            assertParamExists('updateSupermarket', 'supermarketRequest', supermarketRequest)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory: async (id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategory', 'id', id)
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('updateSupermarketCategory', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation: async (id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSupermarketCategoryRelation', 'id', id)
            // verify required parameter 'supermarketCategoryRelationRequest' is not null or undefined
            assertParamExists('updateSupermarketCategoryRelation', 'supermarketCategoryRelationRequest', supermarketCategoryRelationRequest)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync: async (id: number, syncRequest: SyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSync', 'id', id)
            // verify required parameter 'syncRequest' is not null or undefined
            assertParamExists('updateSync', 'syncRequest', syncRequest)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit: async (id: number, unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnit', 'id', id)
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('updateUnit', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion: async (id: number, unitConversionRequest: UnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUnitConversion', 'id', id)
            // verify required parameter 'unitConversionRequest' is not null or undefined
            assertParamExists('updateUnitConversion', 'unitConversionRequest', unitConversionRequest)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile: async (id: number, name: string, file: any, id2?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateUserFile', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('updateUserFile', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateUserFile', 'file', file)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog: async (id: number, viewLogRequest: ViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateViewLog', 'id', id)
            // verify required parameter 'viewLogRequest' is not null or undefined
            assertParamExists('updateViewLog', 'viewLogRequest', viewLogRequest)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkShoppingListEntry(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntryBulk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkShoppingListEntry(shoppingListEntryBulkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAccessToken(accessTokenRequest: AccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAccessToken(accessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutoMealPlan(autoMealPlanRequest: AutoMealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoMealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutoMealPlan(autoMealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAutomation(automationRequest: AutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAutomation(automationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBookmarkletImport(bookmarkletImportRequest: BookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBookmarkletImport(bookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConnectorConfig(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConnectorConfig(connectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCookLog(cookLogRequest: CookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCookLog(cookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomFilter(customFilterRequest: CustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomFilter(customFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createExportLog(exportLogRequest: ExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createExportLog(exportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFood(foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFood(foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportLog(importLogRequest: ImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportLog(importLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createIngredient(ingredientRequest: IngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createIngredient(ingredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createInviteLink(inviteLinkRequest: InviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createInviteLink(inviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createKeyword(keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createKeyword(keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealPlan(mealPlanRequest: MealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealPlan(mealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMealType(mealTypeRequest: MealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMealType(mealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProperty(propertyRequest: PropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProperty(propertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPropertyType(propertyTypeRequest: PropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPropertyType(propertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipe(recipeRequest: RecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipe(recipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBook(recipeBookRequest: RecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBook(recipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeBookEntry(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeBookEntry(recipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRecipeUrlImport(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRecipeUrlImport(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListEntry(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListEntry(shoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createShoppingListRecipe(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createShoppingListRecipe(shoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStep(stepRequest: StepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStep(stepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createStorage(storageRequest: StorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createStorage(storageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarket(supermarketRequest: SupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarket(supermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategory(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategory(supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSupermarketCategoryRelation(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSupermarketCategoryRelation(supermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSync(syncRequest: SyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSync(syncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnit(unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnit(unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUnitConversion(unitConversionRequest: UnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUnitConversion(unitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserFile(name: string, file: any, id?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserFile(name, file, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createViewLog(viewLogRequest: ViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createViewLog(viewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createimportFiles(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createimportFiles(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createingredientFromString(ingredientStringRequest: IngredientStringRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParsedIngredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createingredientFromString(ingredientStringRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createresetFoodInheritance(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createresetFoodInheritance(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAccessToken(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyAutomation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyBookmarkletImport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyConnectorConfig(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyConnectorConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCookLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyCustomFilter(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyExportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyFood(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyImportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyIngredient(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyInviteLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyKeyword(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealPlan(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyMealType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyProperty(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyPropertyType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyPropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBook(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyRecipeBookEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyShoppingListRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStep(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyStorage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarket(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySupermarketCategoryRelation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroySync(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroySync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnit(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUnitConversion(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserFile(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyUserSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async destroyViewLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.destroyViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fdcFood(id: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fdcFood(id, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.icalMealPlan(fromDate, mealType, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageRecipe(id: number, image?: any, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageRecipe(id, image, imageUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAccessTokens(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAccessTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAutomationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAutomations(page, pageSize, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBookmarkletImports(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBookmarkletImportListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBookmarkletImports(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConnectorConfigs(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorConfigConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConnectorConfigs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCookLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCookLogs(page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomFilterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listExportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listExportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoodInheritFields(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodInheritField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoodInheritFields(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFoodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listGroups(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listGroups(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listImportLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIngredientList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listIngredients(food, page, pageSize, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInviteLinkList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKeywordList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealPlanList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealPlans(fromDate, mealType, page, pageSize, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listMealTypes(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listMealTypes(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertyTypes(category, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPropertys(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPropertys(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBookEntrys(book, page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeOverviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listRecipes2(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeFlat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listRecipes2(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListEntrys(checked, id, page, pageSize, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listShoppingListRecipes(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListRecipeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listShoppingListRecipes(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSpaces(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Space>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSpaces(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStepList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSteps(page, pageSize, query, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listStorages(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listStorages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryRelationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSupermarkets(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSyncs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSyncs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitConversionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnitConversions(foodId, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUnits(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserFiles(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserPreferences(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPreference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserSpaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUserSpaces(internalNote, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listUsers(filterList?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listUsers(filterList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listViewLogs(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedViewLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listViewLogs(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeFood(id: number, target: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFood(id, target, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeKeyword(id: number, target: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeKeyword(id, target, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeSupermarketCategory(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeSupermarketCategory(id, target, supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeUnit(id: number, target: number, unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeUnit(id, target, unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveFood(id: number, parent: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveFood(id, parent, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async moveKeyword(id: number, parent: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.moveKeyword(id, parent, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAccessToken(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAccessToken(id, patchedAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateAutomation(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateAutomation(id, patchedAutomationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateBookmarkletImport(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateBookmarkletImport(id, patchedBookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateConnectorConfig(id, patchedConnectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCookLog(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCookLog(id, patchedCookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateCustomFilter(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateCustomFilter(id, patchedCustomFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateExportLog(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateExportLog(id, patchedExportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateFood(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateFood(id, patchedFoodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateImportLog(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateImportLog(id, patchedImportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateIngredient(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateIngredient(id, patchedIngredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateInviteLink(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateInviteLink(id, patchedInviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateKeyword(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateKeyword(id, patchedKeywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealPlan(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealPlan(id, patchedMealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateMealType(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateMealType(id, patchedMealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateProperty(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateProperty(id, patchedPropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdatePropertyType(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdatePropertyType(id, patchedPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipe(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipe(id, patchedRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBook(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBook(id, patchedRecipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateRecipeBookEntry(id, patchedRecipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListEntry(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListEntry(id, patchedShoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateShoppingListRecipe(id, patchedShoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSpace(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSpace(id, patchedSpaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStep(id: number, patchedStepRequest?: PatchedStepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStep(id, patchedStepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateStorage(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateStorage(id, patchedStorageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarket(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarket(id, patchedSupermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategory(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategory(id, patchedSupermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateSync(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateSync(id, patchedSyncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnit(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnit(id, patchedUnitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUnitConversion(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUnitConversion(id, patchedUnitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUser(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUser(id, patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserFile(id: number, name?: string, file?: any, id2?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserFile(id, name, file, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserPreference(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserPreference(user, patchedUserPreferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateUserSpace(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateUserSpace(id, patchedUserSpaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async partialUpdateViewLog(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.partialUpdateViewLog(id, patchedViewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async relatedRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.relatedRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAccessToken(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAccessToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveAutomation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveAutomation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveBookmarkletImport(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveBookmarkletImport(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveConnectorConfig(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveConnectorConfig(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCookLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCookLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveCustomFilter(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveCustomFilter(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveExportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveExportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFood(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFood(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFoodInheritField(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodInheritField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFoodInheritField(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveGroup(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveImportLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveImportLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveIngredient(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveIngredient(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveInviteLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveInviteLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveKeyword(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveKeyword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealPlan(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealPlan(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveMealType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveMealType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveProperty(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveProperty(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievePropertyType(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievePropertyType(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBook(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBook(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveRecipeBookEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveRecipeBookEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListEntry(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListEntry(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveShoppingListRecipe(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveShoppingListRecipe(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStep(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStep(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveStorage(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveStorage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarket(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarket(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategory(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategory(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSupermarketCategoryRelation(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSupermarketCategoryRelation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSync(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSync(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveSyncLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveSyncLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnit(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUnitConversion(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUnitConversion(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUser(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserFile(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserPreference(user: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserPreference(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveUserSpace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveUserSpace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveViewLog(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveViewLog(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievedownloadFile(fileId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievedownloadFile(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievegetExternalFileLink(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievegetExternalFileLink(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrievegetRecipeFile(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrievegetRecipeFile(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveshareLink(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveshareLink(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveswitchActiveSpace(spaceId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveswitchActiveSpace(spaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingFood(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingFood(id, foodShoppingUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async shoppingRecipe(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.shoppingRecipe(id, recipeShoppingUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAccessToken(id: number, accessTokenRequest: AccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAccessToken(id, accessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAutomation(id: number, automationRequest: AutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAutomation(id, automationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBookmarkletImport(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBookmarkletImport(id, bookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConnectorConfig(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConnectorConfig(id, connectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCookLog(id: number, cookLogRequest: CookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCookLog(id, cookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomFilter(id: number, customFilterRequest: CustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomFilter(id, customFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateExportLog(id: number, exportLogRequest: ExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateExportLog(id, exportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFood(id: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFood(id, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImportLog(id: number, importLogRequest: ImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateImportLog(id, importLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIngredient(id: number, ingredientRequest: IngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateIngredient(id, ingredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateInviteLink(id: number, inviteLinkRequest: InviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateInviteLink(id, inviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateKeyword(id: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateKeyword(id, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealPlan(id: number, mealPlanRequest: MealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealPlan(id, mealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateMealType(id: number, mealTypeRequest: MealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateMealType(id, mealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProperty(id: number, propertyRequest: PropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProperty(id, propertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePropertyType(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePropertyType(id, propertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipe(id: number, recipeRequest: RecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipe(id, recipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBook(id: number, recipeBookRequest: RecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBook(id, recipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRecipeBookEntry(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRecipeBookEntry(id, recipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListEntry(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListEntry(id, shoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateShoppingListRecipe(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateShoppingListRecipe(id, shoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStep(id: number, stepRequest: StepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStep(id, stepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStorage(id: number, storageRequest: StorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStorage(id, storageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarket(id: number, supermarketRequest: SupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarket(id, supermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategory(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategory(id, supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSupermarketCategoryRelation(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSupermarketCategoryRelation(id, supermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSync(id: number, syncRequest: SyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSync(id, syncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnit(id: number, unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnit(id, unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUnitConversion(id: number, unitConversionRequest: UnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUnitConversion(id, unitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserFile(id: number, name: string, file: any, id2?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserFile(id, name, file, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateViewLog(id: number, viewLogRequest: ViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateViewLog(id, viewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkShoppingListEntry(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any): AxiosPromise<ShoppingListEntryBulk> {
            return localVarFp.bulkShoppingListEntry(shoppingListEntryBulkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccessToken(accessTokenRequest: AccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.createAccessToken(accessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutoMealPlan(autoMealPlanRequest: AutoMealPlanRequest, options?: any): AxiosPromise<AutoMealPlan> {
            return localVarFp.createAutoMealPlan(autoMealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAutomation(automationRequest: AutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.createAutomation(automationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBookmarkletImport(bookmarkletImportRequest: BookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.createBookmarkletImport(bookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConnectorConfig(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.createConnectorConfig(connectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCookLog(cookLogRequest: CookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.createCookLog(cookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomFilter(customFilterRequest: CustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.createCustomFilter(customFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExportLog(exportLogRequest: ExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.createExportLog(exportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFood(foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.createFood(foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportLog(importLogRequest: ImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.createImportLog(importLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createIngredient(ingredientRequest: IngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.createIngredient(ingredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInviteLink(inviteLinkRequest: InviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.createInviteLink(inviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createKeyword(keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.createKeyword(keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealPlan(mealPlanRequest: MealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.createMealPlan(mealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMealType(mealTypeRequest: MealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.createMealType(mealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProperty(propertyRequest: PropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.createProperty(propertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPropertyType(propertyTypeRequest: PropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.createPropertyType(propertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipe(recipeRequest: RecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.createRecipe(recipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBook(recipeBookRequest: RecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.createRecipeBook(recipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeBookEntry(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.createRecipeBookEntry(recipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRecipeUrlImport(options?: any): AxiosPromise<void> {
            return localVarFp.createRecipeUrlImport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListEntry(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.createShoppingListEntry(shoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createShoppingListRecipe(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.createShoppingListRecipe(shoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStep(stepRequest: StepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.createStep(stepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createStorage(storageRequest: StorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.createStorage(storageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarket(supermarketRequest: SupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.createSupermarket(supermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategory(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.createSupermarketCategory(supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSupermarketCategoryRelation(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.createSupermarketCategoryRelation(supermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSync(syncRequest: SyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.createSync(syncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnit(unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.createUnit(unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUnitConversion(unitConversionRequest: UnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.createUnitConversion(unitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserFile(name: string, file: any, id?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.createUserFile(name, file, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createViewLog(viewLogRequest: ViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.createViewLog(viewLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createimportFiles(options?: any): AxiosPromise<void> {
            return localVarFp.createimportFiles(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createingredientFromString(ingredientStringRequest: IngredientStringRequest, options?: any): AxiosPromise<ParsedIngredient> {
            return localVarFp.createingredientFromString(ingredientStringRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createresetFoodInheritance(options?: any): AxiosPromise<void> {
            return localVarFp.createresetFoodInheritance(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAccessToken(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyAutomation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyBookmarkletImport(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyConnectorConfig(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyConnectorConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCookLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyCustomFilter(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyExportLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyFood(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyImportLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyIngredient(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyInviteLink(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyKeyword(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealPlan(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyMealType(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyProperty(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyPropertyType(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyPropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipe(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBook(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyRecipeBookEntry(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListEntry(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyShoppingListRecipe(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStep(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyStorage(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarket(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategory(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySupermarketCategoryRelation(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroySync(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroySync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnit(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUnitConversion(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserFile(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyUserSpace(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        destroyViewLog(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.destroyViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fdcFood(id: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.fdcFood(id, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): AxiosPromise<string> {
            return localVarFp.icalMealPlan(fromDate, mealType, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageRecipe(id: number, image?: any, imageUrl?: string, options?: any): AxiosPromise<RecipeImage> {
            return localVarFp.imageRecipe(id, image, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAccessTokens(options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.listAccessTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): AxiosPromise<PaginatedAutomationList> {
            return localVarFp.listAutomations(page, pageSize, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBookmarkletImports(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBookmarkletImportListList> {
            return localVarFp.listBookmarkletImports(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConnectorConfigs(options?: any): AxiosPromise<Array<ConnectorConfigConfig>> {
            return localVarFp.listConnectorConfigs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedCookLogList> {
            return localVarFp.listCookLogs(page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): AxiosPromise<PaginatedCustomFilterList> {
            return localVarFp.listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listExportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedExportLogList> {
            return localVarFp.listExportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoodInheritFields(options?: any): AxiosPromise<Array<FoodInheritField>> {
            return localVarFp.listFoodInheritFields(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedFoodList> {
            return localVarFp.listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listGroups(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.listGroups(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedImportLogList> {
            return localVarFp.listImportLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): AxiosPromise<PaginatedIngredientList> {
            return localVarFp.listIngredients(food, page, pageSize, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedInviteLinkList> {
            return localVarFp.listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedKeywordList> {
            return localVarFp.listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): AxiosPromise<PaginatedMealPlanList> {
            return localVarFp.listMealPlans(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listMealTypes(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedMealTypeList> {
            return localVarFp.listMealTypes(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyTypeList> {
            return localVarFp.listPropertyTypes(category, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPropertys(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyList> {
            return localVarFp.listPropertys(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedRecipeBookEntryList> {
            return localVarFp.listRecipeBookEntrys(book, page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedRecipeBookList> {
            return localVarFp.listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): AxiosPromise<PaginatedRecipeOverviewList> {
            return localVarFp.listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listRecipes2(options?: any): AxiosPromise<Array<RecipeFlat>> {
            return localVarFp.listRecipes2(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): AxiosPromise<PaginatedShoppingListEntryList> {
            return localVarFp.listShoppingListEntrys(checked, id, page, pageSize, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listShoppingListRecipes(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedShoppingListRecipeList> {
            return localVarFp.listShoppingListRecipes(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSpaces(options?: any): AxiosPromise<Array<Space>> {
            return localVarFp.listSpaces(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): AxiosPromise<PaginatedStepList> {
            return localVarFp.listSteps(page, pageSize, query, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listStorages(options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.listStorages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryRelationList> {
            return localVarFp.listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryList> {
            return localVarFp.listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketList> {
            return localVarFp.listSupermarkets(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncLogList> {
            return localVarFp.listSyncLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSyncs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncList> {
            return localVarFp.listSyncs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUnitConversionList> {
            return localVarFp.listUnitConversions(foodId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUnitList> {
            return localVarFp.listUnits(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUserFileList> {
            return localVarFp.listUserFiles(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserPreferences(options?: any): AxiosPromise<Array<UserPreference>> {
            return localVarFp.listUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUserSpaceList> {
            return localVarFp.listUserSpaces(internalNote, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listUsers(filterList?: Array<string>, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.listUsers(filterList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listViewLogs(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedViewLogList> {
            return localVarFp.listViewLogs(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFood(id: number, target: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.mergeFood(id, target, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeKeyword(id: number, target: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.mergeKeyword(id, target, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeSupermarketCategory(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.mergeSupermarketCategory(id, target, supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeUnit(id: number, target: number, unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.mergeUnit(id, target, unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveFood(id: number, parent: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.moveFood(id, parent, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        moveKeyword(id: number, parent: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.moveKeyword(id, parent, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAccessToken(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.partialUpdateAccessToken(id, patchedAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateAutomation(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.partialUpdateAutomation(id, patchedAutomationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateBookmarkletImport(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.partialUpdateBookmarkletImport(id, patchedBookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.partialUpdateConnectorConfig(id, patchedConnectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCookLog(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.partialUpdateCookLog(id, patchedCookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateCustomFilter(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.partialUpdateCustomFilter(id, patchedCustomFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateExportLog(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.partialUpdateExportLog(id, patchedExportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateFood(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.partialUpdateFood(id, patchedFoodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateImportLog(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.partialUpdateImportLog(id, patchedImportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateIngredient(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.partialUpdateIngredient(id, patchedIngredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateInviteLink(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.partialUpdateInviteLink(id, patchedInviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateKeyword(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.partialUpdateKeyword(id, patchedKeywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealPlan(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.partialUpdateMealPlan(id, patchedMealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateMealType(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.partialUpdateMealType(id, patchedMealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateProperty(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.partialUpdateProperty(id, patchedPropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdatePropertyType(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.partialUpdatePropertyType(id, patchedPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipe(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.partialUpdateRecipe(id, patchedRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBook(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.partialUpdateRecipeBook(id, patchedRecipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.partialUpdateRecipeBookEntry(id, patchedRecipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListEntry(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.partialUpdateShoppingListEntry(id, patchedShoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.partialUpdateShoppingListRecipe(id, patchedShoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSpace(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any): AxiosPromise<Space> {
            return localVarFp.partialUpdateSpace(id, patchedSpaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStep(id: number, patchedStepRequest?: PatchedStepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.partialUpdateStep(id, patchedStepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateStorage(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.partialUpdateStorage(id, patchedStorageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarket(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.partialUpdateSupermarket(id, patchedSupermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategory(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.partialUpdateSupermarketCategory(id, patchedSupermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateSync(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.partialUpdateSync(id, patchedSyncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnit(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.partialUpdateUnit(id, patchedUnitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUnitConversion(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.partialUpdateUnitConversion(id, patchedUnitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUser(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.partialUpdateUser(id, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserFile(id: number, name?: string, file?: any, id2?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.partialUpdateUserFile(id, name, file, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserPreference(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.partialUpdateUserPreference(user, patchedUserPreferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateUserSpace(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.partialUpdateUserSpace(id, patchedUserSpaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partialUpdateViewLog(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.partialUpdateViewLog(id, patchedViewLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        relatedRecipe(id: number, options?: any): AxiosPromise<RecipeSimple> {
            return localVarFp.relatedRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAccessToken(id: number, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.retrieveAccessToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveAutomation(id: number, options?: any): AxiosPromise<Automation> {
            return localVarFp.retrieveAutomation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveBookmarkletImport(id: number, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.retrieveBookmarkletImport(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveConnectorConfig(id: number, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.retrieveConnectorConfig(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCookLog(id: number, options?: any): AxiosPromise<CookLog> {
            return localVarFp.retrieveCookLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveCustomFilter(id: number, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.retrieveCustomFilter(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveExportLog(id: number, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.retrieveExportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFood(id: number, options?: any): AxiosPromise<Food> {
            return localVarFp.retrieveFood(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFoodInheritField(id: number, options?: any): AxiosPromise<FoodInheritField> {
            return localVarFp.retrieveFoodInheritField(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveGroup(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.retrieveGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportLog(id: number, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.retrieveImportLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveIngredient(id: number, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.retrieveIngredient(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveInviteLink(id: number, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.retrieveInviteLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveKeyword(id: number, options?: any): AxiosPromise<Keyword> {
            return localVarFp.retrieveKeyword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealPlan(id: number, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.retrieveMealPlan(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveMealType(id: number, options?: any): AxiosPromise<MealType> {
            return localVarFp.retrieveMealType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveProperty(id: number, options?: any): AxiosPromise<Property> {
            return localVarFp.retrieveProperty(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievePropertyType(id: number, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.retrievePropertyType(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipe(id: number, options?: any): AxiosPromise<Recipe> {
            return localVarFp.retrieveRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBook(id: number, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.retrieveRecipeBook(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveRecipeBookEntry(id: number, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.retrieveRecipeBookEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListEntry(id: number, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.retrieveShoppingListEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveShoppingListRecipe(id: number, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.retrieveShoppingListRecipe(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSpace(id: number, options?: any): AxiosPromise<Space> {
            return localVarFp.retrieveSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStep(id: number, options?: any): AxiosPromise<Step> {
            return localVarFp.retrieveStep(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveStorage(id: number, options?: any): AxiosPromise<Storage> {
            return localVarFp.retrieveStorage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarket(id: number, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.retrieveSupermarket(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategory(id: number, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.retrieveSupermarketCategory(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSupermarketCategoryRelation(id: number, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.retrieveSupermarketCategoryRelation(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSync(id: number, options?: any): AxiosPromise<Sync> {
            return localVarFp.retrieveSync(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveSyncLog(id: number, options?: any): AxiosPromise<SyncLog> {
            return localVarFp.retrieveSyncLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnit(id: number, options?: any): AxiosPromise<Unit> {
            return localVarFp.retrieveUnit(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUnitConversion(id: number, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.retrieveUnitConversion(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUser(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.retrieveUser(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserFile(id: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.retrieveUserFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserPreference(user: number, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.retrieveUserPreference(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveUserSpace(id: number, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.retrieveUserSpace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveViewLog(id: number, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.retrieveViewLog(id, options).then((request) => request(axios, basePath));
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievedownloadFile(fileId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievedownloadFile(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetExternalFileLink(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievegetExternalFileLink(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrievegetRecipeFile(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrievegetRecipeFile(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveshareLink(id: number, options?: any): AxiosPromise<ShareLink> {
            return localVarFp.retrieveshareLink(id, options).then((request) => request(axios, basePath));
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveswitchActiveSpace(spaceId: number, options?: any): AxiosPromise<void> {
            return localVarFp.retrieveswitchActiveSpace(spaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingFood(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any): AxiosPromise<FoodShoppingUpdate> {
            return localVarFp.shoppingFood(id, foodShoppingUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        shoppingRecipe(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any): AxiosPromise<RecipeShoppingUpdate> {
            return localVarFp.shoppingRecipe(id, recipeShoppingUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccessToken(id: number, accessTokenRequest: AccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.updateAccessToken(id, accessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAutomation(id: number, automationRequest: AutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.updateAutomation(id, automationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBookmarkletImport(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.updateBookmarkletImport(id, bookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConnectorConfig(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.updateConnectorConfig(id, connectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCookLog(id: number, cookLogRequest: CookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.updateCookLog(id, cookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomFilter(id: number, customFilterRequest: CustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.updateCustomFilter(id, customFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateExportLog(id: number, exportLogRequest: ExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.updateExportLog(id, exportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFood(id: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.updateFood(id, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImportLog(id: number, importLogRequest: ImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.updateImportLog(id, importLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIngredient(id: number, ingredientRequest: IngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.updateIngredient(id, ingredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInviteLink(id: number, inviteLinkRequest: InviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.updateInviteLink(id, inviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateKeyword(id: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.updateKeyword(id, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealPlan(id: number, mealPlanRequest: MealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.updateMealPlan(id, mealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateMealType(id: number, mealTypeRequest: MealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.updateMealType(id, mealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProperty(id: number, propertyRequest: PropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.updateProperty(id, propertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePropertyType(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.updatePropertyType(id, propertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipe(id: number, recipeRequest: RecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.updateRecipe(id, recipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBook(id: number, recipeBookRequest: RecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.updateRecipeBook(id, recipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRecipeBookEntry(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.updateRecipeBookEntry(id, recipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListEntry(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.updateShoppingListEntry(id, shoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateShoppingListRecipe(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.updateShoppingListRecipe(id, shoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStep(id: number, stepRequest: StepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.updateStep(id, stepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStorage(id: number, storageRequest: StorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.updateStorage(id, storageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarket(id: number, supermarketRequest: SupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.updateSupermarket(id, supermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategory(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.updateSupermarketCategory(id, supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSupermarketCategoryRelation(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.updateSupermarketCategoryRelation(id, supermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSync(id: number, syncRequest: SyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.updateSync(id, syncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnit(id: number, unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.updateUnit(id, unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnitConversion(id: number, unitConversionRequest: UnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.updateUnitConversion(id, unitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserFile(id: number, name: string, file: any, id2?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.updateUserFile(id, name, file, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateViewLog(id: number, viewLogRequest: ViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.updateViewLog(id, viewLogRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * 
     * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public bulkShoppingListEntry(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any) {
        return ApiApiFp(this.configuration).bulkShoppingListEntry(shoppingListEntryBulkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccessTokenRequest} accessTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAccessToken(accessTokenRequest: AccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).createAccessToken(accessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutoMealPlanRequest} autoMealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutoMealPlan(autoMealPlanRequest: AutoMealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).createAutoMealPlan(autoMealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutomationRequest} automationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createAutomation(automationRequest: AutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).createAutomation(automationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookmarkletImportRequest} bookmarkletImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createBookmarkletImport(bookmarkletImportRequest: BookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).createBookmarkletImport(bookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createConnectorConfig(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).createConnectorConfig(connectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CookLogRequest} cookLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCookLog(cookLogRequest: CookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).createCookLog(cookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomFilterRequest} customFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createCustomFilter(customFilterRequest: CustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).createCustomFilter(customFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportLogRequest} exportLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createExportLog(exportLogRequest: ExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).createExportLog(exportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createFood(foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).createFood(foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportLogRequest} importLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createImportLog(importLogRequest: ImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).createImportLog(importLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IngredientRequest} ingredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createIngredient(ingredientRequest: IngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).createIngredient(ingredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteLinkRequest} inviteLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createInviteLink(inviteLinkRequest: InviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).createInviteLink(inviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createKeyword(keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).createKeyword(keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MealPlanRequest} mealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealPlan(mealPlanRequest: MealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).createMealPlan(mealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {MealTypeRequest} mealTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createMealType(mealTypeRequest: MealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).createMealType(mealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyRequest} propertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createProperty(propertyRequest: PropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).createProperty(propertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyTypeRequest} propertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createPropertyType(propertyTypeRequest: PropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).createPropertyType(propertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeRequest} recipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipe(recipeRequest: RecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).createRecipe(recipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookRequest} recipeBookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBook(recipeBookRequest: RecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBook(recipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeBookEntry(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).createRecipeBookEntry(recipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createRecipeUrlImport(options?: any) {
        return ApiApiFp(this.configuration).createRecipeUrlImport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListEntry(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListEntry(shoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createShoppingListRecipe(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).createShoppingListRecipe(shoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StepRequest} stepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStep(stepRequest: StepRequest, options?: any) {
        return ApiApiFp(this.configuration).createStep(stepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StorageRequest} storageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createStorage(storageRequest: StorageRequest, options?: any) {
        return ApiApiFp(this.configuration).createStorage(storageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketRequest} supermarketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarket(supermarketRequest: SupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).createSupermarket(supermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategory(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategory(supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSupermarketCategoryRelation(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).createSupermarketCategoryRelation(supermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncRequest} syncRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createSync(syncRequest: SyncRequest, options?: any) {
        return ApiApiFp(this.configuration).createSync(syncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnit(unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).createUnit(unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitConversionRequest} unitConversionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUnitConversion(unitConversionRequest: UnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).createUnitConversion(unitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createUserFile(name: string, file: any, id?: number, options?: any) {
        return ApiApiFp(this.configuration).createUserFile(name, file, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewLogRequest} viewLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createViewLog(viewLogRequest: ViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).createViewLog(viewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to handle files passed by application importer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createimportFiles(options?: any) {
        return ApiApiFp(this.configuration).createimportFiles(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IngredientStringRequest} ingredientStringRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createingredientFromString(ingredientStringRequest: IngredientStringRequest, options?: any) {
        return ApiApiFp(this.configuration).createingredientFromString(ingredientStringRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to reset inheritance from api, see food method for docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public createresetFoodInheritance(options?: any) {
        return ApiApiFp(this.configuration).createresetFoodInheritance(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAccessToken(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyAutomation(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyBookmarkletImport(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyConnectorConfig(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyConnectorConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCookLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyCustomFilter(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyExportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyFood(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyImportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyIngredient(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyInviteLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyKeyword(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealPlan(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyMealType(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyProperty(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyPropertyType(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyPropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBook(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyRecipeBookEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyShoppingListRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStep(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyStorage(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarket(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategory(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySupermarketCategoryRelation(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroySync(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroySync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnit(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUnitConversion(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserFile(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyUserSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public destroyViewLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).destroyViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public fdcFood(id: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).fdcFood(id, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public icalMealPlan(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).icalMealPlan(fromDate, mealType, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {any} [image] 
     * @param {string} [imageUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public imageRecipe(id: number, image?: any, imageUrl?: string, options?: any) {
        return ApiApiFp(this.configuration).imageRecipe(id, image, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAccessTokens(options?: any) {
        return ApiApiFp(this.configuration).listAccessTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listAutomations(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any) {
        return ApiApiFp(this.configuration).listAutomations(page, pageSize, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listBookmarkletImports(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listBookmarkletImports(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listConnectorConfigs(options?: any) {
        return ApiApiFp(this.configuration).listConnectorConfigs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] Filter for entries with the given recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCookLogs(page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).listCookLogs(page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listCustomFilters(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listCustomFilters(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listExportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listExportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoodInheritFields(options?: any) {
        return ApiApiFp(this.configuration).listFoodInheritFields(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listFoods(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listFoods(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listGroups(options?: any) {
        return ApiApiFp(this.configuration).listGroups(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listImportLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listImportLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [food] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [unit] ID of unit to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listIngredients(food?: number, page?: number, pageSize?: number, unit?: number, options?: any) {
        return ApiApiFp(this.configuration).listIngredients(food, page, pageSize, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what internal_note is for.
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listInviteLinks(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listInviteLinks(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listKeywords(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listKeywords(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealPlans(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).listMealPlans(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listMealTypes(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listMealTypes(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertyTypes(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listPropertyTypes(category, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listPropertys(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listPropertys(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [book] id of book - only return recipes in that book
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] id of recipe - only return books for that recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBookEntrys(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).listRecipeBookEntrys(book, page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
     * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipeBooks(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listRecipeBooks(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
     * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
     * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
     * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
     * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
     * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
     * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
     * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
     * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
     * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
     * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
     * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
     * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
     * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
     * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
     * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
     * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
     * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
     * @param {number} [units] ID of unit a recipe should have.
     * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipes(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any) {
        return ApiApiFp(this.configuration).listRecipes(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listRecipes2(options?: any) {
        return ApiApiFp(this.configuration).listRecipes2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
     * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListEntrys(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any) {
        return ApiApiFp(this.configuration).listShoppingListEntrys(checked, id, page, pageSize, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listShoppingListRecipes(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listShoppingListRecipes(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSpaces(options?: any) {
        return ApiApiFp(this.configuration).listSpaces(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against object name.
     * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSteps(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any) {
        return ApiApiFp(this.configuration).listSteps(page, pageSize, query, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listStorages(options?: any) {
        return ApiApiFp(this.configuration).listStorages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategoryRelations(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategoryRelations(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarketCategorys(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarketCategorys(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSupermarkets(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listSupermarkets(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSyncLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listSyncs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listSyncs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [foodId] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnitConversions(foodId?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUnitConversions(foodId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUnits(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listUnits(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserFiles(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).listUserFiles(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserPreferences(options?: any) {
        return ApiApiFp(this.configuration).listUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what this is
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUserSpaces(internalNote?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listUserSpaces(internalNote, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [filterList] User IDs, repeat for multiple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listUsers(filterList?: Array<string>, options?: any) {
        return ApiApiFp(this.configuration).listUsers(filterList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public listViewLogs(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).listViewLogs(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeFood(id: number, target: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).mergeFood(id, target, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeKeyword(id: number, target: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).mergeKeyword(id, target, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeSupermarketCategory(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).mergeSupermarketCategory(id, target, supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public mergeUnit(id: number, target: number, unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).mergeUnit(id, target, unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveFood(id: number, parent: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).moveFood(id, parent, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public moveKeyword(id: number, parent: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).moveKeyword(id, parent, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAccessToken(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAccessToken(id, patchedAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateAutomation(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateAutomation(id, patchedAutomationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateBookmarkletImport(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateBookmarkletImport(id, patchedBookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateConnectorConfig(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateConnectorConfig(id, patchedConnectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCookLog(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCookLog(id, patchedCookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateCustomFilter(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateCustomFilter(id, patchedCustomFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateExportLog(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateExportLog(id, patchedExportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {PatchedFoodRequest} [patchedFoodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateFood(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateFood(id, patchedFoodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateImportLog(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateImportLog(id, patchedImportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateIngredient(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateIngredient(id, patchedIngredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateInviteLink(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateInviteLink(id, patchedInviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateKeyword(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateKeyword(id, patchedKeywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealPlan(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealPlan(id, patchedMealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateMealType(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateMealType(id, patchedMealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateProperty(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateProperty(id, patchedPropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdatePropertyType(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdatePropertyType(id, patchedPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipe(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipe(id, patchedRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBook(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBook(id, patchedRecipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateRecipeBookEntry(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateRecipeBookEntry(id, patchedRecipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListEntry(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListEntry(id, patchedShoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateShoppingListRecipe(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateShoppingListRecipe(id, patchedShoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSpace(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSpace(id, patchedSpaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {PatchedStepRequest} [patchedStepRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStep(id: number, patchedStepRequest?: PatchedStepRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStep(id, patchedStepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {PatchedStorageRequest} [patchedStorageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateStorage(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateStorage(id, patchedStorageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarket(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarket(id, patchedSupermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategory(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategory(id, patchedSupermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSupermarketCategoryRelation(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSupermarketCategoryRelation(id, patchedSupermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {PatchedSyncRequest} [patchedSyncRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateSync(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateSync(id, patchedSyncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {PatchedUnitRequest} [patchedUnitRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnit(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnit(id, patchedUnitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUnitConversion(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUnitConversion(id, patchedUnitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUser(id: number, patchedUserRequest?: PatchedUserRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUser(id, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {number} [id2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserFile(id: number, name?: string, file?: any, id2?: number, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserFile(id, name, file, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserPreference(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserPreference(user, patchedUserPreferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateUserSpace(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateUserSpace(id, patchedUserSpaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public partialUpdateViewLog(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).partialUpdateViewLog(id, patchedViewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public relatedRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).relatedRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAccessToken(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveAccessToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveAutomation(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveAutomation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveBookmarkletImport(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveBookmarkletImport(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveConnectorConfig(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveConnectorConfig(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCookLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveCookLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveCustomFilter(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveCustomFilter(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveExportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveExportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFood(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveFood(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food inherit field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveFoodInheritField(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveFoodInheritField(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveGroup(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveImportLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveImportLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveIngredient(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveIngredient(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveInviteLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveInviteLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveKeyword(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveKeyword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealPlan(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealPlan(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveMealType(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveMealType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveProperty(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveProperty(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievePropertyType(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrievePropertyType(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBook(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBook(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveRecipeBookEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveRecipeBookEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListEntry(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveShoppingListRecipe(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveShoppingListRecipe(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStep(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveStep(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveStorage(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveStorage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarket(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarket(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategory(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategory(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSupermarketCategoryRelation(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSupermarketCategoryRelation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSync(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSync(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveSyncLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveSyncLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnit(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnit(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUnitConversion(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUnitConversion(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUser(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUser(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserFile(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserPreference(user: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserPreference(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveUserSpace(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveUserSpace(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveViewLog(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveViewLog(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     * @param {number} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievedownloadFile(fileId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievedownloadFile(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievegetExternalFileLink(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievegetExternalFileLink(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrievegetRecipeFile(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).retrievegetRecipeFile(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveshareLink(id: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveshareLink(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api endpoint to switch space function
     * @param {number} spaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public retrieveswitchActiveSpace(spaceId: number, options?: any) {
        return ApiApiFp(this.configuration).retrieveswitchActiveSpace(spaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingFood(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any) {
        return ApiApiFp(this.configuration).shoppingFood(id, foodShoppingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public shoppingRecipe(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any) {
        return ApiApiFp(this.configuration).shoppingRecipe(id, recipeShoppingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {AccessTokenRequest} accessTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAccessToken(id: number, accessTokenRequest: AccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).updateAccessToken(id, accessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {AutomationRequest} automationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateAutomation(id: number, automationRequest: AutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).updateAutomation(id, automationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImportRequest} bookmarkletImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateBookmarkletImport(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).updateBookmarkletImport(id, bookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateConnectorConfig(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).updateConnectorConfig(id, connectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {CookLogRequest} cookLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCookLog(id: number, cookLogRequest: CookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).updateCookLog(id, cookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {CustomFilterRequest} customFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateCustomFilter(id: number, customFilterRequest: CustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).updateCustomFilter(id, customFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {ExportLogRequest} exportLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateExportLog(id: number, exportLogRequest: ExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).updateExportLog(id, exportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateFood(id: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).updateFood(id, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {ImportLogRequest} importLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateImportLog(id: number, importLogRequest: ImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).updateImportLog(id, importLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {IngredientRequest} ingredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateIngredient(id: number, ingredientRequest: IngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).updateIngredient(id, ingredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {InviteLinkRequest} inviteLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateInviteLink(id: number, inviteLinkRequest: InviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).updateInviteLink(id, inviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateKeyword(id: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).updateKeyword(id, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {MealPlanRequest} mealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealPlan(id: number, mealPlanRequest: MealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).updateMealPlan(id, mealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {MealTypeRequest} mealTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateMealType(id: number, mealTypeRequest: MealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).updateMealType(id, mealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PropertyRequest} propertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateProperty(id: number, propertyRequest: PropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).updateProperty(id, propertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PropertyTypeRequest} propertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updatePropertyType(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).updatePropertyType(id, propertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeRequest} recipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipe(id: number, recipeRequest: RecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).updateRecipe(id, recipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {RecipeBookRequest} recipeBookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBook(id: number, recipeBookRequest: RecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBook(id, recipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateRecipeBookEntry(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).updateRecipeBookEntry(id, recipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListEntry(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListEntry(id, shoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateShoppingListRecipe(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).updateShoppingListRecipe(id, shoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {StepRequest} stepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStep(id: number, stepRequest: StepRequest, options?: any) {
        return ApiApiFp(this.configuration).updateStep(id, stepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {StorageRequest} storageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateStorage(id: number, storageRequest: StorageRequest, options?: any) {
        return ApiApiFp(this.configuration).updateStorage(id, storageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {SupermarketRequest} supermarketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarket(id: number, supermarketRequest: SupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarket(id, supermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategory(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategory(id, supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSupermarketCategoryRelation(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).updateSupermarketCategoryRelation(id, supermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {SyncRequest} syncRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateSync(id: number, syncRequest: SyncRequest, options?: any) {
        return ApiApiFp(this.configuration).updateSync(id, syncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnit(id: number, unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).updateUnit(id, unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {UnitConversionRequest} unitConversionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUnitConversion(id: number, unitConversionRequest: UnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).updateUnitConversion(id, unitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateUserFile(id: number, name: string, file: any, id2?: number, options?: any) {
        return ApiApiFp(this.configuration).updateUserFile(id, name, file, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {ViewLogRequest} viewLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public updateViewLog(id: number, viewLogRequest: ViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).updateViewLog(id, viewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiImportOpenDataApi - axios parameter creator
 * @export
 */
export const ApiImportOpenDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportOpenData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiImportOpenDataApi - functional programming interface
 * @export
 */
export const ApiImportOpenDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiImportOpenDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createImportOpenData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createImportOpenData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveImportOpenData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveImportOpenData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiImportOpenDataApi - factory interface
 * @export
 */
export const ApiImportOpenDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiImportOpenDataApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createImportOpenData(options?: any): AxiosPromise<void> {
            return localVarFp.createImportOpenData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveImportOpenData(options?: any): AxiosPromise<void> {
            return localVarFp.retrieveImportOpenData(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiImportOpenDataApi - object-oriented interface
 * @export
 * @class ApiImportOpenDataApi
 * @extends {BaseAPI}
 */
export class ApiImportOpenDataApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public createImportOpenData(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).createImportOpenData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public retrieveImportOpenData(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).retrieveImportOpenData(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiTokenAuthApi - axios parameter creator
 * @export
 */
export const ApiTokenAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('createAuthToken', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('createAuthToken', 'password', password)
            const localVarPath = `/api-token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenAuthApi - functional programming interface
 * @export
 */
export const ApiTokenAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAuthToken(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAuthToken(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiTokenAuthApi - factory interface
 * @export
 */
export const ApiTokenAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAuthToken(username: string, password: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.createAuthToken(username, password, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenAuthApi - object-oriented interface
 * @export
 * @class ApiTokenAuthApi
 * @extends {BaseAPI}
 */
export class ApiTokenAuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenAuthApi
     */
    public createAuthToken(username: string, password: string, options?: any) {
        return ApiTokenAuthApiFp(this.configuration).createAuthToken(username, password, options).then((request) => request(this.axios, this.basePath));
    }
}


