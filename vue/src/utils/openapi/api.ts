/* tslint:disable */
/* eslint-disable */
/**
 * Tandoor
 * Tandoor API Docs
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    token: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    scope?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    created: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    updated: string;
}
/**
 * 
 * @export
 * @interface AccessTokenRequest
 */
export interface AccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenRequest
     */
    expires: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenRequest
     */
    scope?: string;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    token: string;
}
/**
 * 
 * @export
 * @interface AuthTokenRequest
 */
export interface AuthTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenRequest
     */
    password: string;
}
/**
 * 
 * @export
 * @interface AutoMealPlan
 */
export interface AutoMealPlan {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlan
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlan
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlan
     */
    servings: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof AutoMealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlan
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface AutoMealPlanRequest
 */
export interface AutoMealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlanRequest
     */
    start_date: string;
    /**
     * 
     * @type {string}
     * @memberof AutoMealPlanRequest
     */
    end_date: string;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlanRequest
     */
    meal_type_id: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof AutoMealPlanRequest
     */
    keyword_ids: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof AutoMealPlanRequest
     */
    servings: number;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof AutoMealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof AutoMealPlanRequest
     */
    addshopping: boolean;
}
/**
 * 
 * @export
 * @interface Automation
 */
export interface Automation {
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    id: number;
    /**
     * 
     * @type {TypeEnum}
     * @memberof Automation
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Automation
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Automation
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Automation
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface AutomationRequest
 */
export interface AutomationRequest {
    /**
     * 
     * @type {TypeEnum}
     * @memberof AutomationRequest
     */
    type: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AutomationRequest
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AutomationRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AutomationRequest
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AutomationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface BookmarkletImport
 */
export interface BookmarkletImport {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImport
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImport
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportList
 */
export interface BookmarkletImportList {
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    url?: string | null;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportList
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportList
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface BookmarkletImportRequest
 */
export interface BookmarkletImportRequest {
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BookmarkletImportRequest
     */
    html: string;
    /**
     * 
     * @type {number}
     * @memberof BookmarkletImportRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfig
 */
export interface ConnectorConfigConfig {
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfig
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfig
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfig
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface ConnectorConfigConfigRequest
 */
export interface ConnectorConfigConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConnectorConfigConfigRequest
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ConnectorConfigConfigRequest
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnectorConfigConfigRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface CookLog
 */
export interface CookLog {
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLog
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    comment?: string | null;
    /**
     * 
     * @type {User}
     * @memberof CookLog
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    created_at?: string;
    /**
     * 
     * @type {string}
     * @memberof CookLog
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface CookLogRequest
 */
export interface CookLogRequest {
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CookLogRequest
     */
    comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CookLogRequest
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof CookLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilter
 */
export interface CustomFilter {
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilter
     */
    search: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof CustomFilter
     */
    shared?: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilter
     */
    created_by: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface CustomFilterRequest
 */
export interface CustomFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof CustomFilterRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CustomFilterRequest
     */
    search: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof CustomFilterRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof CustomFilterRequest
     */
    id?: number;
}
/**
 * * `SEARCH` - Search * `PLAN` - Meal-Plan * `BOOKS` - Books * `SHOPPING` - Shopping
 * @export
 * @enum {string}
 */
export enum DefaultPageEnum {
    Search = 'SEARCH',
    Plan = 'PLAN',
    Books = 'BOOKS',
    Shopping = 'SHOPPING'
}

/**
 * * `true` - true
 * @export
 * @enum {string}
 */
export enum DeleteEnum {
    True = 'true'
}

/**
 * 
 * @export
 * @interface ExportLog
 */
export interface ExportLog {
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLog
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ExportLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ExportLogRequest
 */
export interface ExportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof ExportLogRequest
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ExportLogRequest
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ExportLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Food
 */
export interface Food {
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    shopping: string;
    /**
     * 
     * @type {RecipeSimple}
     * @memberof Food
     */
    recipe?: RecipeSimple | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    url?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Food
     */
    properties?: Array<Property> | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {Unit}
     * @memberof Food
     */
    properties_food_unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof Food
     */
    supermarket_category?: SupermarketCategory | null;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Food
     */
    numchild: number;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    inherit_fields?: Array<FoodInheritField> | null;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Food
     */
    full_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimple>}
     * @memberof Food
     */
    substitute?: Array<FoodSimple> | null;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Food
     */
    substitute_onhand: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Food
     */
    child_inherit_fields?: Array<FoodInheritField> | null;
    /**
     * 
     * @type {string}
     * @memberof Food
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritField
 */
export interface FoodInheritField {
    /**
     * 
     * @type {number}
     * @memberof FoodInheritField
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritField
     */
    field?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodInheritFieldRequest
 */
export interface FoodInheritFieldRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFieldRequest
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodInheritFieldRequest
     */
    field?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodInheritFieldRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface FoodRequest
 */
export interface FoodRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    description?: string;
    /**
     * 
     * @type {RecipeSimpleRequest}
     * @memberof FoodRequest
     */
    recipe?: RecipeSimpleRequest | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    url?: string | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof FoodRequest
     */
    properties?: Array<PropertyRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof FoodRequest
     */
    properties_food_unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof FoodRequest
     */
    supermarket_category?: SupermarketCategoryRequest | null;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof FoodRequest
     */
    inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimpleRequest>}
     * @memberof FoodRequest
     */
    substitute?: Array<FoodSimpleRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FoodRequest
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof FoodRequest
     */
    child_inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof FoodRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdate
 */
export interface FoodShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdate
     */
    id: number;
}
/**
 * 
 * @export
 * @interface FoodShoppingUpdateRequest
 */
export interface FoodShoppingUpdateRequest {
    /**
     * Amount of food to add to the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    amount?: number | null;
    /**
     * ID of unit to use for the shopping list
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    unit?: number | null;
    /**
     * When set to true will delete all food from active shopping lists.  * `true` - true
     * @type {DeleteEnum}
     * @memberof FoodShoppingUpdateRequest
     */
    _delete: DeleteEnum | null;
    /**
     * 
     * @type {number}
     * @memberof FoodShoppingUpdateRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface FoodSimple
 */
export interface FoodSimple {
    /**
     * 
     * @type {number}
     * @memberof FoodSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimple
     */
    plural_name?: string | null;
}
/**
 * 
 * @export
 * @interface FoodSimpleRequest
 */
export interface FoodSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof FoodSimpleRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof FoodSimpleRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {number}
     * @memberof FoodSimpleRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface GroupRequest
 */
export interface GroupRequest {
    /**
     * 
     * @type {string}
     * @memberof GroupRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof GroupRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ImportLog
 */
export interface ImportLog {
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLog
     */
    running?: boolean;
    /**
     * 
     * @type {Keyword}
     * @memberof ImportLog
     */
    keyword: Keyword;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ImportLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ImportLogRequest
 */
export interface ImportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof ImportLogRequest
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof ImportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ImportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof ImportLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface Ingredient
 */
export interface Ingredient {
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    id: number;
    /**
     * 
     * @type {Food}
     * @memberof Ingredient
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof Ingredient
     */
    unit: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    amount: number;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    conversions: Array<any>;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Ingredient
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Ingredient
     */
    original_text?: string | null;
    /**
     * 
     * @type {Array<any>}
     * @memberof Ingredient
     */
    used_in_recipes: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Ingredient
     */
    always_use_plural_food?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface IngredientRequest
 */
export interface IngredientRequest {
    /**
     * 
     * @type {FoodRequest}
     * @memberof IngredientRequest
     */
    food: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof IngredientRequest
     */
    unit: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof IngredientRequest
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof IngredientRequest
     */
    original_text?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof IngredientRequest
     */
    always_use_plural_food?: boolean;
    /**
     * 
     * @type {number}
     * @memberof IngredientRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface IngredientStringRequest
 */
export interface IngredientStringRequest {
    /**
     * 
     * @type {string}
     * @memberof IngredientStringRequest
     */
    text: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLink
 */
export interface InviteLink {
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    uuid: string;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    email?: string;
    /**
     * 
     * @type {Group}
     * @memberof InviteLink
     */
    group: Group;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLink
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLink
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof InviteLink
     */
    created_at: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface InviteLinkRequest
 */
export interface InviteLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    email?: string;
    /**
     * 
     * @type {GroupRequest}
     * @memberof InviteLinkRequest
     */
    group: GroupRequest;
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof InviteLinkRequest
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof InviteLinkRequest
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InviteLinkRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof InviteLinkRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    label: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    parent: number;
    /**
     * 
     * @type {number}
     * @memberof Keyword
     */
    numchild: number;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Keyword
     */
    updated_at: string;
    /**
     * Returns a string representation of a tree node and it\'s ancestors, e.g. \'Cuisine > Asian > Chinese > Catonese\'.
     * @type {string}
     * @memberof Keyword
     */
    full_name: string;
}
/**
 * 
 * @export
 * @interface KeywordLabel
 */
export interface KeywordLabel {
    /**
     * 
     * @type {number}
     * @memberof KeywordLabel
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof KeywordLabel
     */
    label: string;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface KeywordRequest
 */
export interface KeywordRequest {
    /**
     * 
     * @type {string}
     * @memberof KeywordRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof KeywordRequest
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof KeywordRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlan
 */
export interface MealPlan {
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof MealPlan
     */
    recipe?: RecipeOverview | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    note_markdown: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    to_date?: string;
    /**
     * 
     * @type {MealType}
     * @memberof MealPlan
     */
    meal_type: MealType;
    /**
     * 
     * @type {number}
     * @memberof MealPlan
     */
    created_by: number;
    /**
     * 
     * @type {Array<User>}
     * @memberof MealPlan
     */
    shared?: Array<User> | null;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlan
     */
    meal_type_name: string;
    /**
     * 
     * @type {boolean}
     * @memberof MealPlan
     */
    shopping: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealPlanRequest
 */
export interface MealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverviewRequest}
     * @memberof MealPlanRequest
     */
    recipe?: RecipeOverviewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRequest
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    from_date: string;
    /**
     * 
     * @type {string}
     * @memberof MealPlanRequest
     */
    to_date?: string;
    /**
     * 
     * @type {MealTypeRequest}
     * @memberof MealPlanRequest
     */
    meal_type: MealTypeRequest;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof MealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof MealPlanRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealType
 */
export interface MealType {
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealType
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealType
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealType
     */
    created_by: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface MealTypeRequest
 */
export interface MealTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof MealTypeRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MealTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof MealTypeRequest
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof MealTypeRequest
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof MealTypeRequest
     */
    id?: number;
}
/**
 * * `DB` - Dropbox * `NEXTCLOUD` - Nextcloud * `LOCAL` - Local
 * @export
 * @enum {string}
 */
export enum MethodEnum {
    Db = 'DB',
    Nextcloud = 'NEXTCLOUD',
    Local = 'LOCAL'
}

/**
 * 
 * @export
 * @interface NutritionInformation
 */
export interface NutritionInformation {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformation
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformation
     */
    source?: string | null;
}
/**
 * 
 * @export
 * @interface NutritionInformationRequest
 */
export interface NutritionInformationRequest {
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    carbohydrates: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    fats: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    proteins: number;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    calories: number;
    /**
     * 
     * @type {string}
     * @memberof NutritionInformationRequest
     */
    source?: string | null;
    /**
     * 
     * @type {number}
     * @memberof NutritionInformationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PaginatedAutomationList
 */
export interface PaginatedAutomationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAutomationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAutomationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Automation>}
     * @memberof PaginatedAutomationList
     */
    results?: Array<Automation>;
}
/**
 * 
 * @export
 * @interface PaginatedBookmarkletImportListList
 */
export interface PaginatedBookmarkletImportListList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBookmarkletImportListList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBookmarkletImportListList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<BookmarkletImportList>}
     * @memberof PaginatedBookmarkletImportListList
     */
    results?: Array<BookmarkletImportList>;
}
/**
 * 
 * @export
 * @interface PaginatedCookLogList
 */
export interface PaginatedCookLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCookLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCookLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CookLog>}
     * @memberof PaginatedCookLogList
     */
    results?: Array<CookLog>;
}
/**
 * 
 * @export
 * @interface PaginatedCustomFilterList
 */
export interface PaginatedCustomFilterList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCustomFilterList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCustomFilterList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomFilter>}
     * @memberof PaginatedCustomFilterList
     */
    results?: Array<CustomFilter>;
}
/**
 * 
 * @export
 * @interface PaginatedExportLogList
 */
export interface PaginatedExportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedExportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedExportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportLog>}
     * @memberof PaginatedExportLogList
     */
    results?: Array<ExportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedFoodList
 */
export interface PaginatedFoodList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedFoodList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedFoodList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Food>}
     * @memberof PaginatedFoodList
     */
    results?: Array<Food>;
}
/**
 * 
 * @export
 * @interface PaginatedImportLogList
 */
export interface PaginatedImportLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedImportLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedImportLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImportLog>}
     * @memberof PaginatedImportLogList
     */
    results?: Array<ImportLog>;
}
/**
 * 
 * @export
 * @interface PaginatedIngredientList
 */
export interface PaginatedIngredientList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedIngredientList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedIngredientList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof PaginatedIngredientList
     */
    results?: Array<Ingredient>;
}
/**
 * 
 * @export
 * @interface PaginatedInviteLinkList
 */
export interface PaginatedInviteLinkList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedInviteLinkList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedInviteLinkList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InviteLink>}
     * @memberof PaginatedInviteLinkList
     */
    results?: Array<InviteLink>;
}
/**
 * 
 * @export
 * @interface PaginatedKeywordList
 */
export interface PaginatedKeywordList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedKeywordList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedKeywordList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof PaginatedKeywordList
     */
    results?: Array<Keyword>;
}
/**
 * 
 * @export
 * @interface PaginatedMealPlanList
 */
export interface PaginatedMealPlanList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealPlanList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealPlanList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealPlan>}
     * @memberof PaginatedMealPlanList
     */
    results?: Array<MealPlan>;
}
/**
 * 
 * @export
 * @interface PaginatedMealTypeList
 */
export interface PaginatedMealTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMealTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMealTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<MealType>}
     * @memberof PaginatedMealTypeList
     */
    results?: Array<MealType>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyList
 */
export interface PaginatedPropertyList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof PaginatedPropertyList
     */
    results?: Array<Property>;
}
/**
 * 
 * @export
 * @interface PaginatedPropertyTypeList
 */
export interface PaginatedPropertyTypeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPropertyTypeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPropertyTypeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PropertyType>}
     * @memberof PaginatedPropertyTypeList
     */
    results?: Array<PropertyType>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookEntryList
 */
export interface PaginatedRecipeBookEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBookEntry>}
     * @memberof PaginatedRecipeBookEntryList
     */
    results?: Array<RecipeBookEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeBookList
 */
export interface PaginatedRecipeBookList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeBookList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeBookList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeBook>}
     * @memberof PaginatedRecipeBookList
     */
    results?: Array<RecipeBook>;
}
/**
 * 
 * @export
 * @interface PaginatedRecipeOverviewList
 */
export interface PaginatedRecipeOverviewList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRecipeOverviewList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRecipeOverviewList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RecipeOverview>}
     * @memberof PaginatedRecipeOverviewList
     */
    results?: Array<RecipeOverview>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListEntryList
 */
export interface PaginatedShoppingListEntryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListEntryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListEntryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListEntry>}
     * @memberof PaginatedShoppingListEntryList
     */
    results?: Array<ShoppingListEntry>;
}
/**
 * 
 * @export
 * @interface PaginatedShoppingListRecipeList
 */
export interface PaginatedShoppingListRecipeList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedShoppingListRecipeList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedShoppingListRecipeList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ShoppingListRecipe>}
     * @memberof PaginatedShoppingListRecipeList
     */
    results?: Array<ShoppingListRecipe>;
}
/**
 * 
 * @export
 * @interface PaginatedStepList
 */
export interface PaginatedStepList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStepList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStepList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Step>}
     * @memberof PaginatedStepList
     */
    results?: Array<Step>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryList
 */
export interface PaginatedSupermarketCategoryList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategory>}
     * @memberof PaginatedSupermarketCategoryList
     */
    results?: Array<SupermarketCategory>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketCategoryRelationList
 */
export interface PaginatedSupermarketCategoryRelationList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof PaginatedSupermarketCategoryRelationList
     */
    results?: Array<SupermarketCategoryRelation>;
}
/**
 * 
 * @export
 * @interface PaginatedSupermarketList
 */
export interface PaginatedSupermarketList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSupermarketList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSupermarketList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Supermarket>}
     * @memberof PaginatedSupermarketList
     */
    results?: Array<Supermarket>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncList
 */
export interface PaginatedSyncList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Sync>}
     * @memberof PaginatedSyncList
     */
    results?: Array<Sync>;
}
/**
 * 
 * @export
 * @interface PaginatedSyncLogList
 */
export interface PaginatedSyncLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSyncLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSyncLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SyncLog>}
     * @memberof PaginatedSyncLogList
     */
    results?: Array<SyncLog>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitConversionList
 */
export interface PaginatedUnitConversionList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitConversionList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitConversionList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UnitConversion>}
     * @memberof PaginatedUnitConversionList
     */
    results?: Array<UnitConversion>;
}
/**
 * 
 * @export
 * @interface PaginatedUnitList
 */
export interface PaginatedUnitList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUnitList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUnitList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Unit>}
     * @memberof PaginatedUnitList
     */
    results?: Array<Unit>;
}
/**
 * 
 * @export
 * @interface PaginatedUserFileList
 */
export interface PaginatedUserFileList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserFileList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserFileList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserFile>}
     * @memberof PaginatedUserFileList
     */
    results?: Array<UserFile>;
}
/**
 * 
 * @export
 * @interface PaginatedUserSpaceList
 */
export interface PaginatedUserSpaceList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedUserSpaceList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedUserSpaceList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<UserSpace>}
     * @memberof PaginatedUserSpaceList
     */
    results?: Array<UserSpace>;
}
/**
 * 
 * @export
 * @interface PaginatedViewLogList
 */
export interface PaginatedViewLogList {
    /**
     * 
     * @type {number}
     * @memberof PaginatedViewLogList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PaginatedViewLogList
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ViewLog>}
     * @memberof PaginatedViewLogList
     */
    results?: Array<ViewLog>;
}
/**
 * 
 * @export
 * @interface ParsedIngredient
 */
export interface ParsedIngredient {
    /**
     * 
     * @type {number}
     * @memberof ParsedIngredient
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    unit: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    food: string;
    /**
     * 
     * @type {string}
     * @memberof ParsedIngredient
     */
    note: string;
}
/**
 * 
 * @export
 * @interface PatchedAccessTokenRequest
 */
export interface PatchedAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessTokenRequest
     */
    expires?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAccessTokenRequest
     */
    scope?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedAccessTokenRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedAutomationRequest
 */
export interface PatchedAutomationRequest {
    /**
     * 
     * @type {TypeEnum}
     * @memberof PatchedAutomationRequest
     */
    type?: TypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_1?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_2?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedAutomationRequest
     */
    param_3?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomationRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedAutomationRequest
     */
    disabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedAutomationRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedBookmarkletImportRequest
 */
export interface PatchedBookmarkletImportRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImportRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedBookmarkletImportRequest
     */
    html?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedBookmarkletImportRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedConnectorConfigConfigRequest
 */
export interface PatchedConnectorConfigConfigRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    url?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    token?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    todo_entity?: string | null;
    /**
     * Is Connector Enabled
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_created_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_updated_enabled?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    on_shopping_list_entry_deleted_enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedConnectorConfigConfigRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedCookLogRequest
 */
export interface PatchedCookLogRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    rating?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLogRequest
     */
    comment?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedCookLogRequest
     */
    created_at?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedCookLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedCustomFilterRequest
 */
export interface PatchedCustomFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilterRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedCustomFilterRequest
     */
    search?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedCustomFilterRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedCustomFilterRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedExportLogRequest
 */
export interface PatchedExportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLogRequest
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedExportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    exported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    cache_duration?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedExportLogRequest
     */
    possibly_not_expired?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedExportLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedFoodRequest
 */
export interface PatchedFoodRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    description?: string;
    /**
     * 
     * @type {RecipeSimpleRequest}
     * @memberof PatchedFoodRequest
     */
    recipe?: RecipeSimpleRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    url?: string | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof PatchedFoodRequest
     */
    properties?: Array<PropertyRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    properties_food_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedFoodRequest
     */
    properties_food_unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    fdc_id?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    food_onhand?: boolean | null;
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof PatchedFoodRequest
     */
    supermarket_category?: SupermarketCategoryRequest | null;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedFoodRequest
     */
    inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    ignore_shopping?: boolean;
    /**
     * 
     * @type {Array<FoodSimpleRequest>}
     * @memberof PatchedFoodRequest
     */
    substitute?: Array<FoodSimpleRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    substitute_siblings?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedFoodRequest
     */
    substitute_children?: boolean;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedFoodRequest
     */
    child_inherit_fields?: Array<FoodInheritFieldRequest> | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedFoodRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedFoodRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedImportLogRequest
 */
export interface PatchedImportLogRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLogRequest
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedImportLogRequest
     */
    msg?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedImportLogRequest
     */
    running?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    total_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    imported_recipes?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedImportLogRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedIngredientRequest
 */
export interface PatchedIngredientRequest {
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedIngredientRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedIngredientRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredientRequest
     */
    note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    is_header?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    no_amount?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedIngredientRequest
     */
    original_text?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    always_use_plural_unit?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedIngredientRequest
     */
    always_use_plural_food?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedIngredientRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedInviteLinkRequest
 */
export interface PatchedInviteLinkRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    email?: string;
    /**
     * 
     * @type {GroupRequest}
     * @memberof PatchedInviteLinkRequest
     */
    group?: GroupRequest;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    valid_until?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLinkRequest
     */
    used_by?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedInviteLinkRequest
     */
    reusable?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedInviteLinkRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedInviteLinkRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedKeywordRequest
 */
export interface PatchedKeywordRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedKeywordRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedKeywordRequest
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedKeywordRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealPlanRequest
 */
export interface PatchedMealPlanRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    title?: string;
    /**
     * 
     * @type {RecipeOverviewRequest}
     * @memberof PatchedMealPlanRequest
     */
    recipe?: RecipeOverviewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlanRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    note?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    from_date?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealPlanRequest
     */
    to_date?: string;
    /**
     * 
     * @type {MealTypeRequest}
     * @memberof PatchedMealPlanRequest
     */
    meal_type?: MealTypeRequest;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedMealPlanRequest
     */
    shared?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealPlanRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedMealTypeRequest
 */
export interface PatchedMealTypeRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedMealTypeRequest
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedMealTypeRequest
     */
    color?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedMealTypeRequest
     */
    _default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedMealTypeRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedPropertyRequest
 */
export interface PatchedPropertyRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyRequest
     */
    property_amount?: number | null;
    /**
     * 
     * @type {PropertyTypeRequest}
     * @memberof PatchedPropertyRequest
     */
    property_type?: PropertyTypeRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedPropertyTypeRequest
 */
export interface PatchedPropertyTypeRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedPropertyTypeRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedPropertyTypeRequest
     */
    fdc_id?: number | null;
}
/**
 * 
 * @export
 * @interface PatchedRecipeBookEntryRequest
 */
export interface PatchedRecipeBookEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    book?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookEntryRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeBookRequest
 */
export interface PatchedRecipeBookRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBookRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeBookRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedRecipeBookRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {CustomFilterRequest}
     * @memberof PatchedRecipeBookRequest
     */
    filter?: CustomFilterRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeBookRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedRecipeRequest
 */
export interface PatchedRecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {Array<KeywordRequest>}
     * @memberof PatchedRecipeRequest
     */
    keywords?: Array<KeywordRequest>;
    /**
     * 
     * @type {Array<StepRequest>}
     * @memberof PatchedRecipeRequest
     */
    steps?: Array<StepRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformationRequest}
     * @memberof PatchedRecipeRequest
     */
    nutrition?: NutritionInformationRequest | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof PatchedRecipeRequest
     */
    properties?: Array<PropertyRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedRecipeRequest
     */
    servings_text?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedRecipeRequest
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedRecipeRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedShoppingListEntryRequest
 */
export interface PatchedShoppingListEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedShoppingListEntryRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedShoppingListEntryRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    amount?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedShoppingListEntryRequest
     */
    checked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntryRequest
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedShoppingListEntryRequest
     */
    delay_until?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListEntryRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedShoppingListRecipeRequest
 */
export interface PatchedShoppingListRecipeRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedShoppingListRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSpaceRequest
 */
export interface PatchedSpaceRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    message?: string;
    /**
     * 
     * @type {Array<FoodInheritFieldRequest>}
     * @memberof PatchedSpaceRequest
     */
    food_inherit?: Array<FoodInheritFieldRequest>;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    image?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    nav_logo?: UserFileViewRequest | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof PatchedSpaceRequest
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    custom_space_theme?: UserFileViewRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSpaceRequest
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof PatchedSpaceRequest
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_32?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_128?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_144?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_180?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_192?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_512?: UserFileViewRequest | null;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedSpaceRequest
     */
    logo_color_svg?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSpaceRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedStepRequest
 */
export interface PatchedStepRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStepRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedStepRequest
     */
    instruction?: string;
    /**
     * 
     * @type {Array<IngredientRequest>}
     * @memberof PatchedStepRequest
     */
    ingredients?: Array<IngredientRequest>;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStepRequest
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedStepRequest
     */
    file?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedStepRequest
     */
    show_ingredients_table?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedStepRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedStorageRequest
 */
export interface PatchedStorageRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    name?: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof PatchedStorageRequest
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedStorageRequest
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedStorageRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedSupermarketCategoryRelationRequest
 */
export interface PatchedSupermarketCategoryRelationRequest {
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    category?: SupermarketCategoryRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    supermarket?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRelationRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketCategoryRequest
 */
export interface PatchedSupermarketCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategoryRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketCategoryRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketCategoryRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedSupermarketRequest
 */
export interface PatchedSupermarketRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedSupermarketRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSupermarketRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedSyncRequest
 */
export interface PatchedSyncRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedSyncRequest
     */
    storage?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedSyncRequest
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedSyncRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedSyncRequest
     */
    last_checked?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedSyncRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUnitConversionRequest
 */
export interface PatchedUnitConversionRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    base_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedUnitConversionRequest
     */
    base_unit?: UnitRequest;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    converted_amount?: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof PatchedUnitConversionRequest
     */
    converted_unit?: UnitRequest;
    /**
     * 
     * @type {FoodRequest}
     * @memberof PatchedUnitConversionRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitConversionRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitConversionRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PatchedUnitRequest
 */
export interface PatchedUnitRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PatchedUnitRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUnitRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserPreferenceRequest
 */
export interface PatchedUserPreferenceRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    user?: number;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof PatchedUserPreferenceRequest
     */
    image?: UserFileViewRequest | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof PatchedUserPreferenceRequest
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedUserPreferenceRequest
     */
    plan_share?: Array<UserRequest> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_share?: Array<UserRequest> | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserPreferenceRequest
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserPreferenceRequest
     */
    show_step_ingredients?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserRequest
 */
export interface PatchedUserRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserRequest
     */
    last_name?: string;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PatchedUserSpaceRequest
 */
export interface PatchedUserSpaceRequest {
    /**
     * 
     * @type {Array<GroupRequest>}
     * @memberof PatchedUserSpaceRequest
     */
    groups?: Array<GroupRequest>;
    /**
     * 
     * @type {boolean}
     * @memberof PatchedUserSpaceRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PatchedUserSpaceRequest
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PatchedUserSpaceRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface PatchedViewLogRequest
 */
export interface PatchedViewLogRequest {
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLogRequest
     */
    recipe?: number;
    /**
     * 
     * @type {number}
     * @memberof PatchedViewLogRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Property
 */
export interface Property {
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Property
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyType}
     * @memberof Property
     */
    property_type: PropertyType;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface PropertyRequest
 */
export interface PropertyRequest {
    /**
     * 
     * @type {number}
     * @memberof PropertyRequest
     */
    property_amount: number | null;
    /**
     * 
     * @type {PropertyTypeRequest}
     * @memberof PropertyRequest
     */
    property_type: PropertyTypeRequest;
    /**
     * 
     * @type {number}
     * @memberof PropertyRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyType
 */
export interface PropertyType {
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyType
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyType
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface PropertyTypeRequest
 */
export interface PropertyTypeRequest {
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    order?: number;
    /**
     * 
     * @type {string}
     * @memberof PropertyTypeRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof PropertyTypeRequest
     */
    fdc_id?: number | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface Recipe
 */
export interface Recipe {
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    image: string | null;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof Recipe
     */
    keywords?: Array<Keyword>;
    /**
     * 
     * @type {Array<Step>}
     * @memberof Recipe
     */
    steps: Array<Step>;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    waiting_time?: number;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformation}
     * @memberof Recipe
     */
    nutrition?: NutritionInformation | null;
    /**
     * 
     * @type {Array<Property>}
     * @memberof Recipe
     */
    properties?: Array<Property>;
    /**
     * 
     * @type {any}
     * @memberof Recipe
     */
    food_properties: any | null;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    servings_text?: string;
    /**
     * 
     * @type {number}
     * @memberof Recipe
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof Recipe
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof Recipe
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof Recipe
     */
    shared?: Array<User>;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBook
 */
export interface RecipeBook {
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBook
     */
    description?: string;
    /**
     * 
     * @type {Array<User>}
     * @memberof RecipeBook
     */
    shared: Array<User>;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    created_by: number;
    /**
     * 
     * @type {CustomFilter}
     * @memberof RecipeBook
     */
    filter?: CustomFilter | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBook
     */
    order?: number;
}
/**
 * 
 * @export
 * @interface RecipeBookEntry
 */
export interface RecipeBookEntry {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    book: number;
    /**
     * 
     * @type {RecipeBook}
     * @memberof RecipeBookEntry
     */
    book_content: RecipeBook;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntry
     */
    recipe: number;
    /**
     * 
     * @type {RecipeOverview}
     * @memberof RecipeBookEntry
     */
    recipe_content: RecipeOverview;
}
/**
 * 
 * @export
 * @interface RecipeBookEntryRequest
 */
export interface RecipeBookEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    book: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookEntryRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeBookRequest
 */
export interface RecipeBookRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeBookRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeBookRequest
     */
    description?: string;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof RecipeBookRequest
     */
    shared: Array<UserRequest>;
    /**
     * 
     * @type {CustomFilterRequest}
     * @memberof RecipeBookRequest
     */
    filter?: CustomFilterRequest | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeBookRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeFlat
 */
export interface RecipeFlat {
    /**
     * 
     * @type {number}
     * @memberof RecipeFlat
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeFlat
     */
    image?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeImage
 */
export interface RecipeImage {
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeImage
     */
    image_url?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverview
 */
export interface RecipeOverview {
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    image: string | null;
    /**
     * 
     * @type {Array<KeywordLabel>}
     * @memberof RecipeOverview
     */
    keywords: Array<KeywordLabel>;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    working_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    waiting_time: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    updated_at: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    internal: boolean;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    servings_text: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverview
     */
    rating: number | null;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    last_cooked: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeOverview
     */
    _new: boolean;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverview
     */
    recent: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeOverviewRequest
 */
export interface RecipeOverviewRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeOverviewRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeOverviewRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeOverviewRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeRequest
 */
export interface RecipeRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    description?: string | null;
    /**
     * 
     * @type {Array<KeywordRequest>}
     * @memberof RecipeRequest
     */
    keywords?: Array<KeywordRequest>;
    /**
     * 
     * @type {Array<StepRequest>}
     * @memberof RecipeRequest
     */
    steps: Array<StepRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    working_time?: number;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    waiting_time?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    source_url?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    internal?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    show_ingredient_overview?: boolean;
    /**
     * 
     * @type {NutritionInformationRequest}
     * @memberof RecipeRequest
     */
    nutrition?: NutritionInformationRequest | null;
    /**
     * 
     * @type {Array<PropertyRequest>}
     * @memberof RecipeRequest
     */
    properties?: Array<PropertyRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    servings?: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    file_path?: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeRequest
     */
    servings_text?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RecipeRequest
     */
    _private?: boolean;
    /**
     * 
     * @type {Array<UserRequest>}
     * @memberof RecipeRequest
     */
    shared?: Array<UserRequest>;
    /**
     * 
     * @type {number}
     * @memberof RecipeRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdate
 */
export interface RecipeShoppingUpdate {
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdate
     */
    id: number;
}
/**
 * 
 * @export
 * @interface RecipeShoppingUpdateRequest
 */
export interface RecipeShoppingUpdateRequest {
    /**
     * Existing shopping list to update
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    list_recipe?: number | null;
    /**
     * List of ingredient IDs from the recipe to add, if not provided all ingredients will be added.
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    ingredients?: number | null;
    /**
     * Providing a list_recipe ID and servings of 0 will delete that shopping list.
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    servings?: number | null;
    /**
     * 
     * @type {number}
     * @memberof RecipeShoppingUpdateRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimple
 */
export interface RecipeSimple {
    /**
     * 
     * @type {number}
     * @memberof RecipeSimple
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RecipeSimple
     */
    url: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface RecipeSimpleRequest
 */
export interface RecipeSimpleRequest {
    /**
     * 
     * @type {string}
     * @memberof RecipeSimpleRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof RecipeSimpleRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ShareLink
 */
export interface ShareLink {
    /**
     * 
     * @type {number}
     * @memberof ShareLink
     */
    pk: number;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    share: string;
    /**
     * 
     * @type {string}
     * @memberof ShareLink
     */
    link: string;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntry
 */
export interface ShoppingListEntry {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {Food}
     * @memberof ShoppingListEntry
     */
    food: Food | null;
    /**
     * 
     * @type {Unit}
     * @memberof ShoppingListEntry
     */
    unit?: Unit | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntry
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntry
     */
    checked?: boolean;
    /**
     * 
     * @type {ShoppingListRecipe}
     * @memberof ShoppingListEntry
     */
    recipe_mealplan: ShoppingListRecipe;
    /**
     * 
     * @type {User}
     * @memberof ShoppingListEntry
     */
    created_by: User;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    updated_at: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntry
     */
    delay_until?: string | null;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulk
 */
export interface ShoppingListEntryBulk {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulk
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulk
     */
    checked: boolean;
}
/**
 * 
 * @export
 * @interface ShoppingListEntryBulkRequest
 */
export interface ShoppingListEntryBulkRequest {
    /**
     * 
     * @type {Array<any>}
     * @memberof ShoppingListEntryBulkRequest
     */
    ids: Array<any>;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryBulkRequest
     */
    checked: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface ShoppingListEntryRequest
 */
export interface ShoppingListEntryRequest {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    list_recipe?: number | null;
    /**
     * 
     * @type {FoodRequest}
     * @memberof ShoppingListEntryRequest
     */
    food: FoodRequest | null;
    /**
     * 
     * @type {UnitRequest}
     * @memberof ShoppingListEntryRequest
     */
    unit?: UnitRequest | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ShoppingListEntryRequest
     */
    checked?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntryRequest
     */
    completed_at?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListEntryRequest
     */
    delay_until?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListEntryRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipe
 */
export interface ShoppingListRecipe {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    recipe_name: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipe
     */
    servings: number;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_note: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_from_date: string;
    /**
     * 
     * @type {string}
     * @memberof ShoppingListRecipe
     */
    mealplan_type: string;
}
/**
 * 
 * @export
 * @interface ShoppingListRecipeRequest
 */
export interface ShoppingListRecipeRequest {
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    recipe?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    mealplan?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    servings: number;
    /**
     * 
     * @type {number}
     * @memberof ShoppingListRecipeRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface Space
 */
export interface Space {
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    created_by: number | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    message?: string;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_recipes: number;
    /**
     * Maximum file storage for space in MB. 0 for unlimited, -1 to disable file upload.
     * @type {number}
     * @memberof Space
     */
    max_file_storage_mb: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    max_users: number;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    allow_sharing: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Space
     */
    demo: boolean;
    /**
     * 
     * @type {Array<FoodInheritField>}
     * @memberof Space
     */
    food_inherit: Array<FoodInheritField>;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    user_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    recipe_count: number;
    /**
     * 
     * @type {number}
     * @memberof Space
     */
    file_size_mb: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    nav_logo?: UserFileView | null;
    /**
     * 
     * @type {SpaceThemeEnum}
     * @memberof Space
     */
    space_theme?: SpaceThemeEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    custom_space_theme?: UserFileView | null;
    /**
     * 
     * @type {string}
     * @memberof Space
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {SpaceNavTextColorEnum}
     * @memberof Space
     */
    nav_text_color?: SpaceNavTextColorEnum;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_32?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_128?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_144?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_180?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_192?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_512?: UserFileView | null;
    /**
     * 
     * @type {UserFileView}
     * @memberof Space
     */
    logo_color_svg?: UserFileView | null;
}
/**
 * * `BLANK` - ------- * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum SpaceNavTextColorEnum {
    Blank = 'BLANK',
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * * `BLANK` - ------- * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum SpaceThemeEnum {
    Blank = 'BLANK',
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface Step
 */
export interface Step {
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instruction?: string;
    /**
     * 
     * @type {Array<Ingredient>}
     * @memberof Step
     */
    ingredients: Array<Ingredient>;
    /**
     * 
     * @type {string}
     * @memberof Step
     */
    instructions_markdown: string;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileView}
     * @memberof Step
     */
    file?: UserFileView | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {any}
     * @memberof Step
     */
    step_recipe_data: any | null;
    /**
     * 
     * @type {number}
     * @memberof Step
     */
    numrecipe: number;
    /**
     * 
     * @type {boolean}
     * @memberof Step
     */
    show_ingredients_table?: boolean;
}
/**
 * Adds nested create feature
 * @export
 * @interface StepRequest
 */
export interface StepRequest {
    /**
     * 
     * @type {string}
     * @memberof StepRequest
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StepRequest
     */
    instruction?: string;
    /**
     * 
     * @type {Array<IngredientRequest>}
     * @memberof StepRequest
     */
    ingredients: Array<IngredientRequest>;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    time?: number;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StepRequest
     */
    show_as_header?: boolean;
    /**
     * 
     * @type {UserFileViewRequest}
     * @memberof StepRequest
     */
    file?: UserFileViewRequest | null;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    step_recipe?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof StepRequest
     */
    show_ingredients_table?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StepRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface Storage
 */
export interface Storage {
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof Storage
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof Storage
     */
    username?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Storage
     */
    created_by: number;
}
/**
 * 
 * @export
 * @interface StorageRequest
 */
export interface StorageRequest {
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    name: string;
    /**
     * 
     * @type {MethodEnum}
     * @memberof StorageRequest
     */
    method?: MethodEnum;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    username?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    password?: string | null;
    /**
     * 
     * @type {string}
     * @memberof StorageRequest
     */
    token?: string | null;
    /**
     * 
     * @type {number}
     * @memberof StorageRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Supermarket
 */
export interface Supermarket {
    /**
     * 
     * @type {number}
     * @memberof Supermarket
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    description?: string | null;
    /**
     * 
     * @type {Array<SupermarketCategoryRelation>}
     * @memberof Supermarket
     */
    category_to_supermarket: Array<SupermarketCategoryRelation>;
    /**
     * 
     * @type {string}
     * @memberof Supermarket
     */
    open_data_slug?: string | null;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategory
 */
export interface SupermarketCategory {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategory
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategory
     */
    description?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelation
 */
export interface SupermarketCategoryRelation {
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    id: number;
    /**
     * 
     * @type {SupermarketCategory}
     * @memberof SupermarketCategoryRelation
     */
    category: SupermarketCategory;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelation
     */
    order?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface SupermarketCategoryRelationRequest
 */
export interface SupermarketCategoryRelationRequest {
    /**
     * 
     * @type {SupermarketCategoryRequest}
     * @memberof SupermarketCategoryRelationRequest
     */
    category: SupermarketCategoryRequest;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    supermarket: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRelationRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketCategoryRequest
 */
export interface SupermarketCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategoryRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketCategoryRequest
     */
    description?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SupermarketCategoryRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface SupermarketRequest
 */
export interface SupermarketRequest {
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SupermarketRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SupermarketRequest
     */
    id?: number;
}
/**
 * 
 * @export
 * @interface Sync
 */
export interface Sync {
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof Sync
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Sync
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    last_checked?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof Sync
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface SyncLog
 */
export interface SyncLog {
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof SyncLog
     */
    sync: number;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    status: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    msg?: string;
    /**
     * 
     * @type {string}
     * @memberof SyncLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface SyncRequest
 */
export interface SyncRequest {
    /**
     * 
     * @type {number}
     * @memberof SyncRequest
     */
    storage: number;
    /**
     * 
     * @type {string}
     * @memberof SyncRequest
     */
    path?: string;
    /**
     * 
     * @type {boolean}
     * @memberof SyncRequest
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SyncRequest
     */
    last_checked?: string | null;
    /**
     * 
     * @type {number}
     * @memberof SyncRequest
     */
    id?: number;
}
/**
 * * `TANDOOR` - Tandoor * `BOOTSTRAP` - Bootstrap * `DARKLY` - Darkly * `FLATLY` - Flatly * `SUPERHERO` - Superhero * `TANDOOR_DARK` - Tandoor Dark (INCOMPLETE)
 * @export
 * @enum {string}
 */
export enum ThemeEnum {
    Tandoor = 'TANDOOR',
    Bootstrap = 'BOOTSTRAP',
    Darkly = 'DARKLY',
    Flatly = 'FLATLY',
    Superhero = 'SUPERHERO',
    TandoorDark = 'TANDOOR_DARK'
}

/**
 * * `FOOD_ALIAS` - Food Alias * `UNIT_ALIAS` - Unit Alias * `KEYWORD_ALIAS` - Keyword Alias * `DESCRIPTION_REPLACE` - Description Replace * `INSTRUCTION_REPLACE` - Instruction Replace * `NEVER_UNIT` - Never Unit * `TRANSPOSE_WORDS` - Transpose Words * `FOOD_REPLACE` - Food Replace * `UNIT_REPLACE` - Unit Replace * `NAME_REPLACE` - Name Replace
 * @export
 * @enum {string}
 */
export enum TypeEnum {
    FoodAlias = 'FOOD_ALIAS',
    UnitAlias = 'UNIT_ALIAS',
    KeywordAlias = 'KEYWORD_ALIAS',
    DescriptionReplace = 'DESCRIPTION_REPLACE',
    InstructionReplace = 'INSTRUCTION_REPLACE',
    NeverUnit = 'NEVER_UNIT',
    TransposeWords = 'TRANSPOSE_WORDS',
    FoodReplace = 'FOOD_REPLACE',
    UnitReplace = 'UNIT_REPLACE',
    NameReplace = 'NAME_REPLACE'
}

/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface Unit
 */
export interface Unit {
    /**
     * 
     * @type {number}
     * @memberof Unit
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Unit
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversion
 */
export interface UnitConversion {
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    base_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    base_unit: Unit;
    /**
     * 
     * @type {number}
     * @memberof UnitConversion
     */
    converted_amount: number;
    /**
     * 
     * @type {Unit}
     * @memberof UnitConversion
     */
    converted_unit: Unit;
    /**
     * 
     * @type {Food}
     * @memberof UnitConversion
     */
    food?: Food | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversion
     */
    open_data_slug?: string | null;
}
/**
 * Adds nested create feature
 * @export
 * @interface UnitConversionRequest
 */
export interface UnitConversionRequest {
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    base_amount: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof UnitConversionRequest
     */
    base_unit: UnitRequest;
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    converted_amount: number;
    /**
     * 
     * @type {UnitRequest}
     * @memberof UnitConversionRequest
     */
    converted_unit: UnitRequest;
    /**
     * 
     * @type {FoodRequest}
     * @memberof UnitConversionRequest
     */
    food?: FoodRequest | null;
    /**
     * 
     * @type {string}
     * @memberof UnitConversionRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UnitConversionRequest
     */
    id?: number;
}
/**
 * Moves `UniqueValidator`\'s from the validation stage to the save stage. It solves the problem with nested validation for unique fields on update.  If you want more details, you can read related issues and articles: https://github.com/beda-software/drf-writable-nested/issues/1 http://www.django-rest-framework.org/api-guide/validators/#updating-nested-serializers  Example of usage: ```     class Child(models.Model):     field = models.CharField(unique=True)   class Parent(models.Model):     child = models.ForeignKey(\'Child\')   class ChildSerializer(UniqueFieldsMixin, serializers.ModelSerializer):     class Meta:         model = Child   class ParentSerializer(NestedUpdateMixin, serializers.ModelSerializer):     child = ChildSerializer()      class Meta:         model = Parent ```  Note: `UniqueFieldsMixin` must be applied only on the serializer which has unique fields.  Note: When you are using both mixins (`UniqueFieldsMixin` and `NestedCreateMixin` or `NestedUpdateMixin`) you should put `UniqueFieldsMixin` ahead.
 * @export
 * @interface UnitRequest
 */
export interface UnitRequest {
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    plural_name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    description?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    base_unit?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UnitRequest
     */
    open_data_slug?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UnitRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id: number;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    display_name: string;
}
/**
 * 
 * @export
 * @interface UserFile
 */
export interface UserFile {
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFile
     */
    preview: string;
    /**
     * 
     * @type {number}
     * @memberof UserFile
     */
    file_size_kb: number;
}
/**
 * 
 * @export
 * @interface UserFileView
 */
export interface UserFileView {
    /**
     * 
     * @type {number}
     * @memberof UserFileView
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    file_download: string;
    /**
     * 
     * @type {string}
     * @memberof UserFileView
     */
    preview: string;
}
/**
 * 
 * @export
 * @interface UserFileViewRequest
 */
export interface UserFileViewRequest {
    /**
     * 
     * @type {string}
     * @memberof UserFileViewRequest
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof UserFileViewRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserPreference
 */
export interface UserPreference {
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    user: number;
    /**
     * 
     * @type {UserFileView}
     * @memberof UserPreference
     */
    image?: UserFileView | null;
    /**
     * 
     * @type {ThemeEnum}
     * @memberof UserPreference
     */
    theme?: ThemeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    nav_bg_color?: string;
    /**
     * 
     * @type {UserPreferenceNavTextColorEnum}
     * @memberof UserPreference
     */
    nav_text_color?: UserPreferenceNavTextColorEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_show_logo?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    default_unit?: string;
    /**
     * 
     * @type {DefaultPageEnum}
     * @memberof UserPreference
     */
    default_page?: DefaultPageEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_fractions?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    use_kj?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    plan_share?: Array<User> | null;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    nav_sticky?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    ingredient_decimals?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    comments?: boolean;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_auto_sync?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoadd_shopping?: boolean;
    /**
     * 
     * @type {FoodInheritField}
     * @memberof UserPreference
     */
    food_inherit_default: FoodInheritField;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    default_delay?: number;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoinclude_related?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    mealplan_autoexclude_onhand?: boolean;
    /**
     * 
     * @type {Array<User>}
     * @memberof UserPreference
     */
    shopping_share?: Array<User> | null;
    /**
     * 
     * @type {number}
     * @memberof UserPreference
     */
    shopping_recent_days?: number;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_delim?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPreference
     */
    csv_prefix?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    filter_to_supermarket?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    shopping_add_onhand?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    left_handed?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    show_step_ingredients?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreference
     */
    food_children_exist: boolean;
}
/**
 * * `LIGHT` - Light * `DARK` - Dark
 * @export
 * @enum {string}
 */
export enum UserPreferenceNavTextColorEnum {
    Light = 'LIGHT',
    Dark = 'DARK'
}

/**
 * Adds nested create feature
 * @export
 * @interface UserRequest
 */
export interface UserRequest {
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof UserRequest
     */
    last_name?: string;
    /**
     * 
     * @type {number}
     * @memberof UserRequest
     */
    id?: number;
}
/**
 * Adds nested create feature
 * @export
 * @interface UserSpace
 */
export interface UserSpace {
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    id: number;
    /**
     * 
     * @type {User}
     * @memberof UserSpace
     */
    user: User;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    space: number;
    /**
     * 
     * @type {Array<Group>}
     * @memberof UserSpace
     */
    groups: Array<Group>;
    /**
     * 
     * @type {boolean}
     * @memberof UserSpace
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    internal_note?: string | null;
    /**
     * 
     * @type {number}
     * @memberof UserSpace
     */
    invite_link: number | null;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    created_at: string;
    /**
     * 
     * @type {string}
     * @memberof UserSpace
     */
    updated_at: string;
}
/**
 * 
 * @export
 * @interface ViewLog
 */
export interface ViewLog {
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLog
     */
    created_by: number;
    /**
     * 
     * @type {string}
     * @memberof ViewLog
     */
    created_at: string;
}
/**
 * 
 * @export
 * @interface ViewLogRequest
 */
export interface ViewLogRequest {
    /**
     * 
     * @type {number}
     * @memberof ViewLogRequest
     */
    recipe: number;
    /**
     * 
     * @type {number}
     * @memberof ViewLogRequest
     */
    id?: number;
}

/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenCreate: async (accessTokenRequest: AccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accessTokenRequest' is not null or undefined
            assertParamExists('apiAccessTokenCreate', 'accessTokenRequest', accessTokenRequest)
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenDestroy', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/access-token/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenPartialUpdate: async (id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenPartialUpdate', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenRetrieve', 'id', id)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenUpdate: async (id: number, accessTokenRequest: AccessTokenRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAccessTokenUpdate', 'id', id)
            // verify required parameter 'accessTokenRequest' is not null or undefined
            assertParamExists('apiAccessTokenUpdate', 'accessTokenRequest', accessTokenRequest)
            const localVarPath = `/api/access-token/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutoPlanCreate: async (autoMealPlanRequest: AutoMealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'autoMealPlanRequest' is not null or undefined
            assertParamExists('apiAutoPlanCreate', 'autoMealPlanRequest', autoMealPlanRequest)
            const localVarPath = `/api/auto-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoMealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationCreate: async (automationRequest: AutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'automationRequest' is not null or undefined
            assertParamExists('apiAutomationCreate', 'automationRequest', automationRequest)
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationDestroy', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationList: async (page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/automation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationPartialUpdate: async (id: number, patchedAutomationRequest?: PatchedAutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationPartialUpdate', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedAutomationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationRetrieve', 'id', id)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationUpdate: async (id: number, automationRequest: AutomationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiAutomationUpdate', 'id', id)
            // verify required parameter 'automationRequest' is not null or undefined
            assertParamExists('apiAutomationUpdate', 'automationRequest', automationRequest)
            const localVarPath = `/api/automation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(automationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportCreate: async (bookmarkletImportRequest: BookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'bookmarkletImportRequest' is not null or undefined
            assertParamExists('apiBookmarkletImportCreate', 'bookmarkletImportRequest', bookmarkletImportRequest)
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportDestroy', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/bookmarklet-import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportPartialUpdate: async (id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportPartialUpdate', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedBookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportRetrieve', 'id', id)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportUpdate: async (id: number, bookmarkletImportRequest: BookmarkletImportRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiBookmarkletImportUpdate', 'id', id)
            // verify required parameter 'bookmarkletImportRequest' is not null or undefined
            assertParamExists('apiBookmarkletImportUpdate', 'bookmarkletImportRequest', bookmarkletImportRequest)
            const localVarPath = `/api/bookmarklet-import/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bookmarkletImportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigCreate: async (connectorConfigConfigRequest: ConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'connectorConfigConfigRequest' is not null or undefined
            assertParamExists('apiConnectorConfigCreate', 'connectorConfigConfigRequest', connectorConfigConfigRequest)
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigDestroy', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/connector-config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigPartialUpdate: async (id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigPartialUpdate', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedConnectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigRetrieve', 'id', id)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigUpdate: async (id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiConnectorConfigUpdate', 'id', id)
            // verify required parameter 'connectorConfigConfigRequest' is not null or undefined
            assertParamExists('apiConnectorConfigUpdate', 'connectorConfigConfigRequest', connectorConfigConfigRequest)
            const localVarPath = `/api/connector-config/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectorConfigConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogCreate: async (cookLogRequest: CookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'cookLogRequest' is not null or undefined
            assertParamExists('apiCookLogCreate', 'cookLogRequest', cookLogRequest)
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogDestroy', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogList: async (page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/cook-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogPartialUpdate: async (id: number, patchedCookLogRequest?: PatchedCookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogPartialUpdate', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogRetrieve', 'id', id)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogUpdate: async (id: number, cookLogRequest: CookLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCookLogUpdate', 'id', id)
            // verify required parameter 'cookLogRequest' is not null or undefined
            assertParamExists('apiCookLogUpdate', 'cookLogRequest', cookLogRequest)
            const localVarPath = `/api/cook-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cookLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterCreate: async (customFilterRequest: CustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'customFilterRequest' is not null or undefined
            assertParamExists('apiCustomFilterCreate', 'customFilterRequest', customFilterRequest)
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterDestroy', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/custom-filter/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (type) {
                localVarQueryParameter['type'] = type;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterPartialUpdate: async (id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterPartialUpdate', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedCustomFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterRetrieve', 'id', id)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterUpdate: async (id: number, customFilterRequest: CustomFilterRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiCustomFilterUpdate', 'id', id)
            // verify required parameter 'customFilterRequest' is not null or undefined
            assertParamExists('apiCustomFilterUpdate', 'customFilterRequest', customFilterRequest)
            const localVarPath = `/api/custom-filter/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDownloadFileRetrieve: async (fileId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists('apiDownloadFileRetrieve', 'fileId', fileId)
            const localVarPath = `/api/download-file/{fileId}/`
                .replace(`{${"fileId"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogCreate: async (exportLogRequest: ExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportLogRequest' is not null or undefined
            assertParamExists('apiExportLogCreate', 'exportLogRequest', exportLogRequest)
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogDestroy', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/export-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogPartialUpdate: async (id: number, patchedExportLogRequest?: PatchedExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogPartialUpdate', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedExportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogRetrieve', 'id', id)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogUpdate: async (id: number, exportLogRequest: ExportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiExportLogUpdate', 'id', id)
            // verify required parameter 'exportLogRequest' is not null or undefined
            assertParamExists('apiExportLogUpdate', 'exportLogRequest', exportLogRequest)
            const localVarPath = `/api/export-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodCreate: async (foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('apiFoodCreate', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodDestroy', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodFdcCreate: async (id: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodFdcCreate', 'id', id)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('apiFoodFdcCreate', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/fdc/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-inherit-field/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodInheritFieldRetrieve', 'id', id)
            const localVarPath = `/api/food-inherit-field/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMergeUpdate: async (id: number, target: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'target', target)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('apiFoodMergeUpdate', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMoveUpdate: async (id: number, parent: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'parent', parent)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('apiFoodMoveUpdate', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPartialUpdate: async (id: number, patchedFoodRequest?: PatchedFoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPartialUpdate', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedFoodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyCreate: async (propertyRequest: PropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyRequest' is not null or undefined
            assertParamExists('apiFoodPropertyCreate', 'propertyRequest', propertyRequest)
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyDestroy', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyPartialUpdate: async (id: number, patchedPropertyRequest?: PatchedPropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyPartialUpdate', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyRetrieve', 'id', id)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeCreate: async (propertyTypeRequest: PropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'propertyTypeRequest' is not null or undefined
            assertParamExists('apiFoodPropertyTypeCreate', 'propertyTypeRequest', propertyTypeRequest)
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeDestroy', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeList: async (category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/food-property-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (category) {
                localVarQueryParameter['category'] = category;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypePartialUpdate: async (id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypePartialUpdate', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedPropertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeRetrieve', 'id', id)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeUpdate: async (id: number, propertyTypeRequest: PropertyTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyTypeUpdate', 'id', id)
            // verify required parameter 'propertyTypeRequest' is not null or undefined
            assertParamExists('apiFoodPropertyTypeUpdate', 'propertyTypeRequest', propertyTypeRequest)
            const localVarPath = `/api/food-property-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyUpdate: async (id: number, propertyRequest: PropertyRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodPropertyUpdate', 'id', id)
            // verify required parameter 'propertyRequest' is not null or undefined
            assertParamExists('apiFoodPropertyUpdate', 'propertyRequest', propertyRequest)
            const localVarPath = `/api/food-property/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propertyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodRetrieve', 'id', id)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodShoppingUpdate: async (id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodShoppingUpdate', 'id', id)
            // verify required parameter 'foodShoppingUpdateRequest' is not null or undefined
            assertParamExists('apiFoodShoppingUpdate', 'foodShoppingUpdateRequest', foodShoppingUpdateRequest)
            const localVarPath = `/api/food/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodShoppingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodUpdate: async (id: number, foodRequest: FoodRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiFoodUpdate', 'id', id)
            // verify required parameter 'foodRequest' is not null or undefined
            assertParamExists('apiFoodUpdate', 'foodRequest', foodRequest)
            const localVarPath = `/api/food/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(foodRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGetExternalFileLinkRetrieve: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('apiGetExternalFileLinkRetrieve', 'recipeId', recipeId)
            const localVarPath = `/api/get_external_file_link/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGetRecipeFileRetrieve: async (recipeId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeId' is not null or undefined
            assertParamExists('apiGetRecipeFileRetrieve', 'recipeId', recipeId)
            const localVarPath = `/api/get_recipe_file/{recipeId}/`
                .replace(`{${"recipeId"}}`, encodeURIComponent(String(recipeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/group/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiGroupRetrieve', 'id', id)
            const localVarPath = `/api/group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogCreate: async (importLogRequest: ImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'importLogRequest' is not null or undefined
            assertParamExists('apiImportLogCreate', 'importLogRequest', importLogRequest)
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogDestroy', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/import-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogPartialUpdate: async (id: number, patchedImportLogRequest?: PatchedImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogPartialUpdate', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedImportLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogRetrieve', 'id', id)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogUpdate: async (id: number, importLogRequest: ImportLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiImportLogUpdate', 'id', id)
            // verify required parameter 'importLogRequest' is not null or undefined
            assertParamExists('apiImportLogUpdate', 'importLogRequest', importLogRequest)
            const localVarPath = `/api/import-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(importLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientCreate: async (ingredientRequest: IngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientRequest' is not null or undefined
            assertParamExists('apiIngredientCreate', 'ingredientRequest', ingredientRequest)
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientDestroy', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientFromStringCreate: async (ingredientStringRequest: IngredientStringRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'ingredientStringRequest' is not null or undefined
            assertParamExists('apiIngredientFromStringCreate', 'ingredientStringRequest', ingredientStringRequest)
            const localVarPath = `/api/ingredient-from-string/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientStringRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientList: async (food?: number, page?: number, pageSize?: number, unit?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/ingredient/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (food !== undefined) {
                localVarQueryParameter['food'] = food;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientPartialUpdate: async (id: number, patchedIngredientRequest?: PatchedIngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientPartialUpdate', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedIngredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientRetrieve', 'id', id)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientUpdate: async (id: number, ingredientRequest: IngredientRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiIngredientUpdate', 'id', id)
            // verify required parameter 'ingredientRequest' is not null or undefined
            assertParamExists('apiIngredientUpdate', 'ingredientRequest', ingredientRequest)
            const localVarPath = `/api/ingredient/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ingredientRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkCreate: async (inviteLinkRequest: InviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'inviteLinkRequest' is not null or undefined
            assertParamExists('apiInviteLinkCreate', 'inviteLinkRequest', inviteLinkRequest)
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkDestroy', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkList: async (internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/invite-link/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkPartialUpdate: async (id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkPartialUpdate', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedInviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkRetrieve', 'id', id)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkUpdate: async (id: number, inviteLinkRequest: InviteLinkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiInviteLinkUpdate', 'id', id)
            // verify required parameter 'inviteLinkRequest' is not null or undefined
            assertParamExists('apiInviteLinkUpdate', 'inviteLinkRequest', inviteLinkRequest)
            const localVarPath = `/api/invite-link/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inviteLinkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordCreate: async (keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('apiKeywordCreate', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordDestroy', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/keyword/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (root !== undefined) {
                localVarQueryParameter['root'] = root;
            }

            if (tree !== undefined) {
                localVarQueryParameter['tree'] = tree;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMergeUpdate: async (id: number, target: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'target', target)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('apiKeywordMergeUpdate', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMoveUpdate: async (id: number, parent: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'id', id)
            // verify required parameter 'parent' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'parent', parent)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('apiKeywordMoveUpdate', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/move/{parent}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent"}}`, encodeURIComponent(String(parent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordPartialUpdate: async (id: number, patchedKeywordRequest?: PatchedKeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordPartialUpdate', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedKeywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordRetrieve', 'id', id)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordUpdate: async (id: number, keywordRequest: KeywordRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiKeywordUpdate', 'id', id)
            // verify required parameter 'keywordRequest' is not null or undefined
            assertParamExists('apiKeywordUpdate', 'keywordRequest', keywordRequest)
            const localVarPath = `/api/keyword/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanCreate: async (mealPlanRequest: MealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealPlanRequest' is not null or undefined
            assertParamExists('apiMealPlanCreate', 'mealPlanRequest', mealPlanRequest)
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanDestroy', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanIcalRetrieve: async (fromDate?: string, mealType?: Array<string>, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/ical/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanList: async (fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-plan/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (fromDate !== undefined) {
                localVarQueryParameter['from_date'] = fromDate;
            }

            if (mealType) {
                localVarQueryParameter['meal_type'] = mealType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (toDate !== undefined) {
                localVarQueryParameter['to_date'] = toDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanPartialUpdate: async (id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanPartialUpdate', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanRetrieve', 'id', id)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanUpdate: async (id: number, mealPlanRequest: MealPlanRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealPlanUpdate', 'id', id)
            // verify required parameter 'mealPlanRequest' is not null or undefined
            assertParamExists('apiMealPlanUpdate', 'mealPlanRequest', mealPlanRequest)
            const localVarPath = `/api/meal-plan/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealPlanRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeCreate: async (mealTypeRequest: MealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mealTypeRequest' is not null or undefined
            assertParamExists('apiMealTypeCreate', 'mealTypeRequest', mealTypeRequest)
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeDestroy', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/meal-type/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypePartialUpdate: async (id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypePartialUpdate', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedMealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeRetrieve', 'id', id)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeUpdate: async (id: number, mealTypeRequest: MealTypeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiMealTypeUpdate', 'id', id)
            // verify required parameter 'mealTypeRequest' is not null or undefined
            assertParamExists('apiMealTypeUpdate', 'mealTypeRequest', mealTypeRequest)
            const localVarPath = `/api/meal-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mealTypeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookCreate: async (recipeBookRequest: RecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookRequest' is not null or undefined
            assertParamExists('apiRecipeBookCreate', 'recipeBookRequest', recipeBookRequest)
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookDestroy', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryCreate: async (recipeBookEntryRequest: RecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeBookEntryRequest' is not null or undefined
            assertParamExists('apiRecipeBookEntryCreate', 'recipeBookEntryRequest', recipeBookEntryRequest)
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryDestroy', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryList: async (book?: number, page?: number, pageSize?: number, recipe?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (book !== undefined) {
                localVarQueryParameter['book'] = book;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (recipe !== undefined) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryPartialUpdate: async (id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryPartialUpdate', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryRetrieve', 'id', id)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryUpdate: async (id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookEntryUpdate', 'id', id)
            // verify required parameter 'recipeBookEntryRequest' is not null or undefined
            assertParamExists('apiRecipeBookEntryUpdate', 'recipeBookEntryRequest', recipeBookEntryRequest)
            const localVarPath = `/api/recipe-book-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookList: async (limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-book/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderDirection !== undefined) {
                localVarQueryParameter['order_direction'] = orderDirection;
            }

            if (orderField !== undefined) {
                localVarQueryParameter['order_field'] = orderField;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookPartialUpdate: async (id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookPartialUpdate', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookRetrieve', 'id', id)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookUpdate: async (id: number, recipeBookRequest: RecipeBookRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeBookUpdate', 'id', id)
            // verify required parameter 'recipeBookRequest' is not null or undefined
            assertParamExists('apiRecipeBookUpdate', 'recipeBookRequest', recipeBookRequest)
            const localVarPath = `/api/recipe-book/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeBookRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeCreate: async (recipeRequest: RecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'recipeRequest' is not null or undefined
            assertParamExists('apiRecipeCreate', 'recipeRequest', recipeRequest)
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeDestroy', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFlatList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/flat/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFromSourceCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe-from-source/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeImageUpdate: async (id: number, image?: any, imageUrl?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeImageUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/image/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
            if (imageUrl !== undefined) { 
                localVarFormParams.append('image_url', imageUrl as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeList: async (books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (books) {
                localVarQueryParameter['books'] = books;
            }

            if (booksAnd) {
                localVarQueryParameter['books_and'] = booksAnd;
            }

            if (booksAndNot) {
                localVarQueryParameter['books_and_not'] = booksAndNot;
            }

            if (booksOr) {
                localVarQueryParameter['books_or'] = booksOr;
            }

            if (booksOrNot) {
                localVarQueryParameter['books_or_not'] = booksOrNot;
            }

            if (cookedon !== undefined) {
                localVarQueryParameter['cookedon'] = cookedon;
            }

            if (createdon !== undefined) {
                localVarQueryParameter['createdon'] = createdon;
            }

            if (foods) {
                localVarQueryParameter['foods'] = foods;
            }

            if (foodsAnd) {
                localVarQueryParameter['foods_and'] = foodsAnd;
            }

            if (foodsAndNot) {
                localVarQueryParameter['foods_and_not'] = foodsAndNot;
            }

            if (foodsOr) {
                localVarQueryParameter['foods_or'] = foodsOr;
            }

            if (foodsOrNot) {
                localVarQueryParameter['foods_or_not'] = foodsOrNot;
            }

            if (internal !== undefined) {
                localVarQueryParameter['internal'] = internal;
            }

            if (keywords) {
                localVarQueryParameter['keywords'] = keywords;
            }

            if (keywordsAnd) {
                localVarQueryParameter['keywords_and'] = keywordsAnd;
            }

            if (keywordsAndNot) {
                localVarQueryParameter['keywords_and_not'] = keywordsAndNot;
            }

            if (keywordsOr) {
                localVarQueryParameter['keywords_or'] = keywordsOr;
            }

            if (keywordsOrNot) {
                localVarQueryParameter['keywords_or_not'] = keywordsOrNot;
            }

            if (makenow !== undefined) {
                localVarQueryParameter['makenow'] = makenow;
            }

            if (_new !== undefined) {
                localVarQueryParameter['new'] = _new;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (rating !== undefined) {
                localVarQueryParameter['rating'] = rating;
            }

            if (timescooked !== undefined) {
                localVarQueryParameter['timescooked'] = timescooked;
            }

            if (units !== undefined) {
                localVarQueryParameter['units'] = units;
            }

            if (updatedon !== undefined) {
                localVarQueryParameter['updatedon'] = updatedon;
            }

            if (viewedon !== undefined) {
                localVarQueryParameter['viewedon'] = viewedon;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipePartialUpdate: async (id: number, patchedRecipeRequest?: PatchedRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipePartialUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRelatedRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeRelatedRetrieve', 'id', id)
            const localVarPath = `/api/recipe/{id}/related/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeRetrieve', 'id', id)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeShoppingUpdate: async (id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeShoppingUpdate', 'id', id)
            const localVarPath = `/api/recipe/{id}/shopping/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeShoppingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeUpdate: async (id: number, recipeRequest: RecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecipeUpdate', 'id', id)
            // verify required parameter 'recipeRequest' is not null or undefined
            assertParamExists('apiRecipeUpdate', 'recipeRequest', recipeRequest)
            const localVarPath = `/api/recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResetFoodInheritanceCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/reset-food-inheritance/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShareLinkRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShareLinkRetrieve', 'id', id)
            const localVarPath = `/api/share-link/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryBulkCreate: async (shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryBulkRequest' is not null or undefined
            assertParamExists('apiShoppingListEntryBulkCreate', 'shoppingListEntryBulkRequest', shoppingListEntryBulkRequest)
            const localVarPath = `/api/shopping-list-entry/bulk/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryBulkRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryCreate: async (shoppingListEntryRequest: ShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListEntryRequest' is not null or undefined
            assertParamExists('apiShoppingListEntryCreate', 'shoppingListEntryRequest', shoppingListEntryRequest)
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryDestroy', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryList: async (checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-entry/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (checked !== undefined) {
                localVarQueryParameter['checked'] = checked;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (supermarket !== undefined) {
                localVarQueryParameter['supermarket'] = supermarket;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryPartialUpdate: async (id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryPartialUpdate', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryRetrieve', 'id', id)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryUpdate: async (id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListEntryUpdate', 'id', id)
            // verify required parameter 'shoppingListEntryRequest' is not null or undefined
            assertParamExists('apiShoppingListEntryUpdate', 'shoppingListEntryRequest', shoppingListEntryRequest)
            const localVarPath = `/api/shopping-list-entry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeCreate: async (shoppingListRecipeRequest: ShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'shoppingListRecipeRequest' is not null or undefined
            assertParamExists('apiShoppingListRecipeCreate', 'shoppingListRecipeRequest', shoppingListRecipeRequest)
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeDestroy', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/shopping-list-recipe/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipePartialUpdate: async (id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipePartialUpdate', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedShoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeRetrieve', 'id', id)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeUpdate: async (id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiShoppingListRecipeUpdate', 'id', id)
            // verify required parameter 'shoppingListRecipeRequest' is not null or undefined
            assertParamExists('apiShoppingListRecipeUpdate', 'shoppingListRecipeRequest', shoppingListRecipeRequest)
            const localVarPath = `/api/shopping-list-recipe/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(shoppingListRecipeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpacePartialUpdate: async (id: number, patchedSpaceRequest?: PatchedSpaceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSpacePartialUpdate', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSpaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSpaceRetrieve', 'id', id)
            const localVarPath = `/api/space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepCreate: async (stepRequest: StepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'stepRequest' is not null or undefined
            assertParamExists('apiStepCreate', 'stepRequest', stepRequest)
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepDestroy', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepList: async (page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/step/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (recipe) {
                localVarQueryParameter['recipe'] = recipe;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepPartialUpdate: async (id: number, patchedStepRequest?: PatchedStepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepPartialUpdate', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepRetrieve', 'id', id)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepUpdate: async (id: number, stepRequest: StepRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStepUpdate', 'id', id)
            // verify required parameter 'stepRequest' is not null or undefined
            assertParamExists('apiStepUpdate', 'stepRequest', stepRequest)
            const localVarPath = `/api/step/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(stepRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageCreate: async (storageRequest: StorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'storageRequest' is not null or undefined
            assertParamExists('apiStorageCreate', 'storageRequest', storageRequest)
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageDestroy', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/storage/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStoragePartialUpdate: async (id: number, patchedStorageRequest?: PatchedStorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStoragePartialUpdate', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedStorageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageRetrieve', 'id', id)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageUpdate: async (id: number, storageRequest: StorageRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiStorageUpdate', 'id', id)
            // verify required parameter 'storageRequest' is not null or undefined
            assertParamExists('apiStorageUpdate', 'storageRequest', storageRequest)
            const localVarPath = `/api/storage/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryCreate: async (supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('apiSupermarketCategoryCreate', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryDestroy', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryMergeUpdate: async (id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'target', target)
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('apiSupermarketCategoryMergeUpdate', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryPartialUpdate: async (id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationCreate: async (supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketCategoryRelationRequest' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationCreate', 'supermarketCategoryRelationRequest', supermarketCategoryRelationRequest)
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationDestroy', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket-category-relation/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationPartialUpdate: async (id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationRetrieve', 'id', id)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationUpdate: async (id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationUpdate', 'id', id)
            // verify required parameter 'supermarketCategoryRelationRequest' is not null or undefined
            assertParamExists('apiSupermarketCategoryRelationUpdate', 'supermarketCategoryRelationRequest', supermarketCategoryRelationRequest)
            const localVarPath = `/api/supermarket-category-relation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRelationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryRetrieve', 'id', id)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryUpdate: async (id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketCategoryUpdate', 'id', id)
            // verify required parameter 'supermarketCategoryRequest' is not null or undefined
            assertParamExists('apiSupermarketCategoryUpdate', 'supermarketCategoryRequest', supermarketCategoryRequest)
            const localVarPath = `/api/supermarket-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketCategoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCreate: async (supermarketRequest: SupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'supermarketRequest' is not null or undefined
            assertParamExists('apiSupermarketCreate', 'supermarketRequest', supermarketRequest)
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketDestroy', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/supermarket/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketPartialUpdate: async (id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketPartialUpdate', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSupermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketRetrieve', 'id', id)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketUpdate: async (id: number, supermarketRequest: SupermarketRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSupermarketUpdate', 'id', id)
            // verify required parameter 'supermarketRequest' is not null or undefined
            assertParamExists('apiSupermarketUpdate', 'supermarketRequest', supermarketRequest)
            const localVarPath = `/api/supermarket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supermarketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwitchActiveSpaceRetrieve: async (spaceId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'spaceId' is not null or undefined
            assertParamExists('apiSwitchActiveSpaceRetrieve', 'spaceId', spaceId)
            const localVarPath = `/api/switch-active-space/{spaceId}/`
                .replace(`{${"spaceId"}}`, encodeURIComponent(String(spaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncCreate: async (syncRequest: SyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'syncRequest' is not null or undefined
            assertParamExists('apiSyncCreate', 'syncRequest', syncRequest)
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncDestroy', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/sync-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncLogRetrieve', 'id', id)
            const localVarPath = `/api/sync-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncPartialUpdate: async (id: number, patchedSyncRequest?: PatchedSyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncPartialUpdate', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedSyncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncRetrieve', 'id', id)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncUpdate: async (id: number, syncRequest: SyncRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiSyncUpdate', 'id', id)
            // verify required parameter 'syncRequest' is not null or undefined
            assertParamExists('apiSyncUpdate', 'syncRequest', syncRequest)
            const localVarPath = `/api/sync/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(syncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionCreate: async (unitConversionRequest: UnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitConversionRequest' is not null or undefined
            assertParamExists('apiUnitConversionCreate', 'unitConversionRequest', unitConversionRequest)
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionDestroy', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionList: async (foodId?: number, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit-conversion/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (foodId !== undefined) {
                localVarQueryParameter['food_id'] = foodId;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionPartialUpdate: async (id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionPartialUpdate', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionRetrieve', 'id', id)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionUpdate: async (id: number, unitConversionRequest: UnitConversionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitConversionUpdate', 'id', id)
            // verify required parameter 'unitConversionRequest' is not null or undefined
            assertParamExists('apiUnitConversionUpdate', 'unitConversionRequest', unitConversionRequest)
            const localVarPath = `/api/unit-conversion/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitConversionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitCreate: async (unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('apiUnitCreate', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitDestroy', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/unit/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitMergeUpdate: async (id: number, target: number, unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'id', id)
            // verify required parameter 'target' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'target', target)
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('apiUnitMergeUpdate', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/{id}/merge/{target}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"target"}}`, encodeURIComponent(String(target)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitPartialUpdate: async (id: number, patchedUnitRequest?: PatchedUnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitPartialUpdate', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUnitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitRetrieve', 'id', id)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitUpdate: async (id: number, unitRequest: UnitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUnitUpdate', 'id', id)
            // verify required parameter 'unitRequest' is not null or undefined
            assertParamExists('apiUnitUpdate', 'unitRequest', unitRequest)
            const localVarPath = `/api/unit/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileCreate: async (name: string, file: any, id?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiUserFileCreate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiUserFileCreate', 'file', file)
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id !== undefined) { 
                localVarFormParams.append('id', id as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileDestroy', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileList: async (limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-file/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (random !== undefined) {
                localVarQueryParameter['random'] = random;
            }

            if (updatedAt !== undefined) {
                localVarQueryParameter['updated_at'] = updatedAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFilePartialUpdate: async (id: number, name?: string, file?: any, id2?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFilePartialUpdate', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileRetrieve', 'id', id)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileUpdate: async (id: number, name: string, file: any, id2?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'id', id)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'name', name)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('apiUserFileUpdate', 'file', file)
            const localVarPath = `/api/user-file/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (id2 !== undefined) { 
                localVarFormParams.append('id', id2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserList: async (filterList?: Array<string>, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (filterList) {
                localVarQueryParameter['filter_list'] = filterList;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPartialUpdate: async (id: number, patchedUserRequest?: PatchedUserRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserPartialUpdate', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-preference/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencePartialUpdate: async (user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserPreferencePartialUpdate', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserPreferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceRetrieve: async (user: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('apiUserPreferenceRetrieve', 'user', user)
            const localVarPath = `/api/user-preference/{user}/`
                .replace(`{${"user"}}`, encodeURIComponent(String(user)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserRetrieve', 'id', id)
            const localVarPath = `/api/user/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpaceDestroy', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceList: async (internalNote?: string, page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user-space/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (internalNote !== undefined) {
                localVarQueryParameter['internal_note'] = internalNote;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpacePartialUpdate: async (id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpacePartialUpdate', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedUserSpaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiUserSpaceRetrieve', 'id', id)
            const localVarPath = `/api/user-space/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogCreate: async (viewLogRequest: ViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'viewLogRequest' is not null or undefined
            assertParamExists('apiViewLogCreate', 'viewLogRequest', viewLogRequest)
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogDestroy: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogDestroy', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogList: async (page?: number, pageSize?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/view-log/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogPartialUpdate: async (id: number, patchedViewLogRequest?: PatchedViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogPartialUpdate', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedViewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogRetrieve: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogRetrieve', 'id', id)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogUpdate: async (id: number, viewLogRequest: ViewLogRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiViewLogUpdate', 'id', id)
            // verify required parameter 'viewLogRequest' is not null or undefined
            assertParamExists('apiViewLogUpdate', 'viewLogRequest', viewLogRequest)
            const localVarPath = `/api/view-log/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(viewLogRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenCreate(accessTokenRequest: AccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenCreate(accessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AccessToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenPartialUpdate(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenPartialUpdate(id, patchedAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAccessTokenUpdate(id: number, accessTokenRequest: AccessTokenRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAccessTokenUpdate(id, accessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutoPlanCreate(autoMealPlanRequest: AutoMealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoMealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutoPlanCreate(autoMealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationCreate(automationRequest: AutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationCreate(automationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationList(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedAutomationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationList(page, pageSize, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationPartialUpdate(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationPartialUpdate(id, patchedAutomationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiAutomationUpdate(id: number, automationRequest: AutomationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Automation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiAutomationUpdate(id, automationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportCreate(bookmarkletImportRequest: BookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportCreate(bookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedBookmarkletImportListList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiBookmarkletImportUpdate(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookmarkletImport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiBookmarkletImportUpdate(id, bookmarkletImportRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigCreate(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigCreate(connectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ConnectorConfigConfig>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiConnectorConfigUpdate(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectorConfigConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiConnectorConfigUpdate(id, connectorConfigConfigRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogCreate(cookLogRequest: CookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogCreate(cookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCookLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogList(page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogPartialUpdate(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogPartialUpdate(id, patchedCookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCookLogUpdate(id: number, cookLogRequest: CookLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CookLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCookLogUpdate(id, cookLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterCreate(customFilterRequest: CustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterCreate(customFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedCustomFilterList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterPartialUpdate(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterPartialUpdate(id, patchedCustomFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiCustomFilterUpdate(id: number, customFilterRequest: CustomFilterRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomFilter>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiCustomFilterUpdate(id, customFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiDownloadFileRetrieve(fileId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiDownloadFileRetrieve(fileId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogCreate(exportLogRequest: ExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogCreate(exportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedExportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogPartialUpdate(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogPartialUpdate(id, patchedExportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiExportLogUpdate(id: number, exportLogRequest: ExportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiExportLogUpdate(id, exportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodCreate(foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodCreate(foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodFdcCreate(id: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodFdcCreate(id, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodInheritFieldList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FoodInheritField>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodInheritFieldList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodInheritFieldRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodInheritField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodInheritFieldRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedFoodList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodMergeUpdate(id: number, target: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodMergeUpdate(id, target, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodMoveUpdate(id: number, parent: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodMoveUpdate(id, parent, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPartialUpdate(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPartialUpdate(id, patchedFoodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyCreate(propertyRequest: PropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyCreate(propertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyPartialUpdate(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyPartialUpdate(id, patchedPropertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeCreate(propertyTypeRequest: PropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeCreate(propertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeList(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedPropertyTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeList(category, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypePartialUpdate(id, patchedPropertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyTypeUpdate(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PropertyType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyTypeUpdate(id, propertyTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodPropertyUpdate(id: number, propertyRequest: PropertyRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Property>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodPropertyUpdate(id, propertyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodShoppingUpdate(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FoodShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodShoppingUpdate(id, foodShoppingUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiFoodUpdate(id: number, foodRequest: FoodRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Food>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiFoodUpdate(id, foodRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGetExternalFileLinkRetrieve(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGetExternalFileLinkRetrieve(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGetRecipeFileRetrieve(recipeId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGetRecipeFileRetrieve(recipeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Group>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiGroupRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiGroupRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogCreate(importLogRequest: ImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogCreate(importLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedImportLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogPartialUpdate(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogPartialUpdate(id, patchedImportLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportLogUpdate(id: number, importLogRequest: ImportLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportLogUpdate(id, importLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientCreate(ingredientRequest: IngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientCreate(ingredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientFromStringCreate(ingredientStringRequest: IngredientStringRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParsedIngredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientFromStringCreate(ingredientStringRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedIngredientList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientList(food, page, pageSize, unit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientPartialUpdate(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientPartialUpdate(id, patchedIngredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiIngredientUpdate(id: number, ingredientRequest: IngredientRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ingredient>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiIngredientUpdate(id, ingredientRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkCreate(inviteLinkRequest: InviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkCreate(inviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedInviteLinkList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkPartialUpdate(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkPartialUpdate(id, patchedInviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiInviteLinkUpdate(id: number, inviteLinkRequest: InviteLinkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InviteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiInviteLinkUpdate(id, inviteLinkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordCreate(keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordCreate(keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedKeywordList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordMergeUpdate(id: number, target: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordMergeUpdate(id, target, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordMoveUpdate(id: number, parent: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordMoveUpdate(id, parent, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordPartialUpdate(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordPartialUpdate(id, patchedKeywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiKeywordUpdate(id: number, keywordRequest: KeywordRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Keyword>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiKeywordUpdate(id, keywordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanCreate(mealPlanRequest: MealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanCreate(mealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanIcalRetrieve(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanList(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealPlanList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanPartialUpdate(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanPartialUpdate(id, patchedMealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealPlanUpdate(id: number, mealPlanRequest: MealPlanRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealPlan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealPlanUpdate(id, mealPlanRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeCreate(mealTypeRequest: MealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeCreate(mealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedMealTypeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypePartialUpdate(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypePartialUpdate(id, patchedMealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiMealTypeUpdate(id: number, mealTypeRequest: MealTypeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MealType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiMealTypeUpdate(id, mealTypeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookCreate(recipeBookRequest: RecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookCreate(recipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryCreate(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryCreate(recipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryList(book, page, pageSize, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookEntryUpdate(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBookEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookEntryUpdate(id, recipeBookEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeBookList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookPartialUpdate(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookPartialUpdate(id, patchedRecipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeBookUpdate(id: number, recipeBookRequest: RecipeBookRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeBook>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeBookUpdate(id, recipeBookRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeCreate(recipeRequest: RecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeCreate(recipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeFlatList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RecipeFlat>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeFlatList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeFromSourceCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeFromSourceCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeImageUpdate(id: number, image?: any, imageUrl?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeImageUpdate(id, image, imageUrl, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeList(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedRecipeOverviewList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipePartialUpdate(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipePartialUpdate(id, patchedRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeRelatedRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeSimple>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeRelatedRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeShoppingUpdate(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecipeShoppingUpdate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeShoppingUpdate(id, recipeShoppingUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiRecipeUpdate(id: number, recipeRequest: RecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Recipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiRecipeUpdate(id, recipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiResetFoodInheritanceCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiResetFoodInheritanceCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShareLinkRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShareLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShareLinkRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntryBulk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryCreate(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryCreate(shoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListEntryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListEntryUpdate(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListEntryUpdate(id, shoppingListEntryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeCreate(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeCreate(shoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedShoppingListRecipeList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiShoppingListRecipeUpdate(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ShoppingListRecipe>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiShoppingListRecipeUpdate(id, shoppingListRecipeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSpaceList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Space>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSpaceList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSpacePartialUpdate(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSpacePartialUpdate(id, patchedSpaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSpaceRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Space>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSpaceRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepCreate(stepRequest: StepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepCreate(stepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepList(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedStepList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepList(page, pageSize, query, recipe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepPartialUpdate(id: number, patchedStepRequest?: PatchedStepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepPartialUpdate(id, patchedStepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStepUpdate(id: number, stepRequest: StepRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Step>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStepUpdate(id, stepRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageCreate(storageRequest: StorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageCreate(storageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Storage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStoragePartialUpdate(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStoragePartialUpdate(id, patchedStorageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiStorageUpdate(id: number, storageRequest: StorageRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Storage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiStorageUpdate(id, storageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryCreate(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryCreate(supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryMergeUpdate(id, target, supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketCategoryRelationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategoryRelation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCategoryUpdate(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupermarketCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCategoryUpdate(id, supermarketCategoryRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketCreate(supermarketRequest: SupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketCreate(supermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSupermarketList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketPartialUpdate(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketPartialUpdate(id, patchedSupermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSupermarketUpdate(id: number, supermarketRequest: SupermarketRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Supermarket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSupermarketUpdate(id, supermarketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSwitchActiveSpaceRetrieve(spaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncCreate(syncRequest: SyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncCreate(syncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedSyncLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SyncLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncPartialUpdate(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncPartialUpdate(id, patchedSyncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiSyncUpdate(id: number, syncRequest: SyncRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sync>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiSyncUpdate(id, syncRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionCreate(unitConversionRequest: UnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionCreate(unitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitConversionList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionList(foodId, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionPartialUpdate(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionPartialUpdate(id, patchedUnitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitConversionUpdate(id: number, unitConversionRequest: UnitConversionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnitConversion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitConversionUpdate(id, unitConversionRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitCreate(unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitCreate(unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUnitList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitMergeUpdate(id: number, target: number, unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitMergeUpdate(id, target, unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitPartialUpdate(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitPartialUpdate(id, patchedUnitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUnitUpdate(id: number, unitRequest: UnitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Unit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUnitUpdate(id, unitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileCreate(name: string, file: any, id?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileCreate(name, file, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserFileList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileList(limit, page, pageSize, query, random, updatedAt, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFilePartialUpdate(id: number, name?: string, file?: any, id2?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFilePartialUpdate(id, name, file, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserFileUpdate(id: number, name: string, file: any, id2?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserFileUpdate(id, name, file, id2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserList(filterList?: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserList(filterList, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPartialUpdate(id, patchedUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferenceList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserPreference>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferenceList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferencePartialUpdate(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferencePartialUpdate(user, patchedUserPreferenceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserPreferenceRetrieve(user: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserPreferenceRetrieve(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedUserSpaceList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceList(internalNote, page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpacePartialUpdate(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpacePartialUpdate(id, patchedUserSpaceRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiUserSpaceRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpace>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiUserSpaceRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogCreate(viewLogRequest: ViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogCreate(viewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogDestroy(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogDestroy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogList(page?: number, pageSize?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedViewLogList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogList(page, pageSize, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogPartialUpdate(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogPartialUpdate(id, patchedViewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogRetrieve(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogRetrieve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiViewLogUpdate(id: number, viewLogRequest: ViewLogRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ViewLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiViewLogUpdate(id, viewLogRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiApiFp(configuration)
    return {
        /**
         * 
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenCreate(accessTokenRequest: AccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenCreate(accessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiAccessTokenDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenList(options?: any): AxiosPromise<Array<AccessToken>> {
            return localVarFp.apiAccessTokenList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenPartialUpdate(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenPartialUpdate(id, patchedAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenRetrieve(id: number, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this access token.
         * @param {AccessTokenRequest} accessTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAccessTokenUpdate(id: number, accessTokenRequest: AccessTokenRequest, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.apiAccessTokenUpdate(id, accessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutoMealPlanRequest} autoMealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutoPlanCreate(autoMealPlanRequest: AutoMealPlanRequest, options?: any): AxiosPromise<AutoMealPlan> {
            return localVarFp.apiAutoPlanCreate(autoMealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationCreate(automationRequest: AutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationCreate(automationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiAutomationDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationList(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any): AxiosPromise<PaginatedAutomationList> {
            return localVarFp.apiAutomationList(page, pageSize, type, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationPartialUpdate(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationPartialUpdate(id, patchedAutomationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationRetrieve(id: number, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this automation.
         * @param {AutomationRequest} automationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiAutomationUpdate(id: number, automationRequest: AutomationRequest, options?: any): AxiosPromise<Automation> {
            return localVarFp.apiAutomationUpdate(id, automationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportCreate(bookmarkletImportRequest: BookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportCreate(bookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiBookmarkletImportDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedBookmarkletImportListList> {
            return localVarFp.apiBookmarkletImportList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportRetrieve(id: number, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this bookmarklet import.
         * @param {BookmarkletImportRequest} bookmarkletImportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiBookmarkletImportUpdate(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any): AxiosPromise<BookmarkletImport> {
            return localVarFp.apiBookmarkletImportUpdate(id, bookmarkletImportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigCreate(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigCreate(connectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiConnectorConfigDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigList(options?: any): AxiosPromise<Array<ConnectorConfigConfig>> {
            return localVarFp.apiConnectorConfigList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigRetrieve(id: number, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this connector config.
         * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiConnectorConfigUpdate(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any): AxiosPromise<ConnectorConfigConfig> {
            return localVarFp.apiConnectorConfigUpdate(id, connectorConfigConfigRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogCreate(cookLogRequest: CookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogCreate(cookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiCookLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] Filter for entries with the given recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedCookLogList> {
            return localVarFp.apiCookLogList(page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogPartialUpdate(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogPartialUpdate(id, patchedCookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogRetrieve(id: number, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cook log.
         * @param {CookLogRequest} cookLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCookLogUpdate(id: number, cookLogRequest: CookLogRequest, options?: any): AxiosPromise<CookLog> {
            return localVarFp.apiCookLogUpdate(id, cookLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterCreate(customFilterRequest: CustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterCreate(customFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiCustomFilterDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any): AxiosPromise<PaginatedCustomFilterList> {
            return localVarFp.apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterPartialUpdate(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterPartialUpdate(id, patchedCustomFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterRetrieve(id: number, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom filter.
         * @param {CustomFilterRequest} customFilterRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiCustomFilterUpdate(id: number, customFilterRequest: CustomFilterRequest, options?: any): AxiosPromise<CustomFilter> {
            return localVarFp.apiCustomFilterUpdate(id, customFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
         * @param {number} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiDownloadFileRetrieve(fileId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiDownloadFileRetrieve(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogCreate(exportLogRequest: ExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogCreate(exportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiExportLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedExportLogList> {
            return localVarFp.apiExportLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogPartialUpdate(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogPartialUpdate(id, patchedExportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogRetrieve(id: number, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export log.
         * @param {ExportLogRequest} exportLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiExportLogUpdate(id: number, exportLogRequest: ExportLogRequest, options?: any): AxiosPromise<ExportLog> {
            return localVarFp.apiExportLogUpdate(id, exportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodCreate(foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodCreate(foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodFdcCreate(id: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodFdcCreate(id, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldList(options?: any): AxiosPromise<Array<FoodInheritField>> {
            return localVarFp.apiFoodInheritFieldList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food inherit field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodInheritFieldRetrieve(id: number, options?: any): AxiosPromise<FoodInheritField> {
            return localVarFp.apiFoodInheritFieldRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedFoodList> {
            return localVarFp.apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMergeUpdate(id: number, target: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodMergeUpdate(id, target, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodMoveUpdate(id: number, parent: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodMoveUpdate(id, parent, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {PatchedFoodRequest} [patchedFoodRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPartialUpdate(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodPartialUpdate(id, patchedFoodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyCreate(propertyRequest: PropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyCreate(propertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodPropertyDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyList> {
            return localVarFp.apiFoodPropertyList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyPartialUpdate(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyPartialUpdate(id, patchedPropertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyRetrieve(id: number, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeCreate(propertyTypeRequest: PropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeCreate(propertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiFoodPropertyTypeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeList(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedPropertyTypeList> {
            return localVarFp.apiFoodPropertyTypeList(category, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypePartialUpdate(id, patchedPropertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeRetrieve(id: number, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property type.
         * @param {PropertyTypeRequest} propertyTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyTypeUpdate(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any): AxiosPromise<PropertyType> {
            return localVarFp.apiFoodPropertyTypeUpdate(id, propertyTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this property.
         * @param {PropertyRequest} propertyRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodPropertyUpdate(id: number, propertyRequest: PropertyRequest, options?: any): AxiosPromise<Property> {
            return localVarFp.apiFoodPropertyUpdate(id, propertyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodRetrieve(id: number, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodShoppingUpdate(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any): AxiosPromise<FoodShoppingUpdate> {
            return localVarFp.apiFoodShoppingUpdate(id, foodShoppingUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this food.
         * @param {FoodRequest} foodRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiFoodUpdate(id: number, foodRequest: FoodRequest, options?: any): AxiosPromise<Food> {
            return localVarFp.apiFoodUpdate(id, foodRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGetExternalFileLinkRetrieve(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiGetExternalFileLinkRetrieve(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} recipeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGetRecipeFileRetrieve(recipeId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiGetRecipeFileRetrieve(recipeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupList(options?: any): AxiosPromise<Array<Group>> {
            return localVarFp.apiGroupList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiGroupRetrieve(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.apiGroupRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * function to handle files passed by application importer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogCreate(importLogRequest: ImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogCreate(importLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiImportLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedImportLogList> {
            return localVarFp.apiImportLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogPartialUpdate(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogPartialUpdate(id, patchedImportLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogRetrieve(id: number, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this import log.
         * @param {ImportLogRequest} importLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportLogUpdate(id: number, importLogRequest: ImportLogRequest, options?: any): AxiosPromise<ImportLog> {
            return localVarFp.apiImportLogUpdate(id, importLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientCreate(ingredientRequest: IngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientCreate(ingredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiIngredientDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {IngredientStringRequest} ingredientStringRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientFromStringCreate(ingredientStringRequest: IngredientStringRequest, options?: any): AxiosPromise<ParsedIngredient> {
            return localVarFp.apiIngredientFromStringCreate(ingredientStringRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [food] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [unit] ID of unit to filter for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any): AxiosPromise<PaginatedIngredientList> {
            return localVarFp.apiIngredientList(food, page, pageSize, unit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientPartialUpdate(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientPartialUpdate(id, patchedIngredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientRetrieve(id: number, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this ingredient.
         * @param {IngredientRequest} ingredientRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiIngredientUpdate(id: number, ingredientRequest: IngredientRequest, options?: any): AxiosPromise<Ingredient> {
            return localVarFp.apiIngredientUpdate(id, ingredientRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkCreate(inviteLinkRequest: InviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkCreate(inviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiInviteLinkDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what internal_note is for.
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedInviteLinkList> {
            return localVarFp.apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkPartialUpdate(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkPartialUpdate(id, patchedInviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkRetrieve(id: number, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this invite link.
         * @param {InviteLinkRequest} inviteLinkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiInviteLinkUpdate(id: number, inviteLinkRequest: InviteLinkRequest, options?: any): AxiosPromise<InviteLink> {
            return localVarFp.apiInviteLinkUpdate(id, inviteLinkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordCreate(keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordCreate(keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiKeywordDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
         * @param {number} [tree] Return all self and children of {obj} with ID [int].
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any): AxiosPromise<PaginatedKeywordList> {
            return localVarFp.apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMergeUpdate(id: number, target: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordMergeUpdate(id, target, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {number} parent The ID of the desired parent of the {obj}.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordMoveUpdate(id: number, parent: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordMoveUpdate(id, parent, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordPartialUpdate(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordPartialUpdate(id, patchedKeywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordRetrieve(id: number, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this keyword.
         * @param {KeywordRequest} keywordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiKeywordUpdate(id: number, keywordRequest: KeywordRequest, options?: any): AxiosPromise<Keyword> {
            return localVarFp.apiKeywordUpdate(id, keywordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanCreate(mealPlanRequest: MealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanCreate(mealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiMealPlanDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanIcalRetrieve(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any): AxiosPromise<string> {
            return localVarFp.apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [fromDate] Filter meal plans from date (inclusive).
         * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [toDate] Filter meal plans to date (inclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanList(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any): AxiosPromise<PaginatedMealPlanList> {
            return localVarFp.apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanPartialUpdate(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanPartialUpdate(id, patchedMealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanRetrieve(id: number, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this meal plan.
         * @param {MealPlanRequest} mealPlanRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealPlanUpdate(id: number, mealPlanRequest: MealPlanRequest, options?: any): AxiosPromise<MealPlan> {
            return localVarFp.apiMealPlanUpdate(id, mealPlanRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeCreate(mealTypeRequest: MealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeCreate(mealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiMealTypeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedMealTypeList> {
            return localVarFp.apiMealTypeList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypePartialUpdate(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypePartialUpdate(id, patchedMealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeRetrieve(id: number, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * returns list of meal types created by the requesting user ordered by the order field.
         * @param {number} id A unique integer value identifying this meal type.
         * @param {MealTypeRequest} mealTypeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiMealTypeUpdate(id: number, mealTypeRequest: MealTypeRequest, options?: any): AxiosPromise<MealType> {
            return localVarFp.apiMealTypeUpdate(id, mealTypeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookCreate(recipeBookRequest: RecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookCreate(recipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeBookDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryCreate(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryCreate(recipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeBookEntryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [book] id of book - only return recipes in that book
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [recipe] id of recipe - only return books for that recipe
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any): AxiosPromise<PaginatedRecipeBookEntryList> {
            return localVarFp.apiRecipeBookEntryList(book, page, pageSize, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryRetrieve(id: number, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book entry.
         * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookEntryUpdate(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any): AxiosPromise<RecipeBookEntry> {
            return localVarFp.apiRecipeBookEntryUpdate(id, recipeBookEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
         * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedRecipeBookList> {
            return localVarFp.apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookPartialUpdate(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookPartialUpdate(id, patchedRecipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookRetrieve(id: number, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe book.
         * @param {RecipeBookRequest} recipeBookRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeBookUpdate(id: number, recipeBookRequest: RecipeBookRequest, options?: any): AxiosPromise<RecipeBook> {
            return localVarFp.apiRecipeBookUpdate(id, recipeBookRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeCreate(recipeRequest: RecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeCreate(recipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFlatList(options?: any): AxiosPromise<Array<RecipeFlat>> {
            return localVarFp.apiRecipeFlatList(options).then((request) => request(axios, basePath));
        },
        /**
         * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeFromSourceCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiRecipeFromSourceCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {any} [image] 
         * @param {string} [imageUrl] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeImageUpdate(id: number, image?: any, imageUrl?: string, options?: any): AxiosPromise<RecipeImage> {
            return localVarFp.apiRecipeImageUpdate(id, image, imageUrl, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
         * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
         * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
         * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
         * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
         * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
         * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
         * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
         * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
         * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
         * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
         * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
         * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
         * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
         * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
         * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
         * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
         * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
         * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
         * @param {number} [units] ID of unit a recipe should have.
         * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeList(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any): AxiosPromise<PaginatedRecipeOverviewList> {
            return localVarFp.apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipePartialUpdate(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipePartialUpdate(id, patchedRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRelatedRetrieve(id: number, options?: any): AxiosPromise<RecipeSimple> {
            return localVarFp.apiRecipeRelatedRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeRetrieve(id: number, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeShoppingUpdate(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any): AxiosPromise<RecipeShoppingUpdate> {
            return localVarFp.apiRecipeShoppingUpdate(id, recipeShoppingUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this recipe.
         * @param {RecipeRequest} recipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecipeUpdate(id: number, recipeRequest: RecipeRequest, options?: any): AxiosPromise<Recipe> {
            return localVarFp.apiRecipeUpdate(id, recipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * function to reset inheritance from api, see food method for docs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiResetFoodInheritanceCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiResetFoodInheritanceCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShareLinkRetrieve(id: number, options?: any): AxiosPromise<ShareLink> {
            return localVarFp.apiShareLinkRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any): AxiosPromise<ShoppingListEntryBulk> {
            return localVarFp.apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryCreate(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryCreate(shoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiShoppingListEntryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
         * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any): AxiosPromise<PaginatedShoppingListEntryList> {
            return localVarFp.apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryRetrieve(id: number, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list entry.
         * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListEntryUpdate(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any): AxiosPromise<ShoppingListEntry> {
            return localVarFp.apiShoppingListEntryUpdate(id, shoppingListEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeCreate(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeCreate(shoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiShoppingListRecipeDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedShoppingListRecipeList> {
            return localVarFp.apiShoppingListRecipeList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeRetrieve(id: number, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this shopping list recipe.
         * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiShoppingListRecipeUpdate(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any): AxiosPromise<ShoppingListRecipe> {
            return localVarFp.apiShoppingListRecipeUpdate(id, shoppingListRecipeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceList(options?: any): AxiosPromise<Array<Space>> {
            return localVarFp.apiSpaceList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpacePartialUpdate(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any): AxiosPromise<Space> {
            return localVarFp.apiSpacePartialUpdate(id, patchedSpaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSpaceRetrieve(id: number, options?: any): AxiosPromise<Space> {
            return localVarFp.apiSpaceRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepCreate(stepRequest: StepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepCreate(stepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiStepDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] Query string matched (fuzzy) against object name.
         * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepList(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any): AxiosPromise<PaginatedStepList> {
            return localVarFp.apiStepList(page, pageSize, query, recipe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {PatchedStepRequest} [patchedStepRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepPartialUpdate(id: number, patchedStepRequest?: PatchedStepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepPartialUpdate(id, patchedStepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepRetrieve(id: number, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this step.
         * @param {StepRequest} stepRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStepUpdate(id: number, stepRequest: StepRequest, options?: any): AxiosPromise<Step> {
            return localVarFp.apiStepUpdate(id, stepRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageCreate(storageRequest: StorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageCreate(storageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiStorageDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageList(options?: any): AxiosPromise<Array<Storage>> {
            return localVarFp.apiStorageList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {PatchedStorageRequest} [patchedStorageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStoragePartialUpdate(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStoragePartialUpdate(id, patchedStorageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageRetrieve(id: number, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this storage.
         * @param {StorageRequest} storageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiStorageUpdate(id: number, storageRequest: StorageRequest, options?: any): AxiosPromise<Storage> {
            return localVarFp.apiStorageUpdate(id, storageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryCreate(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryCreate(supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketCategoryDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryList> {
            return localVarFp.apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryMergeUpdate(id, target, supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketCategoryRelationDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketCategoryRelationList> {
            return localVarFp.apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationRetrieve(id: number, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category relation.
         * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any): AxiosPromise<SupermarketCategoryRelation> {
            return localVarFp.apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryRetrieve(id: number, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket category.
         * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCategoryUpdate(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any): AxiosPromise<SupermarketCategory> {
            return localVarFp.apiSupermarketCategoryUpdate(id, supermarketCategoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketCreate(supermarketRequest: SupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketCreate(supermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSupermarketDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedSupermarketList> {
            return localVarFp.apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketPartialUpdate(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketPartialUpdate(id, patchedSupermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketRetrieve(id: number, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this supermarket.
         * @param {SupermarketRequest} supermarketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSupermarketUpdate(id: number, supermarketRequest: SupermarketRequest, options?: any): AxiosPromise<Supermarket> {
            return localVarFp.apiSupermarketUpdate(id, supermarketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * api endpoint to switch space function
         * @param {number} spaceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSwitchActiveSpaceRetrieve(spaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncCreate(syncRequest: SyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncCreate(syncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiSyncDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncList> {
            return localVarFp.apiSyncList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedSyncLogList> {
            return localVarFp.apiSyncLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncLogRetrieve(id: number, options?: any): AxiosPromise<SyncLog> {
            return localVarFp.apiSyncLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {PatchedSyncRequest} [patchedSyncRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncPartialUpdate(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncPartialUpdate(id, patchedSyncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncRetrieve(id: number, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this sync.
         * @param {SyncRequest} syncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiSyncUpdate(id: number, syncRequest: SyncRequest, options?: any): AxiosPromise<Sync> {
            return localVarFp.apiSyncUpdate(id, syncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionCreate(unitConversionRequest: UnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionCreate(unitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUnitConversionDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [foodId] ID of food to filter for
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUnitConversionList> {
            return localVarFp.apiUnitConversionList(foodId, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionPartialUpdate(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionPartialUpdate(id, patchedUnitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionRetrieve(id: number, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit conversion.
         * @param {UnitConversionRequest} unitConversionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitConversionUpdate(id: number, unitConversionRequest: UnitConversionRequest, options?: any): AxiosPromise<UnitConversion> {
            return localVarFp.apiUnitConversionUpdate(id, unitConversionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitCreate(unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitCreate(unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUnitDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUnitList> {
            return localVarFp.apiUnitList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {number} target The ID of the {obj} you want to merge with.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitMergeUpdate(id: number, target: number, unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitMergeUpdate(id, target, unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {PatchedUnitRequest} [patchedUnitRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitPartialUpdate(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitPartialUpdate(id, patchedUnitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitRetrieve(id: number, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this unit.
         * @param {UnitRequest} unitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUnitUpdate(id: number, unitRequest: UnitRequest, options?: any): AxiosPromise<Unit> {
            return localVarFp.apiUnitUpdate(id, unitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileCreate(name: string, file: any, id?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileCreate(name, file, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUserFileDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [limit] limit number of entries to return
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {string} [query] lookup if query string is contained within the name, case insensitive
         * @param {string} [random] randomly orders entries (only works together with limit)
         * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any): AxiosPromise<PaginatedUserFileList> {
            return localVarFp.apiUserFileList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} [name] 
         * @param {any} [file] 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFilePartialUpdate(id: number, name?: string, file?: any, id2?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFilePartialUpdate(id, name, file, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileRetrieve(id: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user file.
         * @param {string} name 
         * @param {any} file 
         * @param {number} [id2] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserFileUpdate(id: number, name: string, file: any, id2?: number, options?: any): AxiosPromise<UserFile> {
            return localVarFp.apiUserFileUpdate(id, name, file, id2, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<string>} [filterList] User IDs, repeat for multiple
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserList(filterList?: Array<string>, options?: any): AxiosPromise<Array<User>> {
            return localVarFp.apiUserList(filterList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {PatchedUserRequest} [patchedUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.apiUserPartialUpdate(id, patchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceList(options?: any): AxiosPromise<Array<UserPreference>> {
            return localVarFp.apiUserPreferenceList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferencePartialUpdate(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.apiUserPreferencePartialUpdate(user, patchedUserPreferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} user A unique value identifying this user preference.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserPreferenceRetrieve(user: number, options?: any): AxiosPromise<UserPreference> {
            return localVarFp.apiUserPreferenceRetrieve(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserRetrieve(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.apiUserRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiUserSpaceDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [internalNote] I have no idea what this is
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedUserSpaceList> {
            return localVarFp.apiUserSpaceList(internalNote, page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpacePartialUpdate(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.apiUserSpacePartialUpdate(id, patchedUserSpaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user space.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiUserSpaceRetrieve(id: number, options?: any): AxiosPromise<UserSpace> {
            return localVarFp.apiUserSpaceRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogCreate(viewLogRequest: ViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogCreate(viewLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogDestroy(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.apiViewLogDestroy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [pageSize] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogList(page?: number, pageSize?: number, options?: any): AxiosPromise<PaginatedViewLogList> {
            return localVarFp.apiViewLogList(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogPartialUpdate(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogPartialUpdate(id, patchedViewLogRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogRetrieve(id: number, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this view log.
         * @param {ViewLogRequest} viewLogRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiViewLogUpdate(id: number, viewLogRequest: ViewLogRequest, options?: any): AxiosPromise<ViewLog> {
            return localVarFp.apiViewLogUpdate(id, viewLogRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * 
     * @param {AccessTokenRequest} accessTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenCreate(accessTokenRequest: AccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenCreate(accessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenList(options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {PatchedAccessTokenRequest} [patchedAccessTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenPartialUpdate(id: number, patchedAccessTokenRequest?: PatchedAccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenPartialUpdate(id, patchedAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this access token.
     * @param {AccessTokenRequest} accessTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAccessTokenUpdate(id: number, accessTokenRequest: AccessTokenRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAccessTokenUpdate(id, accessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutoMealPlanRequest} autoMealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutoPlanCreate(autoMealPlanRequest: AutoMealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAutoPlanCreate(autoMealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutomationRequest} automationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationCreate(automationRequest: AutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationCreate(automationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>} [type] Return the Automations matching the automation type.  Repeat for multiple.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationList(page?: number, pageSize?: number, type?: Array<'DESCRIPTION_REPLACE' | 'FOOD_ALIAS' | 'FOOD_REPLACE' | 'INSTRUCTION_REPLACE' | 'KEYWORD_ALIAS' | 'NAME_REPLACE' | 'NEVER_UNIT' | 'TRANSPOSE_WORDS' | 'UNIT_ALIAS' | 'UNIT_REPLACE'>, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationList(page, pageSize, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {PatchedAutomationRequest} [patchedAutomationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationPartialUpdate(id: number, patchedAutomationRequest?: PatchedAutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationPartialUpdate(id, patchedAutomationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this automation.
     * @param {AutomationRequest} automationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiAutomationUpdate(id: number, automationRequest: AutomationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiAutomationUpdate(id, automationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {BookmarkletImportRequest} bookmarkletImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportCreate(bookmarkletImportRequest: BookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportCreate(bookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {PatchedBookmarkletImportRequest} [patchedBookmarkletImportRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportPartialUpdate(id: number, patchedBookmarkletImportRequest?: PatchedBookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportPartialUpdate(id, patchedBookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this bookmarklet import.
     * @param {BookmarkletImportRequest} bookmarkletImportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiBookmarkletImportUpdate(id: number, bookmarkletImportRequest: BookmarkletImportRequest, options?: any) {
        return ApiApiFp(this.configuration).apiBookmarkletImportUpdate(id, bookmarkletImportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigCreate(connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigCreate(connectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigList(options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {PatchedConnectorConfigConfigRequest} [patchedConnectorConfigConfigRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigPartialUpdate(id: number, patchedConnectorConfigConfigRequest?: PatchedConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigPartialUpdate(id, patchedConnectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this connector config.
     * @param {ConnectorConfigConfigRequest} connectorConfigConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiConnectorConfigUpdate(id: number, connectorConfigConfigRequest: ConnectorConfigConfigRequest, options?: any) {
        return ApiApiFp(this.configuration).apiConnectorConfigUpdate(id, connectorConfigConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CookLogRequest} cookLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogCreate(cookLogRequest: CookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogCreate(cookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] Filter for entries with the given recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogList(page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogList(page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {PatchedCookLogRequest} [patchedCookLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogPartialUpdate(id: number, patchedCookLogRequest?: PatchedCookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogPartialUpdate(id, patchedCookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this cook log.
     * @param {CookLogRequest} cookLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCookLogUpdate(id: number, cookLogRequest: CookLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCookLogUpdate(id, cookLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CustomFilterRequest} customFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterCreate(customFilterRequest: CustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterCreate(customFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {Array<'FOOD' | 'KEYWORD' | 'RECIPE'>} [type] Return the CustomFilters matching the model type.  Repeat for multiple.
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, type?: Array<'FOOD' | 'KEYWORD' | 'RECIPE'>, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterList(limit, page, pageSize, query, random, type, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {PatchedCustomFilterRequest} [patchedCustomFilterRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterPartialUpdate(id: number, patchedCustomFilterRequest?: PatchedCustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterPartialUpdate(id, patchedCustomFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this custom filter.
     * @param {CustomFilterRequest} customFilterRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiCustomFilterUpdate(id: number, customFilterRequest: CustomFilterRequest, options?: any) {
        return ApiApiFp(this.configuration).apiCustomFilterUpdate(id, customFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to download a user file securely (wrapping as zip to prevent any context based XSS problems) temporary solution until a real file manager is implemented
     * @param {number} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiDownloadFileRetrieve(fileId: number, options?: any) {
        return ApiApiFp(this.configuration).apiDownloadFileRetrieve(fileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExportLogRequest} exportLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogCreate(exportLogRequest: ExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogCreate(exportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {PatchedExportLogRequest} [patchedExportLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogPartialUpdate(id: number, patchedExportLogRequest?: PatchedExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogPartialUpdate(id, patchedExportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this export log.
     * @param {ExportLogRequest} exportLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiExportLogUpdate(id: number, exportLogRequest: ExportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiExportLogUpdate(id, exportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodCreate(foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodCreate(foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * updates the food with all possible data from the FDC Api if properties with a fdc_id already exist they will be overridden, if existing properties don\'t have a fdc_id they won\'t be changed
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodFdcCreate(id: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodFdcCreate(id, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodInheritFieldList(options?: any) {
        return ApiApiFp(this.configuration).apiFoodInheritFieldList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food inherit field.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodInheritFieldRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodInheritFieldRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiFoodList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodMergeUpdate(id: number, target: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodMergeUpdate(id, target, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodMoveUpdate(id: number, parent: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodMoveUpdate(id, parent, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {PatchedFoodRequest} [patchedFoodRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPartialUpdate(id: number, patchedFoodRequest?: PatchedFoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPartialUpdate(id, patchedFoodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyRequest} propertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyCreate(propertyRequest: PropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyCreate(propertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PatchedPropertyRequest} [patchedPropertyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyPartialUpdate(id: number, patchedPropertyRequest?: PatchedPropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyPartialUpdate(id, patchedPropertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PropertyTypeRequest} propertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeCreate(propertyTypeRequest: PropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeCreate(propertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>} [category] Return the PropertyTypes matching the property category.  Repeat for multiple.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeList(category?: Array<'ALLERGEN' | 'GOAL' | 'NUTRITION' | 'OTHER' | 'PRICE'>, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeList(category, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PatchedPropertyTypeRequest} [patchedPropertyTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypePartialUpdate(id: number, patchedPropertyTypeRequest?: PatchedPropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypePartialUpdate(id, patchedPropertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property type.
     * @param {PropertyTypeRequest} propertyTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyTypeUpdate(id: number, propertyTypeRequest: PropertyTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyTypeUpdate(id, propertyTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this property.
     * @param {PropertyRequest} propertyRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodPropertyUpdate(id: number, propertyRequest: PropertyRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodPropertyUpdate(id, propertyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiFoodRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodShoppingUpdateRequest} foodShoppingUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodShoppingUpdate(id: number, foodShoppingUpdateRequest: FoodShoppingUpdateRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodShoppingUpdate(id, foodShoppingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this food.
     * @param {FoodRequest} foodRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiFoodUpdate(id: number, foodRequest: FoodRequest, options?: any) {
        return ApiApiFp(this.configuration).apiFoodUpdate(id, foodRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGetExternalFileLinkRetrieve(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).apiGetExternalFileLinkRetrieve(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} recipeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGetRecipeFileRetrieve(recipeId: number, options?: any) {
        return ApiApiFp(this.configuration).apiGetRecipeFileRetrieve(recipeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGroupList(options?: any) {
        return ApiApiFp(this.configuration).apiGroupList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiGroupRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiGroupRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to handle files passed by application importer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportCreate(options?: any) {
        return ApiApiFp(this.configuration).apiImportCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ImportLogRequest} importLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogCreate(importLogRequest: ImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogCreate(importLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {PatchedImportLogRequest} [patchedImportLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogPartialUpdate(id: number, patchedImportLogRequest?: PatchedImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogPartialUpdate(id, patchedImportLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this import log.
     * @param {ImportLogRequest} importLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiImportLogUpdate(id: number, importLogRequest: ImportLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiImportLogUpdate(id, importLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IngredientRequest} ingredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientCreate(ingredientRequest: IngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientCreate(ingredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IngredientStringRequest} ingredientStringRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientFromStringCreate(ingredientStringRequest: IngredientStringRequest, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientFromStringCreate(ingredientStringRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [food] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [unit] ID of unit to filter for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientList(food?: number, page?: number, pageSize?: number, unit?: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientList(food, page, pageSize, unit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {PatchedIngredientRequest} [patchedIngredientRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientPartialUpdate(id: number, patchedIngredientRequest?: PatchedIngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientPartialUpdate(id, patchedIngredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this ingredient.
     * @param {IngredientRequest} ingredientRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiIngredientUpdate(id: number, ingredientRequest: IngredientRequest, options?: any) {
        return ApiApiFp(this.configuration).apiIngredientUpdate(id, ingredientRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InviteLinkRequest} inviteLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkCreate(inviteLinkRequest: InviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkCreate(inviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what internal_note is for.
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkList(internalNote?: string, limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkList(internalNote, limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {PatchedInviteLinkRequest} [patchedInviteLinkRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkPartialUpdate(id: number, patchedInviteLinkRequest?: PatchedInviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkPartialUpdate(id, patchedInviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this invite link.
     * @param {InviteLinkRequest} inviteLinkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiInviteLinkUpdate(id: number, inviteLinkRequest: InviteLinkRequest, options?: any) {
        return ApiApiFp(this.configuration).apiInviteLinkUpdate(id, inviteLinkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordCreate(keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordCreate(keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {number} [root] Return first level children of {obj} with ID [int].  Integer 0 will return root {obj}s.
     * @param {number} [tree] Return all self and children of {obj} with ID [int].
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, root?: number, tree?: number, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordList(limit, page, pageSize, query, random, root, tree, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordMergeUpdate(id: number, target: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordMergeUpdate(id, target, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {number} parent The ID of the desired parent of the {obj}.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordMoveUpdate(id: number, parent: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordMoveUpdate(id, parent, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {PatchedKeywordRequest} [patchedKeywordRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordPartialUpdate(id: number, patchedKeywordRequest?: PatchedKeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordPartialUpdate(id, patchedKeywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this keyword.
     * @param {KeywordRequest} keywordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiKeywordUpdate(id: number, keywordRequest: KeywordRequest, options?: any) {
        return ApiApiFp(this.configuration).apiKeywordUpdate(id, keywordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MealPlanRequest} mealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanCreate(mealPlanRequest: MealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanCreate(mealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanIcalRetrieve(fromDate?: string, mealType?: Array<string>, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanIcalRetrieve(fromDate, mealType, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [fromDate] Filter meal plans from date (inclusive).
     * @param {Array<string>} [mealType] Filter meal plans with MealType ID. For multiple repeat parameter.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [toDate] Filter meal plans to date (inclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanList(fromDate?: string, mealType?: Array<string>, page?: number, pageSize?: number, toDate?: string, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanList(fromDate, mealType, page, pageSize, toDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {PatchedMealPlanRequest} [patchedMealPlanRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanPartialUpdate(id: number, patchedMealPlanRequest?: PatchedMealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanPartialUpdate(id, patchedMealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this meal plan.
     * @param {MealPlanRequest} mealPlanRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealPlanUpdate(id: number, mealPlanRequest: MealPlanRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealPlanUpdate(id, mealPlanRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {MealTypeRequest} mealTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeCreate(mealTypeRequest: MealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeCreate(mealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {PatchedMealTypeRequest} [patchedMealTypeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypePartialUpdate(id: number, patchedMealTypeRequest?: PatchedMealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypePartialUpdate(id, patchedMealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * returns list of meal types created by the requesting user ordered by the order field.
     * @param {number} id A unique integer value identifying this meal type.
     * @param {MealTypeRequest} mealTypeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiMealTypeUpdate(id: number, mealTypeRequest: MealTypeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiMealTypeUpdate(id, mealTypeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookRequest} recipeBookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookCreate(recipeBookRequest: RecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookCreate(recipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryCreate(recipeBookEntryRequest: RecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryCreate(recipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [book] id of book - only return recipes in that book
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [recipe] id of recipe - only return books for that recipe
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryList(book?: number, page?: number, pageSize?: number, recipe?: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryList(book, page, pageSize, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {PatchedRecipeBookEntryRequest} [patchedRecipeBookEntryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryPartialUpdate(id: number, patchedRecipeBookEntryRequest?: PatchedRecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryPartialUpdate(id, patchedRecipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book entry.
     * @param {RecipeBookEntryRequest} recipeBookEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookEntryUpdate(id: number, recipeBookEntryRequest: RecipeBookEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookEntryUpdate(id, recipeBookEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {'asc' | 'desc'} [orderDirection] Order ascending or descending
     * @param {'id' | 'name' | 'order'} [orderField] Field to order recipe books on
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookList(limit?: string, orderDirection?: 'asc' | 'desc', orderField?: 'id' | 'name' | 'order', page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookList(limit, orderDirection, orderField, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {PatchedRecipeBookRequest} [patchedRecipeBookRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookPartialUpdate(id: number, patchedRecipeBookRequest?: PatchedRecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookPartialUpdate(id, patchedRecipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe book.
     * @param {RecipeBookRequest} recipeBookRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeBookUpdate(id: number, recipeBookRequest: RecipeBookRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeBookUpdate(id, recipeBookRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RecipeRequest} recipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeCreate(recipeRequest: RecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeCreate(recipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeFlatList(options?: any) {
        return ApiApiFp(this.configuration).apiRecipeFlatList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to retrieve a recipe from a given url or source string :param request: standard request with additional post parameters         - url: url to use for importing recipe         - data: if no url is given recipe is imported from provided source data         - (optional) bookmarklet: id of bookmarklet import to use, overrides URL and data attributes :return: JsonResponse containing the parsed json and images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeFromSourceCreate(options?: any) {
        return ApiApiFp(this.configuration).apiRecipeFromSourceCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {any} [image] 
     * @param {string} [imageUrl] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeImageUpdate(id: number, image?: any, imageUrl?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeImageUpdate(id, image, imageUrl, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<number>} [books] ID of book a recipe should be in. For multiple repeat parameter.
     * @param {Array<number>} [booksAnd] Book IDs, repeat for multiple. Return recipes with all of the books.
     * @param {Array<number>} [booksAndNot] Book IDs, repeat for multiple. Exclude recipes with all of the books.
     * @param {Array<number>} [booksOr] Book IDs, repeat for multiple. Return recipes with any of the books
     * @param {Array<number>} [booksOrNot] Book IDs, repeat for multiple. Exclude recipes with any of the books.
     * @param {string} [cookedon] Filter recipes last cooked on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [createdon] Filter recipes created on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {Array<number>} [foods] ID of food a recipe should have. For multiple repeat parameter.
     * @param {Array<number>} [foodsAnd] Food IDs, repeat for multiple. Return recipes with all of the foods.
     * @param {Array<number>} [foodsAndNot] Food IDs, repeat for multiple. Exclude recipes with all of the foods.
     * @param {Array<number>} [foodsOr] Food IDs, repeat for multiple. Return recipes with any of the foods
     * @param {Array<number>} [foodsOrNot] Food IDs, repeat for multiple. Exclude recipes with any of the foods.
     * @param {boolean} [internal] If only internal recipes should be returned. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {Array<number>} [keywords] ID of keyword a recipe should have. For multiple repeat parameter. Equivalent to keywords_or
     * @param {Array<number>} [keywordsAnd] Keyword IDs, repeat for multiple. Return recipes with all of the keywords.
     * @param {Array<number>} [keywordsAndNot] Keyword IDs, repeat for multiple. Exclude recipes with all of the keywords.
     * @param {Array<number>} [keywordsOr] Keyword IDs, repeat for multiple. Return recipes with any of the keywords
     * @param {Array<number>} [keywordsOrNot] Keyword IDs, repeat for multiple. Exclude recipes with any of the keywords.
     * @param {boolean} [makenow] Filter recipes that can be made with OnHand food. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {string} [_new] Returns new results first in search results. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against recipe name. In the future also fulltext search.
     * @param {string} [random] Returns the results in randomized order. [true/&lt;b&gt;false&lt;/b&gt;]
     * @param {number} [rating] Rating a recipe should have or greater. [0 - 5] Negative value filters rating less than.
     * @param {number} [timescooked] Filter recipes cooked X times or more.  Negative values returns cooked less than X times
     * @param {number} [units] ID of unit a recipe should have.
     * @param {string} [updatedon] Filter recipes updated on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {string} [viewedon] Filter recipes lasts viewed on or after YYYY-MM-DD. Prepending - filters on or before date.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeList(books?: Array<number>, booksAnd?: Array<number>, booksAndNot?: Array<number>, booksOr?: Array<number>, booksOrNot?: Array<number>, cookedon?: string, createdon?: string, foods?: Array<number>, foodsAnd?: Array<number>, foodsAndNot?: Array<number>, foodsOr?: Array<number>, foodsOrNot?: Array<number>, internal?: boolean, keywords?: Array<number>, keywordsAnd?: Array<number>, keywordsAndNot?: Array<number>, keywordsOr?: Array<number>, keywordsOrNot?: Array<number>, makenow?: boolean, _new?: string, page?: number, pageSize?: number, query?: string, random?: string, rating?: number, timescooked?: number, units?: number, updatedon?: string, viewedon?: string, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeList(books, booksAnd, booksAndNot, booksOr, booksOrNot, cookedon, createdon, foods, foodsAnd, foodsAndNot, foodsOr, foodsOrNot, internal, keywords, keywordsAnd, keywordsAndNot, keywordsOr, keywordsOrNot, makenow, _new, page, pageSize, query, random, rating, timescooked, units, updatedon, viewedon, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {PatchedRecipeRequest} [patchedRecipeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipePartialUpdate(id: number, patchedRecipeRequest?: PatchedRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipePartialUpdate(id, patchedRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeRelatedRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeRelatedRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeShoppingUpdateRequest} [recipeShoppingUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeShoppingUpdate(id: number, recipeShoppingUpdateRequest?: RecipeShoppingUpdateRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeShoppingUpdate(id, recipeShoppingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this recipe.
     * @param {RecipeRequest} recipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiRecipeUpdate(id: number, recipeRequest: RecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiRecipeUpdate(id, recipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * function to reset inheritance from api, see food method for docs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiResetFoodInheritanceCreate(options?: any) {
        return ApiApiFp(this.configuration).apiResetFoodInheritanceCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShareLinkRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShareLinkRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntryBulkRequest} shoppingListEntryBulkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest: ShoppingListEntryBulkRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryBulkCreate(shoppingListEntryBulkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryCreate(shoppingListEntryRequest: ShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryCreate(shoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [checked] Filter shopping list entries on checked.  [true, false, both, &lt;b&gt;recent&lt;/b&gt;]&lt;br&gt;                              - recent includes unchecked items and recently completed items.
     * @param {number} [id] Returns the shopping list entry with a primary key of id.  Multiple values allowed.
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {number} [supermarket] Returns the shopping list entries sorted by supermarket category order.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryList(checked?: string, id?: number, page?: number, pageSize?: number, supermarket?: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryList(checked, id, page, pageSize, supermarket, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {PatchedShoppingListEntryRequest} [patchedShoppingListEntryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryPartialUpdate(id: number, patchedShoppingListEntryRequest?: PatchedShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryPartialUpdate(id, patchedShoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list entry.
     * @param {ShoppingListEntryRequest} shoppingListEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListEntryUpdate(id: number, shoppingListEntryRequest: ShoppingListEntryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListEntryUpdate(id, shoppingListEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeCreate(shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeCreate(shoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {PatchedShoppingListRecipeRequest} [patchedShoppingListRecipeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipePartialUpdate(id: number, patchedShoppingListRecipeRequest?: PatchedShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipePartialUpdate(id, patchedShoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this shopping list recipe.
     * @param {ShoppingListRecipeRequest} shoppingListRecipeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiShoppingListRecipeUpdate(id: number, shoppingListRecipeRequest: ShoppingListRecipeRequest, options?: any) {
        return ApiApiFp(this.configuration).apiShoppingListRecipeUpdate(id, shoppingListRecipeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSpaceList(options?: any) {
        return ApiApiFp(this.configuration).apiSpaceList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {PatchedSpaceRequest} [patchedSpaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSpacePartialUpdate(id: number, patchedSpaceRequest?: PatchedSpaceRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSpacePartialUpdate(id, patchedSpaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSpaceRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSpaceRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StepRequest} stepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepCreate(stepRequest: StepRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStepCreate(stepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStepDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] Query string matched (fuzzy) against object name.
     * @param {Array<number>} [recipe] ID of recipe a step is part of. For multiple repeat parameter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepList(page?: number, pageSize?: number, query?: string, recipe?: Array<number>, options?: any) {
        return ApiApiFp(this.configuration).apiStepList(page, pageSize, query, recipe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {PatchedStepRequest} [patchedStepRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepPartialUpdate(id: number, patchedStepRequest?: PatchedStepRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStepPartialUpdate(id, patchedStepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStepRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this step.
     * @param {StepRequest} stepRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStepUpdate(id: number, stepRequest: StepRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStepUpdate(id, stepRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {StorageRequest} storageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageCreate(storageRequest: StorageRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStorageCreate(storageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStorageDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageList(options?: any) {
        return ApiApiFp(this.configuration).apiStorageList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {PatchedStorageRequest} [patchedStorageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStoragePartialUpdate(id: number, patchedStorageRequest?: PatchedStorageRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStoragePartialUpdate(id, patchedStorageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiStorageRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this storage.
     * @param {StorageRequest} storageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiStorageUpdate(id: number, storageRequest: StorageRequest, options?: any) {
        return ApiApiFp(this.configuration).apiStorageUpdate(id, storageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryCreate(supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryCreate(supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryMergeUpdate(id: number, target: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryMergeUpdate(id, target, supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {PatchedSupermarketCategoryRequest} [patchedSupermarketCategoryRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryPartialUpdate(id: number, patchedSupermarketCategoryRequest?: PatchedSupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryPartialUpdate(id, patchedSupermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationCreate(supermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {PatchedSupermarketCategoryRelationRequest} [patchedSupermarketCategoryRelationRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationPartialUpdate(id: number, patchedSupermarketCategoryRelationRequest?: PatchedSupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationPartialUpdate(id, patchedSupermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category relation.
     * @param {SupermarketCategoryRelationRequest} supermarketCategoryRelationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRelationUpdate(id: number, supermarketCategoryRelationRequest: SupermarketCategoryRelationRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRelationUpdate(id, supermarketCategoryRelationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket category.
     * @param {SupermarketCategoryRequest} supermarketCategoryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCategoryUpdate(id: number, supermarketCategoryRequest: SupermarketCategoryRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCategoryUpdate(id, supermarketCategoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SupermarketRequest} supermarketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketCreate(supermarketRequest: SupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketCreate(supermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {PatchedSupermarketRequest} [patchedSupermarketRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketPartialUpdate(id: number, patchedSupermarketRequest?: PatchedSupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketPartialUpdate(id, patchedSupermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this supermarket.
     * @param {SupermarketRequest} supermarketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSupermarketUpdate(id: number, supermarketRequest: SupermarketRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSupermarketUpdate(id, supermarketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * api endpoint to switch space function
     * @param {number} spaceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSwitchActiveSpaceRetrieve(spaceId: number, options?: any) {
        return ApiApiFp(this.configuration).apiSwitchActiveSpaceRetrieve(spaceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SyncRequest} syncRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncCreate(syncRequest: SyncRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSyncCreate(syncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {PatchedSyncRequest} [patchedSyncRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncPartialUpdate(id: number, patchedSyncRequest?: PatchedSyncRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSyncPartialUpdate(id, patchedSyncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiSyncRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this sync.
     * @param {SyncRequest} syncRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiSyncUpdate(id: number, syncRequest: SyncRequest, options?: any) {
        return ApiApiFp(this.configuration).apiSyncUpdate(id, syncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitConversionRequest} unitConversionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionCreate(unitConversionRequest: UnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionCreate(unitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [foodId] ID of food to filter for
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionList(foodId?: number, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionList(foodId, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {PatchedUnitConversionRequest} [patchedUnitConversionRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionPartialUpdate(id: number, patchedUnitConversionRequest?: PatchedUnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionPartialUpdate(id, patchedUnitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit conversion.
     * @param {UnitConversionRequest} unitConversionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitConversionUpdate(id: number, unitConversionRequest: UnitConversionRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitConversionUpdate(id, unitConversionRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitCreate(unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitCreate(unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiUnitList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {number} target The ID of the {obj} you want to merge with.
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitMergeUpdate(id: number, target: number, unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitMergeUpdate(id, target, unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {PatchedUnitRequest} [patchedUnitRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitPartialUpdate(id: number, patchedUnitRequest?: PatchedUnitRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitPartialUpdate(id, patchedUnitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUnitRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this unit.
     * @param {UnitRequest} unitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUnitUpdate(id: number, unitRequest: UnitRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUnitUpdate(id, unitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileCreate(name: string, file: any, id?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileCreate(name, file, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [limit] limit number of entries to return
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {string} [query] lookup if query string is contained within the name, case insensitive
     * @param {string} [random] randomly orders entries (only works together with limit)
     * @param {string} [updatedAt] if model has an updated_at timestamp, filter only models updated at or after datetime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileList(limit?: string, page?: number, pageSize?: number, query?: string, random?: string, updatedAt?: string, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileList(limit, page, pageSize, query, random, updatedAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {string} [name] 
     * @param {any} [file] 
     * @param {number} [id2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFilePartialUpdate(id: number, name?: string, file?: any, id2?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFilePartialUpdate(id, name, file, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user file.
     * @param {string} name 
     * @param {any} file 
     * @param {number} [id2] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserFileUpdate(id: number, name: string, file: any, id2?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserFileUpdate(id, name, file, id2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Array<string>} [filterList] User IDs, repeat for multiple
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserList(filterList?: Array<string>, options?: any) {
        return ApiApiFp(this.configuration).apiUserList(filterList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {PatchedUserRequest} [patchedUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPartialUpdate(id: number, patchedUserRequest?: PatchedUserRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUserPartialUpdate(id, patchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPreferenceList(options?: any) {
        return ApiApiFp(this.configuration).apiUserPreferenceList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {PatchedUserPreferenceRequest} [patchedUserPreferenceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPreferencePartialUpdate(user: number, patchedUserPreferenceRequest?: PatchedUserPreferenceRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUserPreferencePartialUpdate(user, patchedUserPreferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} user A unique value identifying this user preference.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserPreferenceRetrieve(user: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserPreferenceRetrieve(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [internalNote] I have no idea what this is
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceList(internalNote?: string, page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceList(internalNote, page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {PatchedUserSpaceRequest} [patchedUserSpaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpacePartialUpdate(id: number, patchedUserSpaceRequest?: PatchedUserSpaceRequest, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpacePartialUpdate(id, patchedUserSpaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this user space.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiUserSpaceRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiUserSpaceRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ViewLogRequest} viewLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogCreate(viewLogRequest: ViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogCreate(viewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogDestroy(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogDestroy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} [page] A page number within the paginated result set.
     * @param {number} [pageSize] Number of results to return per page.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogList(page?: number, pageSize?: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogList(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {PatchedViewLogRequest} [patchedViewLogRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogPartialUpdate(id: number, patchedViewLogRequest?: PatchedViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogPartialUpdate(id, patchedViewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogRetrieve(id: number, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id A unique integer value identifying this view log.
     * @param {ViewLogRequest} viewLogRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    public apiViewLogUpdate(id: number, viewLogRequest: ViewLogRequest, options?: any) {
        return ApiApiFp(this.configuration).apiViewLogUpdate(id, viewLogRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiImportOpenDataApi - axios parameter creator
 * @export
 */
export const ApiImportOpenDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataRetrieve: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/api-import-open-data/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiImportOpenDataApi - functional programming interface
 * @export
 */
export const ApiImportOpenDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiImportOpenDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportOpenDataCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportOpenDataCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiImportOpenDataRetrieve(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiImportOpenDataRetrieve(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiImportOpenDataApi - factory interface
 * @export
 */
export const ApiImportOpenDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiImportOpenDataApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataCreate(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportOpenDataCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiImportOpenDataRetrieve(options?: any): AxiosPromise<void> {
            return localVarFp.apiImportOpenDataRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiImportOpenDataApi - object-oriented interface
 * @export
 * @class ApiImportOpenDataApi
 * @extends {BaseAPI}
 */
export class ApiImportOpenDataApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public apiImportOpenDataCreate(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).apiImportOpenDataCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiImportOpenDataApi
     */
    public apiImportOpenDataRetrieve(options?: any) {
        return ApiImportOpenDataApiFp(this.configuration).apiImportOpenDataRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ApiTokenAuthApi - axios parameter creator
 * @export
 */
export const ApiTokenAuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenAuthCreate: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('apiTokenAuthCreate', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('apiTokenAuthCreate', 'password', password)
            const localVarPath = `/api-token-auth/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (username !== undefined) { 
                localVarFormParams.append('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ApiTokenAuthApi - functional programming interface
 * @export
 */
export const ApiTokenAuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ApiTokenAuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiTokenAuthCreate(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiTokenAuthCreate(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ApiTokenAuthApi - factory interface
 * @export
 */
export const ApiTokenAuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ApiTokenAuthApiFp(configuration)
    return {
        /**
         * 
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiTokenAuthCreate(username: string, password: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.apiTokenAuthCreate(username, password, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ApiTokenAuthApi - object-oriented interface
 * @export
 * @class ApiTokenAuthApi
 * @extends {BaseAPI}
 */
export class ApiTokenAuthApi extends BaseAPI {
    /**
     * 
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiTokenAuthApi
     */
    public apiTokenAuthCreate(username: string, password: string, options?: any) {
        return ApiTokenAuthApiFp(this.configuration).apiTokenAuthCreate(username, password, options).then((request) => request(this.axios, this.basePath));
    }
}


